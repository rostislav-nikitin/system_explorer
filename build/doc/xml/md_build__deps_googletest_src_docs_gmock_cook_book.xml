<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="md_build__deps_googletest_src_docs_gmock_cook_book" kind="page">
    <compoundname>md_build__deps_googletest_src_docs_gmock_cook_book</compoundname>
    <title>gMock Cookbook</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>You can find recipes for using gMock here. If you haven&apos;t yet, please read <ref refid="md_build__deps_googletest_src_docs_gmock_for_dummies" kindref="compound">the dummy guide</ref> first to make sure you understand the basics.</para>
<para>{: .callout .note} <bold>Note:</bold> gMock lives in the <computeroutput>testing</computeroutput> name space. For readability, it is recommended to write <computeroutput>using ::testing::Foo;</computeroutput> once in your file before using the name <computeroutput>Foo</computeroutput> defined by gMock. We omit such <computeroutput>using</computeroutput> statements in this section for brevity, but you should do it in your own code.</para>
<sect1 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md119">
<title>Creating Mock Classes</title>
<para><ref refid="classMock" kindref="compound">Mock</ref> classes are defined as normal classes, using the <computeroutput>MOCK_METHOD</computeroutput> macro to generate mocked methods. The macro gets 3 or 4 parameters:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyMock<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(ReturnType,<sp/>MethodName,<sp/>(Args...));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(ReturnType,<sp/>MethodName,<sp/>(Args...),<sp/>(Specs...));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>The first 3 parameters are simply the method declaration, split into 3 parts. The 4th parameter accepts a closed list of qualifiers, which affect the generated method:</para>
<para><itemizedlist>
<listitem><para>**<computeroutput>const</computeroutput>** - Makes the mocked method a <computeroutput>const</computeroutput> method. Required if overriding a <computeroutput>const</computeroutput> method.</para>
</listitem><listitem><para>**<computeroutput>override</computeroutput>** - Marks the method with <computeroutput>override</computeroutput>. Recommended if overriding a <computeroutput>virtual</computeroutput> method.</para>
</listitem><listitem><para>**<computeroutput>noexcept</computeroutput>** - Marks the method with <computeroutput>noexcept</computeroutput>. Required if overriding a <computeroutput>noexcept</computeroutput> method.</para>
</listitem><listitem><para>**<computeroutput>Calltype(...)</computeroutput>** - Sets the call type for the method (e.g. to <computeroutput>STDMETHODCALLTYPE</computeroutput>), useful in Windows.</para>
</listitem><listitem><para>**<computeroutput>ref(...)</computeroutput>** - Marks the method with the reference qualification specified. Required if overriding a method that has reference qualifications. Eg <computeroutput>ref(&amp;)</computeroutput> or <computeroutput>ref(&amp;&amp;)</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md120">
<title>Dealing with unprotected commas</title>
<para>Unprotected commas, i.e. commas which are not surrounded by parentheses, prevent <computeroutput>MOCK_METHOD</computeroutput> from parsing its arguments correctly:</para>
<para>{: .bad} <programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(std::pair&lt;bool,<sp/>int&gt;,<sp/>GetPair,<sp/>());<sp/><sp/></highlight><highlight class="comment">//<sp/>Won&apos;t<sp/>compile!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>CheckMap,<sp/>(std::map&lt;int,<sp/>double&gt;,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">));<sp/><sp/></highlight><highlight class="comment">//<sp/>Won&apos;t<sp/>compile!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Solution 1 - wrap with parentheses:</para>
<para>{: .good} <programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD((std::pair&lt;bool,<sp/>int&gt;),<sp/>GetPair,<sp/>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>CheckMap,<sp/>((std::map&lt;int,<sp/>double&gt;),<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Note that wrapping a return or argument type with parentheses is, in general, invalid C++. <computeroutput>MOCK_METHOD</computeroutput> removes the parentheses.</para>
<para>Solution 2 - define an alias:</para>
<para>{: .good} <programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">BoolAndInt<sp/>=<sp/>std::pair&lt;bool,<sp/>int&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(BoolAndInt,<sp/>GetPair,<sp/>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">MapIntDouble<sp/>=<sp/>std::map&lt;int,<sp/>double&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>CheckMap,<sp/>(MapIntDouble,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md121">
<title>Mocking Private or Protected Methods</title>
<para>You must always put a mock method definition (<computeroutput>MOCK_METHOD</computeroutput>) in a <computeroutput>public:</computeroutput> section of the mock class, regardless of the method being mocked being <computeroutput>public</computeroutput>, <computeroutput>protected</computeroutput>, or <computeroutput>private</computeroutput> in the base class. This allows <computeroutput>ON_CALL</computeroutput> and <computeroutput>EXPECT_CALL</computeroutput> to reference the mock function from outside of the mock class. (Yes, C++ allows a subclass to change the access level of a virtual function in the base class.) Example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Transform(Gadget*<sp/>g)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">protected</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Resume();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>GetTimeOut();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>Transform,<sp/>(Gadget*<sp/>g),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>following<sp/>must<sp/>be<sp/>in<sp/>the<sp/>public<sp/>section,<sp/>even<sp/>though<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>methods<sp/>are<sp/>protected<sp/>or<sp/>private<sp/>in<sp/>the<sp/>base<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Resume,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>GetTimeOut,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md122">
<title>Mocking Overloaded Methods</title>
<para>You can mock overloaded functions as usual. No special attention is required:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Must<sp/>be<sp/>virtual<sp/>as<sp/>we&apos;ll<sp/>inherit<sp/>from<sp/>Foo.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~Foo();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Overloaded<sp/>on<sp/>the<sp/>types<sp/>and/or<sp/>numbers<sp/>of<sp/>arguments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Add(Element<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Add(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>times,<sp/>Element<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Overloaded<sp/>on<sp/>the<sp/>const-ness<sp/>of<sp/>this<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>Bar&amp;<sp/>GetBar();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Bar&amp;<sp/>GetBar()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>Add,<sp/>(Element<sp/>x),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>Add,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>times,<sp/>Element<sp/>x),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>{: .callout .note} <bold>Note:</bold> if you don&apos;t mock all versions of the overloaded method, the compiler will give you a warning about some methods in the base class being hidden. To fix that, use <computeroutput>using</computeroutput> to bring them in scope:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Foo::Add;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>Add,<sp/>(Element<sp/>x),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>don&apos;t<sp/>want<sp/>to<sp/>mock<sp/>int<sp/>Add(int<sp/>times,<sp/>Element<sp/>x);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md123">
<title>Mocking Class Templates</title>
<para>You can mock class templates just like any class.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Elem&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">StackInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Must<sp/>be<sp/>virtual<sp/>as<sp/>we&apos;ll<sp/>inherit<sp/>from<sp/>StackInterface.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~StackInterface();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>GetSize()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Push(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Elem&amp;<sp/>x)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Elem&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockStack<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>StackInterface&lt;Elem&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>GetSize,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Push,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Elem&amp;<sp/>x),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1MockingNonVirtualMethods">
<title>Mocking Non-virtual Methods</title>
<para>gMock can mock non-virtual functions to be used in Hi-perf dependency injection.</para>
<para>In this case, instead of sharing a common base class with the real class, your mock class will be <emphasis>unrelated</emphasis> to the real class, but contain methods with the same signatures. The syntax for mocking non-virtual methods is the <emphasis>same</emphasis> as mocking virtual methods (just don&apos;t add <computeroutput>override</computeroutput>):</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>A<sp/>simple<sp/>packet<sp/>stream<sp/>class.<sp/><sp/>None<sp/>of<sp/>its<sp/>members<sp/>is<sp/>virtual.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">ConcretePacketStream<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AppendPacket(Packet*<sp/>new_packet);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Packet*<sp/>GetPacket(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>packet_number)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>NumberOfPackets()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>mock<sp/>packet<sp/>stream<sp/>class.<sp/><sp/>It<sp/>inherits<sp/>from<sp/>no<sp/>other,<sp/>but<sp/>defines</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>GetPacket()<sp/>and<sp/>NumberOfPackets().</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockPacketStream<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Packet*,<sp/>GetPacket,<sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>packet_number),<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">,<sp/>NumberOfPackets,<sp/>(),<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Note that the mock class doesn&apos;t define <computeroutput>AppendPacket()</computeroutput>, unlike the real class. That&apos;s fine as long as the test doesn&apos;t need to call it.</para>
<para>Next, you need a way to say that you want to use <computeroutput>ConcretePacketStream</computeroutput> in production code, and use <computeroutput>MockPacketStream</computeroutput> in tests. Since the functions are not virtual and the two classes are unrelated, you must specify your choice at <emphasis>compile time</emphasis> (as opposed to run time).</para>
<para>One way to do it is to templatize your code that needs to use a packet stream. More specifically, you will give your code a template type argument for the type of the packet stream. In production, you will instantiate your template with <computeroutput>ConcretePacketStream</computeroutput> as the type argument. In tests, you will instantiate the same template with <computeroutput>MockPacketStream</computeroutput>. For example, you may write:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PacketStream&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>CreateConnection(PacketStream*<sp/>stream)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PacketStream&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">PacketReader<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ReadPackets(PacketStream*<sp/>stream,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>packet_num);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Then you can use <computeroutput>CreateConnection&lt;ConcretePacketStream&gt;()</computeroutput> and <computeroutput>PacketReader&lt;ConcretePacketStream&gt;</computeroutput> in production code, and use <computeroutput>CreateConnection&lt;MockPacketStream&gt;()</computeroutput> and <computeroutput>PacketReader&lt;MockPacketStream&gt;</computeroutput> in tests.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MockPacketStream<sp/>mock_stream;</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock_stream,<sp/>...)...;</highlight></codeline>
<codeline><highlight class="normal">..<sp/>set<sp/>more<sp/>expectations<sp/>on<sp/>mock_stream<sp/>...</highlight></codeline>
<codeline><highlight class="normal">PacketReader&lt;MockPacketStream&gt;<sp/>reader(&amp;mock_stream);</highlight></codeline>
<codeline><highlight class="normal">...<sp/>exercise<sp/>reader<sp/>...</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md124">
<title>Mocking Free Functions</title>
<para>It is not possible to directly mock a free function (i.e. a C-style function or a static method). If you need to, you can rewrite your code to use an interface (abstract class).</para>
<para>Instead of calling a free function (say, <computeroutput>OpenFile</computeroutput>) directly, introduce an interface for it and have a concrete subclass that calls the free function:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">FileInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Open(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>path,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>mode)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">File<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>FileInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Open(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>path,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>mode)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>OpenFile(path,<sp/>mode);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Your code should talk to <computeroutput>FileInterface</computeroutput> to open a file. Now it&apos;s easy to mock out the function.</para>
<para>This may seem like a lot of hassle, but in practice you often have multiple related functions that you can put in the same interface, so the per-function syntactic overhead will be much lower.</para>
<para>If you are concerned about the performance overhead incurred by virtual functions, and profiling confirms your concern, you can combine this with the recipe for <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1MockingNonVirtualMethods" kindref="member">mocking non-virtual methods</ref>.</para>
<para>Alternatively, instead of introducing a new interface, you can rewrite your code to accept a std::function instead of the free function, and then use <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1MockFunction" kindref="member">MockFunction</ref> to mock the std::function.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md125">
<title>Old-Style &lt;tt&gt;MOCK_METHODn&lt;/tt&gt; Macros</title>
<para>Before the generic <computeroutput>MOCK_METHOD</computeroutput> macro <ulink url="https://github.com/google/googletest/commit/c5f08bf91944ce1b19bcf414fa1760e69d20afc2">was introduced in 2018</ulink>, mocks where created using a family of macros collectively called <computeroutput>MOCK_METHODn</computeroutput>. These macros are still supported, though migration to the new <computeroutput>MOCK_METHOD</computeroutput> is recommended.</para>
<para>The macros in the <computeroutput>MOCK_METHODn</computeroutput> family differ from <computeroutput>MOCK_METHOD</computeroutput>:</para>
<para><itemizedlist>
<listitem><para>The general structure is <computeroutput>MOCK_METHODn(MethodName, ReturnType(Args))</computeroutput>, instead of <computeroutput>MOCK_METHOD(ReturnType, MethodName, (Args))</computeroutput>.</para>
</listitem><listitem><para>The number <computeroutput>n</computeroutput> must equal the number of arguments.</para>
</listitem><listitem><para>When mocking a const method, one must use <computeroutput>MOCK_CONST_METHODn</computeroutput>.</para>
</listitem><listitem><para>When mocking a class template, the macro name must be suffixed with <computeroutput>_T</computeroutput>.</para>
</listitem><listitem><para>In order to specify the call type, the macro name must be suffixed with <computeroutput>_WITH_CALLTYPE</computeroutput>, and the call type is the first macro argument.</para>
</listitem></itemizedlist>
</para>
<para>Old macros and their new equivalents:</para>
<para><table rows="24" cols="2"><row>
<entry thead="yes" colspan="2"><para>Simple </para>
</entry></row>
<row>
<entry thead="no"><para>Old </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD1(Foo, bool(int))</computeroutput>  </para>
</entry></row>
<row>
<entry thead="no"><para>New </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD(bool, Foo, (int))</computeroutput> </para>
<para></para>
</entry></row>
<row>
<entry thead="yes" colspan="2"><para>Const Method </para>
</entry></row>
<row>
<entry thead="no"><para>Old </para>
</entry><entry thead="no"><para><computeroutput>MOCK_CONST_METHOD1(Foo, bool(int))</computeroutput>  </para>
</entry></row>
<row>
<entry thead="no"><para>New </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD(bool, Foo, (int), (const))</computeroutput> </para>
<para></para>
</entry></row>
<row>
<entry thead="yes" colspan="2"><para>Method in a Class Template </para>
</entry></row>
<row>
<entry thead="no"><para>Old </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD1_T(Foo, bool(int))</computeroutput>  </para>
</entry></row>
<row>
<entry thead="no"><para>New </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD(bool, Foo, (int))</computeroutput> </para>
<para></para>
</entry></row>
<row>
<entry thead="yes" colspan="2"><para>Const Method in a Class Template </para>
</entry></row>
<row>
<entry thead="no"><para>Old </para>
</entry><entry thead="no"><para><computeroutput>MOCK_CONST_METHOD1_T(Foo, bool(int))</computeroutput>  </para>
</entry></row>
<row>
<entry thead="no"><para>New </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD(bool, Foo, (int), (const))</computeroutput> </para>
<para></para>
</entry></row>
<row>
<entry thead="yes" colspan="2"><para>Method with Call Type </para>
</entry></row>
<row>
<entry thead="no"><para>Old </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</computeroutput>  </para>
</entry></row>
<row>
<entry thead="no"><para>New </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))</computeroutput> </para>
<para></para>
</entry></row>
<row>
<entry thead="yes" colspan="2"><para>Const Method with Call Type </para>
</entry></row>
<row>
<entry thead="no"><para>Old </para>
</entry><entry thead="no"><para><computeroutput>MOCK_CONST_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</computeroutput>  </para>
</entry></row>
<row>
<entry thead="no"><para>New </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))</computeroutput> </para>
<para></para>
</entry></row>
<row>
<entry thead="yes" colspan="2"><para>Method with Call Type in a Class Template </para>
</entry></row>
<row>
<entry thead="no"><para>Old </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</computeroutput>  </para>
</entry></row>
<row>
<entry thead="no"><para>New </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))</computeroutput> </para>
<para></para>
</entry></row>
<row>
<entry thead="yes" colspan="2"><para>Const Method with Call Type in a Class Template </para>
</entry></row>
<row>
<entry thead="no"><para>Old </para>
</entry><entry thead="no"><para><computeroutput>MOCK_CONST_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</computeroutput>  </para>
</entry></row>
<row>
<entry thead="no"><para>New </para>
</entry><entry thead="no"><para><computeroutput>MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))</computeroutput>  </para>
</entry></row>
</table>
</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1NiceStrictNaggy">
<title>The Nice, the Strict, and the Naggy</title>
<para>If a mock method has no <computeroutput>EXPECT_CALL</computeroutput> spec but is called, we say that it&apos;s an &quot;uninteresting call&quot;, and the default action (which can be specified using <computeroutput>ON_CALL()</computeroutput>) of the method will be taken. Currently, an uninteresting call will also by default cause gMock to print a warning.</para>
<para>However, sometimes you may want to ignore these uninteresting calls, and sometimes you may want to treat them as errors. gMock lets you make the decision on a per-mock-object basis.</para>
<para>Suppose your test uses a mock class <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If a method of <computeroutput>mock_foo</computeroutput> other than <computeroutput>DoThis()</computeroutput> is called, you will get a warning. However, if you rewrite your test to use <computeroutput>NiceMock&lt;<ref refid="classMockFoo" kindref="compound">MockFoo</ref>&gt;</computeroutput> instead, you can suppress the warning:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::NiceMock;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockFoo&gt;<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><computeroutput>NiceMock&lt;<ref refid="classMockFoo" kindref="compound">MockFoo</ref>&gt;</computeroutput> is a subclass of <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput>, so it can be used wherever <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput> is accepted.</para>
<para>It also works if <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput>&apos;s constructor takes some arguments, as <computeroutput>NiceMock&lt;<ref refid="classMockFoo" kindref="compound">MockFoo</ref>&gt;</computeroutput> &quot;inherits&quot; <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput>&apos;s constructors:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::NiceMock;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockFoo&gt;<sp/>mock_foo(5,<sp/></highlight><highlight class="stringliteral">&quot;hi&quot;</highlight><highlight class="normal">);<sp/><sp/></highlight><highlight class="comment">//<sp/>Calls<sp/>MockFoo(5,<sp/>&quot;hi&quot;).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The usage of <computeroutput>StrictMock</computeroutput> is similar, except that it makes all uninteresting calls failures:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::StrictMock;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>StrictMock&lt;MockFoo&gt;<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>test<sp/>will<sp/>fail<sp/>if<sp/>a<sp/>method<sp/>of<sp/>mock_foo<sp/>other<sp/>than<sp/>DoThis()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>is<sp/>called.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>{: .callout .note} NOTE: <computeroutput>NiceMock</computeroutput> and <computeroutput>StrictMock</computeroutput> only affects <emphasis>uninteresting</emphasis> calls (calls of <emphasis>methods</emphasis> with no expectations); they do not affect <emphasis>unexpected</emphasis> calls (calls of methods with expectations, but they don&apos;t match). See <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1uninteresting-vs-unexpected" kindref="member">Understanding Uninteresting vs Unexpected Calls</ref>.</para>
<para>There are some caveats though (sadly they are side effects of C++&apos;s limitations):</para>
<para><orderedlist>
<listitem><para><computeroutput>NiceMock&lt;<ref refid="classMockFoo" kindref="compound">MockFoo</ref>&gt;</computeroutput> and <computeroutput>StrictMock&lt;<ref refid="classMockFoo" kindref="compound">MockFoo</ref>&gt;</computeroutput> only work for mock methods defined using the <computeroutput>MOCK_METHOD</computeroutput> macro <bold>directly</bold> in the <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput> class. If a mock method is defined in a <bold>base class</bold> of <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput>, the &quot;nice&quot; or &quot;strict&quot; modifier may not affect it, depending on the compiler. In particular, nesting <computeroutput>NiceMock</computeroutput> and <computeroutput>StrictMock</computeroutput> (e.g. <computeroutput>NiceMock&lt;StrictMock&lt;<ref refid="classMockFoo" kindref="compound">MockFoo</ref>&gt; &gt;</computeroutput>) is <bold>not</bold> supported.</para>
</listitem><listitem><para><computeroutput>NiceMock&lt;<ref refid="classMockFoo" kindref="compound">MockFoo</ref>&gt;</computeroutput> and <computeroutput>StrictMock&lt;<ref refid="classMockFoo" kindref="compound">MockFoo</ref>&gt;</computeroutput> may not work correctly if the destructor of <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput> is not virtual. We would like to fix this, but it requires cleaning up existing tests.</para>
</listitem></orderedlist>
</para>
<para>Finally, you should be <bold>very cautious</bold> about when to use naggy or strict mocks, as they tend to make tests more brittle and harder to maintain. When you refactor your code without changing its externally visible behavior, ideally you shouldn&apos;t need to update any tests. If your code interacts with a naggy mock, however, you may start to get spammed with warnings as the result of your change. Worse, if your code interacts with a strict mock, your tests may start to fail and you&apos;ll be forced to fix them. Our general recommendation is to use nice mocks (not yet the default) most of the time, use naggy mocks (the current default) when developing or debugging tests, and use strict mocks only as the last resort.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1SimplerInterfaces">
<title>Simplifying the Interface without Breaking Existing Code</title>
<para>Sometimes a method has a long list of arguments that is mostly uninteresting. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">LogSink<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>send(LogSeverity<sp/>severity,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>full_filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>base_filename,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>line,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>tm*<sp/>tm_time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>message,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>message_len)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>This method&apos;s argument list is lengthy and hard to work with (the <computeroutput>message</computeroutput> argument is not even 0-terminated). If we mock it as is, using the mock will be awkward. If, however, we try to simplify this interface, we&apos;ll need to fix all clients depending on it, which is often infeasible.</para>
<para>The trick is to redispatch the method in the mock class:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">ScopedMockLog<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>LogSink<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>send(LogSeverity<sp/>severity,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>full_filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>base_filename,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>line,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>tm*<sp/>tm_time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>message,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>message_len)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>only<sp/>interested<sp/>in<sp/>the<sp/>log<sp/>severity,<sp/>full<sp/>file<sp/>name,<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>log<sp/>message.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Log(severity,<sp/>full_filename,<sp/>std::string(message,<sp/>message_len));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Implements<sp/>the<sp/>mock<sp/>method:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>void<sp/>Log(LogSeverity<sp/>severity,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>string&amp;<sp/>file_path,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>string&amp;<sp/>message);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Log,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(LogSeverity<sp/>severity,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>file_path,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>message));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>By defining a new mock method with a trimmed argument list, we make the mock class more user-friendly.</para>
<para>This technique may also be applied to make overloaded methods more amenable to mocking. For example, when overloads have been used to implement default arguments:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockTurtleFactory<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>TurtleFactory<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Turtle*<sp/>MakeTurtle(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>length,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>weight)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Turtle*<sp/>MakeTurtle(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>length,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>weight,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>speed)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>above<sp/>methods<sp/>delegate<sp/>to<sp/>this<sp/>one:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Turtle*,<sp/>DoMakeTurtle,<sp/>());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>This allows tests that don&apos;t care which overload was invoked to avoid specifying argument matchers:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ON_CALL(factory,<sp/>DoMakeTurtle)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillByDefault(Return(MakeMockTurtle()));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md126">
<title>Alternative to Mocking Concrete Classes</title>
<para>Often you may find yourself using classes that don&apos;t implement interfaces. In order to test your code that uses such a class (let&apos;s call it <computeroutput>Concrete</computeroutput>), you may be tempted to make the methods of <computeroutput>Concrete</computeroutput> virtual and then mock it.</para>
<para>Try not to do that.</para>
<para>Making a non-virtual function virtual is a big decision. It creates an extension point where subclasses can tweak your class&apos; behavior. This weakens your control on the class because now it&apos;s harder to maintain the class invariants. You should make a function virtual only when there is a valid reason for a subclass to override it.</para>
<para>Mocking concrete classes directly is problematic as it creates a tight coupling between the class and the tests - any small change in the class may invalidate your tests and make test maintenance a pain.</para>
<para>To avoid such problems, many programmers have been practicing &quot;coding to
interfaces&quot;: instead of talking to the <computeroutput>Concrete</computeroutput> class, your code would define an interface and talk to it. Then you implement that interface as an adaptor on top of <computeroutput>Concrete</computeroutput>. In tests, you can easily mock that interface to observe how your code is doing.</para>
<para>This technique incurs some overhead:</para>
<para><itemizedlist>
<listitem><para>You pay the cost of virtual function calls (usually not a problem).</para>
</listitem><listitem><para>There is more abstraction for the programmers to learn.</para>
</listitem></itemizedlist>
</para>
<para>However, it can also bring significant benefits in addition to better testability:</para>
<para><itemizedlist>
<listitem><para><computeroutput>Concrete</computeroutput>&apos;s API may not fit your problem domain very well, as you may not be the only client it tries to serve. By designing your own interface, you have a chance to tailor it to your need - you may add higher-level functionalities, rename stuff, etc instead of just trimming the class. This allows you to write your code (user of the interface) in a more natural way, which means it will be more readable, more maintainable, and you&apos;ll be more productive.</para>
</listitem><listitem><para>If <computeroutput>Concrete</computeroutput>&apos;s implementation ever has to change, you don&apos;t have to rewrite everywhere it is used. Instead, you can absorb the change in your implementation of the interface, and your other code and tests will be insulated from this change.</para>
</listitem></itemizedlist>
</para>
<para>Some people worry that if everyone is practicing this technique, they will end up writing lots of redundant code. This concern is totally understandable. However, there are two reasons why it may not be the case:</para>
<para><itemizedlist>
<listitem><para>Different projects may need to use <computeroutput>Concrete</computeroutput> in different ways, so the best interfaces for them will be different. Therefore, each of them will have its own domain-specific interface on top of <computeroutput>Concrete</computeroutput>, and they will not be the same code.</para>
</listitem><listitem><para>If enough projects want to use the same interface, they can always share it, just like they have been sharing <computeroutput>Concrete</computeroutput>. You can check in the interface and the adaptor somewhere near <computeroutput>Concrete</computeroutput> (perhaps in a <computeroutput>contrib</computeroutput> sub-directory) and let many projects use it.</para>
</listitem></itemizedlist>
</para>
<para>You need to weigh the pros and cons carefully for your particular problem, but I&apos;d like to assure you that the Java community has been practicing this for a long time and it&apos;s a proven effective technique applicable in a wide variety of situations. :-)</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1DelegatingToFake">
<title>Delegating Calls to a Fake</title>
<para>Some times you have a non-trivial fake implementation of an interface. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~Foo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>DoThis(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DoThat(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>s,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>p)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">FakeFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>DoThis(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(n<sp/>&gt;<sp/>0)<sp/>?<sp/></highlight><highlight class="charliteral">&apos;+&apos;</highlight><highlight class="normal"><sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(n<sp/>&lt;<sp/>0)<sp/>?<sp/></highlight><highlight class="charliteral">&apos;-&apos;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="charliteral">&apos;0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DoThat(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>s,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>p)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*p<sp/>=<sp/>strlen(s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Now you want to mock this interface such that you can set expectations on it. However, you also want to use <computeroutput>FakeFoo</computeroutput> for the default behavior, as duplicating it in the mock object is, well, a lot of work.</para>
<para>When you define the mock class using gMock, you can have it delegate its default action to a fake class you already have, using this pattern:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Normal<sp/>mock<sp/>method<sp/>definitions<sp/>using<sp/>gMock.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">,<sp/>DoThis,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>DoThat,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>s,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>p),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Delegates<sp/>the<sp/>default<sp/>actions<sp/>of<sp/>the<sp/>methods<sp/>to<sp/>a<sp/>FakeFoo<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>must<sp/>be<sp/>called<sp/>*before*<sp/>the<sp/>custom<sp/>ON_CALL()<sp/>statements.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DelegateToFake()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>DoThis).WillByDefault([</highlight><highlight class="keyword">this</highlight><highlight class="normal">](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>fake_.DoThis(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>DoThat).WillByDefault([</highlight><highlight class="keyword">this</highlight><highlight class="normal">](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>s,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>fake_.DoThat(s,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FakeFoo<sp/>fake_;<sp/><sp/></highlight><highlight class="comment">//<sp/>Keeps<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>fake<sp/>in<sp/>the<sp/>mock.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>With that, you can use <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput> in your tests as usual. Just remember that if you don&apos;t explicitly set an action in an <computeroutput>ON_CALL()</computeroutput> or <computeroutput>EXPECT_CALL()</computeroutput>, the fake will be called upon to do it.:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST(AbcTest,<sp/>Xyz)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DelegateToFake();<sp/><sp/></highlight><highlight class="comment">//<sp/>Enables<sp/>the<sp/>fake<sp/>for<sp/>delegation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Put<sp/>your<sp/>ON_CALL(foo,<sp/>...)s<sp/>here,<sp/>if<sp/>any.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>action<sp/>specified,<sp/>meaning<sp/>to<sp/>use<sp/>the<sp/>default<sp/>action.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(_,<sp/>_));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(foo.DoThis(5),<sp/></highlight><highlight class="charliteral">&apos;+&apos;</highlight><highlight class="normal">);<sp/><sp/></highlight><highlight class="comment">//<sp/>FakeFoo::DoThis()<sp/>is<sp/>invoked.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat(</highlight><highlight class="stringliteral">&quot;Hi&quot;</highlight><highlight class="normal">,<sp/>&amp;n);<sp/><sp/></highlight><highlight class="comment">//<sp/>FakeFoo::DoThat()<sp/>is<sp/>invoked.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(n,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><bold>Some tips:</bold></para>
<para><itemizedlist>
<listitem><para>If you want, you can still override the default action by providing your own <computeroutput>ON_CALL()</computeroutput> or using <computeroutput>.WillOnce()</computeroutput> / <computeroutput>.WillRepeatedly()</computeroutput> in <computeroutput>EXPECT_CALL()</computeroutput>.</para>
</listitem><listitem><para>In <computeroutput>DelegateToFake()</computeroutput>, you only need to delegate the methods whose fake implementation you intend to use.</para>
</listitem><listitem><para>The general technique discussed here works for overloaded methods, but you&apos;ll need to tell the compiler which version you mean. To disambiguate a mock function (the one you specify inside the parentheses of <computeroutput>ON_CALL()</computeroutput>), use <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1SelectOverload" kindref="member">this technique</ref>; to disambiguate a fake function (the one you place inside <computeroutput>Invoke()</computeroutput>), use a <computeroutput>static_cast</computeroutput> to specify the function&apos;s type. For instance, if class <computeroutput>Foo</computeroutput> has methods <computeroutput>char DoThis(int
    n)</computeroutput> and <computeroutput>bool DoThis(double x) const</computeroutput>, and you want to invoke the latter, you need to write <computeroutput>Invoke(&amp;fake_, static_cast&lt;bool (FakeFoo::*)(double) const&gt;(&amp;FakeFoo::DoThis))</computeroutput> instead of <computeroutput>Invoke(&amp;fake_, &amp;FakeFoo::DoThis)</computeroutput> (The strange-looking thing inside the angled brackets of <computeroutput>static_cast</computeroutput> is the type of a function pointer to the second <computeroutput>DoThis()</computeroutput> method.).</para>
</listitem><listitem><para>Having to mix a mock and a fake is often a sign of something gone wrong. Perhaps you haven&apos;t got used to the interaction-based way of testing yet. Or perhaps your interface is taking on too many roles and should be split up. Therefore, <bold>don&apos;t abuse this</bold>. We would only recommend to do it as an intermediate step when you are refactoring your code.</para>
</listitem></itemizedlist>
</para>
<para>Regarding the tip on mixing a mock and a fake, here&apos;s an example on why it may be a bad sign: Suppose you have a class <computeroutput>System</computeroutput> for low-level system operations. In particular, it does file and I/O operations. And suppose you want to test how your code uses <computeroutput>System</computeroutput> to do I/O, and you just want the file operations to work normally. If you mock out the entire <computeroutput>System</computeroutput> class, you&apos;ll have to provide a fake implementation for the file operation part, which suggests that <computeroutput>System</computeroutput> is taking on too many roles.</para>
<para>Instead, you can define a <computeroutput>FileOps</computeroutput> interface and an <computeroutput>IOOps</computeroutput> interface and split <computeroutput>System</computeroutput>&apos;s functionalities into the two. Then you can mock <computeroutput>IOOps</computeroutput> without mocking <computeroutput>FileOps</computeroutput>.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md127">
<title>Delegating Calls to a Real Object</title>
<para>When using testing doubles (mocks, fakes, stubs, and etc), sometimes their behaviors will differ from those of the real objects. This difference could be either intentional (as in simulating an error such that you can test the error handling code) or unintentional. If your mocks have different behaviors than the real objects by mistake, you could end up with code that passes the tests but fails in production.</para>
<para>You can use the <emphasis>delegating-to-real</emphasis> technique to ensure that your mock has the same behavior as the real object while retaining the ability to validate calls. This technique is very similar to the <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1DelegatingToFake" kindref="member">delegating-to-fake</ref> technique, the difference being that we use a real object instead of a fake. Here&apos;s an example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::AtLeast;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>By<sp/>default,<sp/>all<sp/>calls<sp/>are<sp/>delegated<sp/>to<sp/>the<sp/>real<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>DoThis).WillByDefault([</highlight><highlight class="keyword">this</highlight><highlight class="normal">](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>real_.DoThis(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>DoThat).WillByDefault([</highlight><highlight class="keyword">this</highlight><highlight class="normal">](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>s,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>real_.DoThat(s,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">,<sp/>DoThis,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>DoThat,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo<sp/>real_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>DoThat(</highlight><highlight class="stringliteral">&quot;Hi&quot;</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AtLeast(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>mock<sp/>in<sp/>test<sp/>...</highlight></codeline>
</programlisting></para>
<para>With this, gMock will verify that your code made the right calls (with the right arguments, in the right order, called the right number of times, etc), and a real object will answer the calls (so the behavior will be the same as in production). This gives you the best of both worlds.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md128">
<title>Delegating Calls to a Parent Class</title>
<para>Ideally, you should code to interfaces, whose methods are all pure virtual. In reality, sometimes you do need to mock a virtual method that is not pure (i.e, it already has an implementation). For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~Foo();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Pure(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Concrete(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Mocking<sp/>a<sp/>pure<sp/>method.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Pure,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Mocking<sp/>a<sp/>concrete<sp/>method.<sp/><sp/>Foo::Concrete()<sp/>is<sp/>shadowed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>Concrete,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Sometimes you may want to call <computeroutput>Foo::Concrete()</computeroutput> instead of <computeroutput>MockFoo::Concrete()</computeroutput>. Perhaps you want to do it as part of a stub action, or perhaps your test doesn&apos;t need to mock <computeroutput>Concrete()</computeroutput> at all (but it would be oh-so painful to have to define a new mock class whenever you don&apos;t need to mock one of its methods).</para>
<para>You can call <computeroutput>Foo::Concrete()</computeroutput> inside an action by:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Concrete).WillOnce([&amp;foo](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>foo.Foo::Concrete(str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
</programlisting></para>
<para>or tell the mock object that you don&apos;t want to mock <computeroutput>Concrete()</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Concrete).WillByDefault([&amp;foo](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>foo.Foo::Concrete(str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
</programlisting></para>
<para>(Why don&apos;t we just write <computeroutput>{ return foo.Concrete(str); }</computeroutput>? If you do that, <computeroutput>MockFoo::Concrete()</computeroutput> will be called (and cause an infinite recursion) since <computeroutput>Foo::Concrete()</computeroutput> is virtual. That&apos;s just how C++ works.)</para>
</sect2>
</sect1>
<sect1 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md129">
<title>Using Matchers</title>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md130">
<title>Matching Argument Values Exactly</title>
<para>You can specify exactly which arguments a mock method is expecting:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Return(</highlight><highlight class="charliteral">&apos;a&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(</highlight><highlight class="stringliteral">&quot;Hello&quot;</highlight><highlight class="normal">,<sp/>bar));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md131">
<title>Using Simple Matchers</title>
<para>You can use matchers to match arguments that have a certain property:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(Ge(5)))<sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>&gt;=<sp/>5.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Return(</highlight><highlight class="charliteral">&apos;a&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(</highlight><highlight class="stringliteral">&quot;Hello&quot;</highlight><highlight class="normal">,<sp/>NotNull()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>second<sp/>argument<sp/>must<sp/>not<sp/>be<sp/>NULL.</highlight></codeline>
</programlisting></para>
<para>A frequently used matcher is <computeroutput>_</computeroutput>, which matches anything:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>DoThat(_,<sp/>NotNull()));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1CombiningMatchers">
<title>Combining Matchers</title>
<para>You can build complex matchers from existing ones using <computeroutput>AllOf()</computeroutput>, <computeroutput>AllOfArray()</computeroutput>, <computeroutput>AnyOf()</computeroutput>, <computeroutput>AnyOfArray()</computeroutput> and <computeroutput>Not()</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::HasSubstr;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ne;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Not;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>&gt;<sp/>5<sp/>and<sp/>!=<sp/>10.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(AllOf(Gt(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ne(10))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>first<sp/>argument<sp/>must<sp/>not<sp/>contain<sp/>sub-string<sp/>&quot;blah&quot;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(Not(HasSubstr(</highlight><highlight class="stringliteral">&quot;blah&quot;</highlight><highlight class="normal">)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NULL));</highlight></codeline>
</programlisting></para>
<para>Matchers are function objects, and parametrized matchers can be composed just like any other function. However because their types can be long and rarely provide meaningful information, it can be easier to express them with C++14 generic lambdas to avoid specifying types. For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Contains;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Property;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>HasFoo<sp/>=<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>f)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Property(</highlight><highlight class="stringliteral">&quot;foo&quot;</highlight><highlight class="normal">,<sp/>&amp;MyClass::foo,<sp/>Contains(f));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(x,<sp/>HasFoo(</highlight><highlight class="stringliteral">&quot;blah&quot;</highlight><highlight class="normal">));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1SafeMatcherCast">
<title>Casting Matchers</title>
<para>gMock matchers are statically typed, meaning that the compiler can catch your mistake if you use a matcher of the wrong type (for example, if you use <computeroutput>Eq(5)</computeroutput> to match a <computeroutput>string</computeroutput> argument). Good for you!</para>
<para>Sometimes, however, you know what you&apos;re doing and want the compiler to give you some slack. One example is that you have a matcher for <computeroutput>long</computeroutput> and the argument you want to match is <computeroutput>int</computeroutput>. While the two types aren&apos;t exactly the same, there is nothing really wrong with using a <computeroutput>Matcher&lt;long&gt;</computeroutput> to match an <computeroutput>int</computeroutput> - after all, we can first convert the <computeroutput>int</computeroutput> argument to a <computeroutput>long</computeroutput> losslessly before giving it to the matcher.</para>
<para>To support this need, gMock gives you the <computeroutput>SafeMatcherCast&lt;T&gt;(m)</computeroutput> function. It casts a matcher <computeroutput>m</computeroutput> to type <computeroutput>Matcher&lt;T&gt;</computeroutput>. To ensure safety, gMock checks that (let <computeroutput>U</computeroutput> be the type <computeroutput>m</computeroutput> accepts :</para>
<para><orderedlist>
<listitem><para>Type <computeroutput>T</computeroutput> can be <emphasis>implicitly</emphasis> cast to type <computeroutput>U</computeroutput>;</para>
</listitem><listitem><para>When both <computeroutput>T</computeroutput> and <computeroutput>U</computeroutput> are built-in arithmetic types (<computeroutput>bool</computeroutput>, integers, and floating-point numbers), the conversion from <computeroutput>T</computeroutput> to <computeroutput>U</computeroutput> is not lossy (in other words, any value representable by <computeroutput>T</computeroutput> can also be represented by <computeroutput>U</computeroutput>); and</para>
</listitem><listitem><para>When <computeroutput>U</computeroutput> is a reference, <computeroutput>T</computeroutput> must also be a reference (as the underlying matcher may be interested in the address of the <computeroutput>U</computeroutput> value).</para>
</listitem></orderedlist>
</para>
<para>The code won&apos;t compile if any of these conditions isn&apos;t met.</para>
<para>Here&apos;s one example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::SafeMatcherCast;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>base<sp/>class<sp/>and<sp/>a<sp/>child<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classBase" kindref="compound">Base</ref><sp/>{<sp/>...<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Derived<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classBase" kindref="compound">Base</ref><sp/>{<sp/>...<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>DoThis,<sp/>(Derived*<sp/>derived),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>m<sp/>is<sp/>a<sp/>Matcher&lt;Base*&gt;<sp/>we<sp/>got<sp/>from<sp/>somewhere.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(SafeMatcherCast&lt;Derived*&gt;(m)));</highlight></codeline>
</programlisting></para>
<para>If you find <computeroutput>SafeMatcherCast&lt;T&gt;(m)</computeroutput> too limiting, you can use a similar function <computeroutput>MatcherCast&lt;T&gt;(m)</computeroutput>. The difference is that <computeroutput>MatcherCast</computeroutput> works as long as you can <computeroutput>static_cast</computeroutput> type <computeroutput>T</computeroutput> to type <computeroutput>U</computeroutput>.</para>
<para><computeroutput>MatcherCast</computeroutput> essentially lets you bypass C++&apos;s type system (<computeroutput>static_cast</computeroutput> isn&apos;t always safe as it could throw away information, for example), so be careful not to misuse/abuse it.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1SelectOverload">
<title>Selecting Between Overloaded Functions</title>
<para>If you expect an overloaded function to be called, the compiler may need some help on which overloaded version it is.</para>
<para>To disambiguate functions overloaded on the const-ness of this object, use the <computeroutput>Const()</computeroutput> argument wrapper.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::ReturnRef;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>bar1,<sp/>bar2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetBar())<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>non-const<sp/>GetBar().</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(Const(foo),<sp/>GetBar())<sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>const<sp/>GetBar().</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar2));</highlight></codeline>
</programlisting></para>
<para>(<computeroutput>Const()</computeroutput> is defined by gMock and returns a <computeroutput>const</computeroutput> reference to its argument.)</para>
<para>To disambiguate overloaded functions with the same number of arguments but different argument types, you may need to specify the exact type of a matcher, either by wrapping your matcher in <computeroutput>Matcher&lt;type&gt;()</computeroutput>, or using a matcher whose type is fixed (<computeroutput>TypedEq&lt;type&gt;</computeroutput>, <computeroutput>An&lt;type&gt;()</computeroutput>, etc):</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::An;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::TypedEq;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockPrinter<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Printer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Print,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Print,<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST(PrinterTest,<sp/>Print)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockPrinter<sp/>printer;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(An&lt;int&gt;()));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>void<sp/>Print(int);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(Matcher&lt;int&gt;(Lt(5))));<sp/><sp/></highlight><highlight class="comment">//<sp/>void<sp/>Print(int);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(TypedEq&lt;char&gt;(</highlight><highlight class="charliteral">&apos;a&apos;</highlight><highlight class="normal">)));<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>void<sp/>Print(char);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(</highlight><highlight class="charliteral">&apos;a&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md132">
<title>Performing Different Actions Based on the Arguments</title>
<para>When a mock method is called, the <emphasis>last</emphasis> matching expectation that&apos;s still active will be selected (think &quot;newer overrides older&quot;). So, you can make a method do different things depending on its argument values like this:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>default<sp/>case.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(</highlight><highlight class="charliteral">&apos;b&apos;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>more<sp/>specific<sp/>case.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(Lt(5)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(</highlight><highlight class="charliteral">&apos;a&apos;</highlight><highlight class="normal">));</highlight></codeline>
</programlisting></para>
<para>Now, if <computeroutput>foo.DoThis()</computeroutput> is called with a value less than 5, <lsquo/>&apos;a<rsquo/><computeroutput>will be returned; otherwise</computeroutput>&apos;b&apos;` will be returned.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md133">
<title>Matching Multiple Arguments as a Whole</title>
<para>Sometimes it&apos;s not enough to match the arguments individually. For example, we may want to say that the first argument must be less than the second argument. The <computeroutput>With()</computeroutput> clause allows us to match all arguments of a mock function as a whole. For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ne;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>InRange(Ne(0),<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.With(Lt());</highlight></codeline>
</programlisting></para>
<para>says that the first argument of <computeroutput>InRange()</computeroutput> must not be 0, and must be less than the second argument.</para>
<para>The expression inside <computeroutput>With()</computeroutput> must be a matcher of type <computeroutput>Matcher&lt;std::tuple&lt;A1, ..., An&gt;&gt;</computeroutput>, where <computeroutput>A1</computeroutput>, ..., <computeroutput>An</computeroutput> are the types of the function arguments.</para>
<para>You can also write <computeroutput>AllArgs(m)</computeroutput> instead of <computeroutput>m</computeroutput> inside <computeroutput>.With()</computeroutput>. The two forms are equivalent, but <computeroutput>.With(AllArgs(Lt()))</computeroutput> is more readable than <computeroutput>.With(Lt())</computeroutput>.</para>
<para>You can use <computeroutput>Args&lt;k1, ..., kn&gt;(m)</computeroutput> to match the <computeroutput>n</computeroutput> selected arguments (as a tuple) against <computeroutput>m</computeroutput>. For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Args;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Blah)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.With(AllOf(Args&lt;0,<sp/>1&gt;(Lt()),<sp/>Args&lt;1,<sp/>2&gt;(Lt())));</highlight></codeline>
</programlisting></para>
<para>says that <computeroutput>Blah</computeroutput> will be called with arguments <computeroutput>x</computeroutput>, <computeroutput>y</computeroutput>, and <computeroutput>z</computeroutput> where <computeroutput>x &lt; y &lt; z</computeroutput>. Note that in this example, it wasn&apos;t necessary to specify the positional matchers.</para>
<para>As a convenience and example, gMock provides some matchers for 2-tuples, including the <computeroutput>Lt()</computeroutput> matcher above. See <ulink url="reference/matchers.md#MultiArgMatchers">Multi-argument Matchers</ulink> for the complete list.</para>
<para>Note that if you want to pass the arguments to a predicate of your own (e.g. <computeroutput>.With(Args&lt;0, 1&gt;(Truly(&amp;MyPredicate)))</computeroutput>), that predicate MUST be written to take a <computeroutput>std::tuple</computeroutput> as its argument; gMock will pass the <computeroutput>n</computeroutput> selected arguments as <emphasis>one</emphasis> single tuple to the predicate.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md134">
<title>Using Matchers as Predicates</title>
<para>Have you noticed that a matcher is just a fancy predicate that also knows how to describe itself? Many existing algorithms take predicates as arguments (e.g. those defined in STL&apos;s <computeroutput>&lt;algorithm&gt;</computeroutput> header), and it would be a shame if gMock matchers were not allowed to participate.</para>
<para>Luckily, you can use a matcher where a unary predicate functor is expected by wrapping it inside the <computeroutput>Matches()</computeroutput> function. For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matches;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">vector&lt;int&gt;<sp/>v;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>How<sp/>many<sp/>elements<sp/>in<sp/>v<sp/>are<sp/>&gt;=<sp/>10?</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">const<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>count_if(v.begin(),<sp/>v.end(),<sp/>Matches(Ge(10)));</highlight></codeline>
</programlisting></para>
<para>Since you can build complex matchers from simpler ones easily using gMock, this gives you a way to conveniently construct composite predicates (doing the same using STL&apos;s <computeroutput>&lt;functional&gt;</computeroutput> header is just painful). For example, here&apos;s a predicate that&apos;s satisfied by any number that is &gt;= 0, &lt;= 100, and != 50:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Le;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matches;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ne;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">Matches(AllOf(Ge(0),<sp/>Le(100),<sp/>Ne(50)))</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md135">
<title>Using Matchers in googletest Assertions</title>
<para>See <ulink url="reference/assertions.md#EXPECT_THAT"><computeroutput>EXPECT_THAT</computeroutput></ulink> in the Assertions Reference.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md136">
<title>Using Predicates as Matchers</title>
<para>gMock provides a set of built-in matchers for matching arguments with expected valuessee the <ref refid="md_build__deps_googletest_src_docs_reference_matchers" kindref="compound">Matchers Reference</ref> for more information. In case you find the built-in set lacking, you can use an arbitrary unary predicate function or functor as a matcher - as long as the predicate accepts a value of the type you want. You do this by wrapping the predicate inside the <computeroutput>Truly()</computeroutput> function, for example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Truly;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>IsEven(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(n<sp/>%<sp/>2)<sp/>==<sp/>0<sp/>?<sp/>1<sp/>:<sp/>0;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Bar()<sp/>must<sp/>be<sp/>called<sp/>with<sp/>an<sp/>even<sp/>number.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Truly(IsEven)));</highlight></codeline>
</programlisting></para>
<para>Note that the predicate function / functor doesn&apos;t have to return <computeroutput>bool</computeroutput>. It works as long as the return value can be used as the condition in the statement <computeroutput>if (condition) ...</computeroutput>.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md137">
<title>Matching Arguments that Are Not Copyable</title>
<para>When you do an <computeroutput>EXPECT_CALL(mock_obj, Foo(bar))</computeroutput>, gMock saves away a copy of <computeroutput>bar</computeroutput>. When <computeroutput>Foo()</computeroutput> is called later, gMock compares the argument to <computeroutput>Foo()</computeroutput> with the saved copy of <computeroutput>bar</computeroutput>. This way, you don&apos;t need to worry about <computeroutput>bar</computeroutput> being modified or destroyed after the <computeroutput>EXPECT_CALL()</computeroutput> is executed. The same is true when you use matchers like <computeroutput>Eq(bar)</computeroutput>, <computeroutput>Le(bar)</computeroutput>, and so on.</para>
<para>But what if <computeroutput>bar</computeroutput> cannot be copied (i.e. has no copy constructor)? You could define your own matcher function or callback and use it with <computeroutput>Truly()</computeroutput>, as the previous couple of recipes have shown. Or, you may be able to get away from it if you can guarantee that <computeroutput>bar</computeroutput> won&apos;t be changed after the <computeroutput>EXPECT_CALL()</computeroutput> is executed. Just tell gMock that it should save a reference to <computeroutput>bar</computeroutput>, instead of a copy of it. Here&apos;s how:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Eq;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Expects<sp/>that<sp/>Foo()&apos;s<sp/>argument<sp/>==<sp/>bar.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_obj,<sp/>Foo(Eq(std::ref(bar))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Expects<sp/>that<sp/>Foo()&apos;s<sp/>argument<sp/>&lt;<sp/>bar.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_obj,<sp/>Foo(Lt(std::ref(bar))));</highlight></codeline>
</programlisting></para>
<para>Remember: if you do this, don&apos;t change <computeroutput>bar</computeroutput> after the <computeroutput>EXPECT_CALL()</computeroutput>, or the result is undefined.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md138">
<title>Validating a Member of an Object</title>
<para>Often a mock function takes a reference to object as an argument. When matching the argument, you may not want to compare the entire object against a fixed object, as that may be over-specification. Instead, you may need to validate a certain member variable or the result of a certain getter method of the object. You can do this with <computeroutput>Field()</computeroutput> and <computeroutput>Property()</computeroutput>. More specifically,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">Field(&amp;Foo::bar,<sp/>m)</highlight></codeline>
</programlisting></para>
<para>is a matcher that matches a <computeroutput>Foo</computeroutput> object whose <computeroutput>bar</computeroutput> member variable satisfies matcher <computeroutput>m</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">Property(&amp;Foo::baz,<sp/>m)</highlight></codeline>
</programlisting></para>
<para>is a matcher that matches a <computeroutput>Foo</computeroutput> object whose <computeroutput>baz()</computeroutput> method returns a value that satisfies matcher <computeroutput>m</computeroutput>.</para>
<para>For example:</para>
<para><table rows="3" cols="2"><row>
<entry thead="yes" align='left'><para>Expression   </para>
</entry><entry thead="yes" align='left'><para>Description    </para>
</entry></row>
<row>
<entry thead="no" align='left'><para><computeroutput>Field(&amp;Foo::number, Ge(3))</computeroutput>   </para>
</entry><entry thead="no" align='left'><para>Matches <computeroutput>x</computeroutput> where <computeroutput>x.number &gt;= 3</computeroutput>.    </para>
</entry></row>
<row>
<entry thead="no" align='left'><para><computeroutput>Property(&amp;Foo::name, StartsWith(&quot;John &quot;))</computeroutput>   </para>
</entry><entry thead="no" align='left'><para>Matches <computeroutput>x</computeroutput> where <computeroutput>x.name()</computeroutput> starts with <computeroutput>&quot;John &quot;</computeroutput>.   </para>
</entry></row>
</table>
</para>
<para>Note that in <computeroutput>Property(&amp;Foo::baz, ...)</computeroutput>, method <computeroutput>baz()</computeroutput> must take no argument and be declared as <computeroutput>const</computeroutput>. Don&apos;t use <computeroutput>Property()</computeroutput> against member functions that you do not own, because taking addresses of functions is fragile and generally not part of the contract of the function.</para>
<para><computeroutput>Field()</computeroutput> and <computeroutput>Property()</computeroutput> can also match plain pointers to objects. For instance,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Field;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">Field(&amp;Foo::number,<sp/>Ge(3))</highlight></codeline>
</programlisting></para>
<para>matches a plain pointer <computeroutput>p</computeroutput> where <computeroutput>p-&gt;number &gt;= 3</computeroutput>. If <computeroutput>p</computeroutput> is <computeroutput>NULL</computeroutput>, the match will always fail regardless of the inner matcher.</para>
<para>What if you want to validate more than one members at the same time? Remember that there are <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1CombiningMatchers" kindref="member">`AllOf()` and `AllOfArray()`</ref>.</para>
<para>Finally <computeroutput>Field()</computeroutput> and <computeroutput>Property()</computeroutput> provide overloads that take the field or property names as the first argument to include it in the error message. This can be useful when creating combined matchers.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Field;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SafeMatcherCast;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Matcher&lt;Foo&gt;<sp/>IsFoo(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Foo&amp;<sp/>foo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AllOf(Field(</highlight><highlight class="stringliteral">&quot;some_field&quot;</highlight><highlight class="normal">,<sp/>&amp;Foo::some_field,<sp/>foo.some_field),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Field(</highlight><highlight class="stringliteral">&quot;other_field&quot;</highlight><highlight class="normal">,<sp/>&amp;Foo::other_field,<sp/>foo.other_field),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Field(</highlight><highlight class="stringliteral">&quot;last_field&quot;</highlight><highlight class="normal">,<sp/>&amp;Foo::last_field,<sp/>foo.last_field));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md139">
<title>Validating the Value Pointed to by a Pointer Argument</title>
<para>C++ functions often take pointers as arguments. You can use matchers like <computeroutput>IsNull()</computeroutput>, <computeroutput>NotNull()</computeroutput>, and other comparison matchers to match a pointer, but what if you want to make sure the value <emphasis>pointed to</emphasis> by the pointer, instead of the pointer itself, has a certain property? Well, you can use the <computeroutput>Pointee(m)</computeroutput> matcher.</para>
<para><computeroutput>Pointee(m)</computeroutput> matches a pointer if and only if <computeroutput>m</computeroutput> matches the value the pointer points to. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Pointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Pointee(Ge(3))));</highlight></codeline>
</programlisting></para>
<para>expects <computeroutput>foo.Bar()</computeroutput> to be called with a pointer that points to a value greater than or equal to 3.</para>
<para>One nice thing about <computeroutput>Pointee()</computeroutput> is that it treats a <computeroutput>NULL</computeroutput> pointer as a match failure, so you can write <computeroutput>Pointee(m)</computeroutput> instead of</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Pointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AllOf(NotNull(),<sp/>Pointee(m))</highlight></codeline>
</programlisting></para>
<para>without worrying that a <computeroutput>NULL</computeroutput> pointer will crash your test.</para>
<para>Also, did we tell you that <computeroutput>Pointee()</computeroutput> works with both raw pointers <bold>and</bold> smart pointers (<computeroutput>std::unique_ptr</computeroutput>, <computeroutput>std::shared_ptr</computeroutput>, etc)?</para>
<para>What if you have a pointer to pointer? You guessed it - you can use nested <computeroutput>Pointee()</computeroutput> to probe deeper inside the value. For example, <computeroutput>Pointee(Pointee(Lt(3)))</computeroutput> matches a pointer that points to a pointer that points to a number less than 3 (what a mouthful...).</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1CustomMatcherClass">
<title>Defining a Custom Matcher Class</title>
<para>Most matchers can be simply defined using <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1NewMatchers" kindref="member">the MATCHER* macros</ref>, which are terse and flexible, and produce good error messages. However, these macros are not very explicit about the interfaces they create and are not always suitable, especially for matchers that will be widely reused.</para>
<para>For more advanced cases, you may need to define your own matcher class. A custom matcher allows you to test a specific invariant property of that object. Let&apos;s take a look at how to do so.</para>
<para>Imagine you have a mock function that takes an object of type <computeroutput>Foo</computeroutput>, which has an <computeroutput>int bar()</computeroutput> method and an <computeroutput>int baz()</computeroutput> method. You want to constrain that the argument&apos;s <computeroutput>bar()</computeroutput> value plus its <computeroutput>baz()</computeroutput> value is a given number. (This is an invariant.) Here&apos;s how we can write and use a matcher class to do so:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">BarPlusBazEqMatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">is_gtest_matcher<sp/>=<sp/>void;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">explicit</highlight><highlight class="normal"><sp/>BarPlusBazEqMatcher(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>expected_sum)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>expected_sum_(expected_sum)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>MatchAndExplain(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Foo&amp;<sp/>foo,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream*<sp/></highlight><highlight class="comment">/*<sp/>listener<sp/>*/</highlight><highlight class="normal">)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(foo.bar()<sp/>+<sp/>foo.baz())<sp/>==<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;bar()<sp/>+<sp/>baz()<sp/>equals<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeNegationTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;bar()<sp/>+<sp/>baz()<sp/>does<sp/>not<sp/>equal<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtesting_1_1Matcher" kindref="compound">::testing::Matcher&lt;const Foo&amp;&gt;</ref><sp/>BarPlusBazEq(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>expected_sum)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>BarPlusBazEqMatcher(expected_sum);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(foo,<sp/>BarPlusBazEq(5))...;</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md140">
<title>Matching Containers</title>
<para>Sometimes an STL container (e.g. list, vector, map, ...) is passed to a mock function and you may want to validate it. Since most STL containers support the <computeroutput>==</computeroutput> operator, you can write <computeroutput>Eq(expected_container)</computeroutput> or simply <computeroutput>expected_container</computeroutput> to match a container exactly.</para>
<para>Sometimes, though, you may want to be more flexible (for example, the first element must be an exact match, but the second element can be any positive number, and so on). Also, containers used in tests often have a small number of elements, and having to define the expected container out-of-line is a bit of a hassle.</para>
<para>You can use the <computeroutput>ElementsAre()</computeroutput> or <computeroutput>UnorderedElementsAre()</computeroutput> matcher in such cases:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ElementsAre;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Foo,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>vector&lt;int&gt;&amp;<sp/>numbers),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAre(1,<sp/>Gt(0),<sp/>_,<sp/>5)));</highlight></codeline>
</programlisting></para>
<para>The above matcher says that the container must have 4 elements, which must be 1, greater than 0, anything, and 5 respectively.</para>
<para>If you instead write:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::UnorderedElementsAre;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Foo,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>vector&lt;int&gt;&amp;<sp/>numbers),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(UnorderedElementsAre(1,<sp/>Gt(0),<sp/>_,<sp/>5)));</highlight></codeline>
</programlisting></para>
<para>It means that the container must have 4 elements, which (under some permutation) must be 1, greater than 0, anything, and 5 respectively.</para>
<para>As an alternative you can place the arguments in a C-style array and use <computeroutput>ElementsAreArray()</computeroutput> or <computeroutput>UnorderedElementsAreArray()</computeroutput> instead:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::ElementsAreArray;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>ElementsAreArray<sp/>accepts<sp/>an<sp/>array<sp/>of<sp/>element<sp/>values.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>expected_vector1[]<sp/>=<sp/>{1,<sp/>5,<sp/>2,<sp/>4,<sp/>...};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector1)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Or,<sp/>an<sp/>array<sp/>of<sp/>element<sp/>matchers.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matcher&lt;int&gt;<sp/>expected_vector2[]<sp/>=<sp/>{1,<sp/>Gt(2),<sp/>_,<sp/>3,<sp/>...};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector2)));</highlight></codeline>
</programlisting></para>
<para>In case the array needs to be dynamically created (and therefore the array size cannot be inferred by the compiler), you can give <computeroutput>ElementsAreArray()</computeroutput> an additional argument to specify the array size:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::ElementsAreArray;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>expected_vector3<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">[count];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>fill<sp/>expected_vector3<sp/>with<sp/>values<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector3,<sp/>count)));</highlight></codeline>
</programlisting></para>
<para>Use <computeroutput>Pair</computeroutput> when comparing maps or other associative containers.</para>
<para>{% raw %}</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::UnorderedElementsAre;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Pair;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>absl::flat_hash_map&lt;string,<sp/>int&gt;<sp/>m<sp/>=<sp/>{{</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">,<sp/>1},<sp/>{</highlight><highlight class="stringliteral">&quot;b&quot;</highlight><highlight class="normal">,<sp/>2},<sp/>{</highlight><highlight class="stringliteral">&quot;c&quot;</highlight><highlight class="normal">,<sp/>3}};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(m,<sp/>UnorderedElementsAre(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Pair(</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">,<sp/>1),<sp/>Pair(</highlight><highlight class="stringliteral">&quot;b&quot;</highlight><highlight class="normal">,<sp/>2),<sp/>Pair(</highlight><highlight class="stringliteral">&quot;c&quot;</highlight><highlight class="normal">,<sp/>3)));</highlight></codeline>
</programlisting></para>
<para>{% endraw %}</para>
<para><bold>Tips:</bold></para>
<para><itemizedlist>
<listitem><para><computeroutput>ElementsAre*()</computeroutput> can be used to match <emphasis>any</emphasis> container that implements the STL iterator pattern (i.e. it has a <computeroutput>const_iterator</computeroutput> type and supports <computeroutput>begin()/end()</computeroutput>), not just the ones defined in STL. It will even work with container types yet to be written - as long as they follows the above pattern.</para>
</listitem><listitem><para>You can use nested <computeroutput>ElementsAre*()</computeroutput> to match nested (multi-dimensional) containers.</para>
</listitem><listitem><para>If the container is passed by pointer instead of by reference, just write <computeroutput>Pointee(ElementsAre*(...))</computeroutput>.</para>
</listitem><listitem><para>The order of elements <emphasis>matters</emphasis> for <computeroutput>ElementsAre*()</computeroutput>. If you are using it with containers whose element order are undefined (such as a <computeroutput>std::unordered_map</computeroutput>) you should use <computeroutput>UnorderedElementsAre</computeroutput>.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md141">
<title>Sharing Matchers</title>
<para>Under the hood, a gMock matcher object consists of a pointer to a ref-counted implementation object. Copying matchers is allowed and very efficient, as only the pointer is copied. When the last matcher that references the implementation object dies, the implementation object will be deleted.</para>
<para>Therefore, if you have some complex matcher that you want to use again and again, there is no need to build it every time. Just assign it to a matcher variable and use that variable repeatedly! For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Le;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matcher&lt;int&gt;<sp/>in_range<sp/>=<sp/>AllOf(Gt(5),<sp/>Le(10));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>in_range<sp/>as<sp/>a<sp/>matcher<sp/>in<sp/>multiple<sp/>EXPECT_CALLs<sp/>...</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1PureMatchers">
<title>Matchers must have no side-effects</title>
<para>{: .callout .warning} WARNING: gMock does not guarantee when or how many times a matcher will be invoked. Therefore, all matchers must be <emphasis>purely functional</emphasis>: they cannot have any side effects, and the match result must not depend on anything other than the matcher&apos;s parameters and the value being matched.</para>
<para>This requirement must be satisfied no matter how a matcher is defined (e.g., if it is one of the standard matchers, or a custom matcher). In particular, a matcher can never call a mock function, as that will affect the state of the mock object and gMock.</para>
</sect2>
</sect1>
<sect1 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md142">
<title>Setting Expectations</title>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1UseOnCall">
<title>Knowing When to Expect</title>
<para>**<computeroutput>ON_CALL</computeroutput>** is likely the <emphasis>single most under-utilized construct</emphasis> in gMock.</para>
<para>There are basically two constructs for defining the behavior of a mock object: <computeroutput>ON_CALL</computeroutput> and <computeroutput>EXPECT_CALL</computeroutput>. The difference? <computeroutput>ON_CALL</computeroutput> defines what happens when a mock method is called, but <emphasis>doesn&apos;t imply any expectation on the method being called</emphasis>. <computeroutput>EXPECT_CALL</computeroutput> not only defines the behavior, but also sets an expectation that <emphasis>the method will be called with the given arguments, for the given number of times</emphasis> (and <emphasis>in the given order</emphasis> when you specify the order too).</para>
<para>Since <computeroutput>EXPECT_CALL</computeroutput> does more, isn&apos;t it better than <computeroutput>ON_CALL</computeroutput>? Not really. Every <computeroutput>EXPECT_CALL</computeroutput> adds a constraint on the behavior of the code under test. Having more constraints than necessary is <emphasis>baaad</emphasis> - even worse than not having enough constraints.</para>
<para>This may be counter-intuitive. How could tests that verify more be worse than tests that verify less? Isn&apos;t verification the whole point of tests?</para>
<para>The answer lies in <emphasis>what</emphasis> a test should verify. <bold>A good test verifies the contract of the code.</bold> If a test over-specifies, it doesn&apos;t leave enough freedom to the implementation. As a result, changing the implementation without breaking the contract (e.g. refactoring and optimization), which should be perfectly fine to do, can break such tests. Then you have to spend time fixing them, only to see them broken again the next time the implementation is changed.</para>
<para>Keep in mind that one doesn&apos;t have to verify more than one property in one test. In fact, <bold>it&apos;s a good style to verify only one thing in one test.</bold> If you do that, a bug will likely break only one or two tests instead of dozens (which case would you rather debug?). If you are also in the habit of giving tests descriptive names that tell what they verify, you can often easily guess what&apos;s wrong just from the test log itself.</para>
<para>So use <computeroutput>ON_CALL</computeroutput> by default, and only use <computeroutput>EXPECT_CALL</computeroutput> when you actually intend to verify that the call is made. For example, you may have a bunch of <computeroutput>ON_CALL</computeroutput>s in your test fixture to set the common mock behavior shared by all tests in the same group, and write (scarcely) different <computeroutput>EXPECT_CALL</computeroutput>s in different <computeroutput>TEST_F</computeroutput>s to verify different aspects of the code&apos;s behavior. Compared with the style where each <computeroutput>TEST</computeroutput> has many <computeroutput>EXPECT_CALL</computeroutput>s, this leads to tests that are more resilient to implementational changes (and thus less likely to require maintenance) and makes the intent of the tests more obvious (so they are easier to maintain when you do need to maintain them).</para>
<para>If you are bothered by the &quot;Uninteresting mock function call&quot; message printed when a mock method without an <computeroutput>EXPECT_CALL</computeroutput> is called, you may use a <computeroutput>NiceMock</computeroutput> instead to suppress all such messages for the mock object, or suppress the message for specific methods by adding <computeroutput>EXPECT_CALL(...).Times(AnyNumber())</computeroutput>. DO NOT suppress it by blindly adding an <computeroutput>EXPECT_CALL(...)</computeroutput>, or you&apos;ll have a test that&apos;s a pain to maintain.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md143">
<title>Ignoring Uninteresting Calls</title>
<para>If you are not interested in how a mock method is called, just don&apos;t say anything about it. In this case, if the method is ever called, gMock will perform its default action to allow the test program to continue. If you are not happy with the default action taken by gMock, you can override it using <computeroutput>DefaultValue&lt;T&gt;::Set()</computeroutput> (described <ref refid="md_build__deps_googletest_src_docs_reference_mocking_1DefaultValue" kindref="member">here</ref>) or <computeroutput>ON_CALL()</computeroutput>.</para>
<para>Please note that once you expressed interest in a particular mock method (via <computeroutput>EXPECT_CALL()</computeroutput>), all invocations to it must match some expectation. If this function is called but the arguments don&apos;t match any <computeroutput>EXPECT_CALL()</computeroutput> statement, it will be an error.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md144">
<title>Disallowing Unexpected Calls</title>
<para>If a mock method shouldn&apos;t be called at all, explicitly say so:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(0);</highlight></codeline>
</programlisting></para>
<para>If some calls to the method are allowed, but the rest are not, just list all the expected calls:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::AnyNumber;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Gt(10)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());</highlight></codeline>
</programlisting></para>
<para>A call to <computeroutput>foo.Bar()</computeroutput> that doesn&apos;t match any of the <computeroutput>EXPECT_CALL()</computeroutput> statements will be an error.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1uninteresting-vs-unexpected">
<title>Understanding Uninteresting vs Unexpected Calls</title>
<para><emphasis>Uninteresting</emphasis> calls and <emphasis>unexpected</emphasis> calls are different concepts in gMock. <emphasis>Very</emphasis> different.</para>
<para>A call <computeroutput>x.Y(...)</computeroutput> is <bold>uninteresting</bold> if there&apos;s <emphasis>not even a single</emphasis> <computeroutput>EXPECT_CALL(x, Y(...))</computeroutput> set. In other words, the test isn&apos;t interested in the <computeroutput>x.Y()</computeroutput> method at all, as evident in that the test doesn&apos;t care to say anything about it.</para>
<para>A call <computeroutput>x.Y(...)</computeroutput> is <bold>unexpected</bold> if there are <emphasis>some</emphasis> <computeroutput>EXPECT_CALL(x,
Y(...))</computeroutput>s set, but none of them matches the call. Put another way, the test is interested in the <computeroutput>x.Y()</computeroutput> method (therefore it explicitly sets some <computeroutput>EXPECT_CALL</computeroutput> to verify how it&apos;s called); however, the verification fails as the test doesn&apos;t expect this particular call to happen.</para>
<para><bold>An unexpected call is always an error,</bold> as the code under test doesn&apos;t behave the way the test expects it to behave.</para>
<para><bold>By default, an uninteresting call is not an error,</bold> as it violates no constraint specified by the test. (gMock&apos;s philosophy is that saying nothing means there is no constraint.) However, it leads to a warning, as it <emphasis>might</emphasis> indicate a problem (e.g. the test author might have forgotten to specify a constraint).</para>
<para>In gMock, <computeroutput>NiceMock</computeroutput> and <computeroutput>StrictMock</computeroutput> can be used to make a mock class &quot;nice&quot; or &quot;strict&quot;. How does this affect uninteresting calls and unexpected calls?</para>
<para>A <bold>nice mock</bold> suppresses uninteresting call <emphasis>warnings</emphasis>. It is less chatty than the default mock, but otherwise is the same. If a test fails with a default mock, it will also fail using a nice mock instead. And vice versa. Don&apos;t expect making a mock nice to change the test&apos;s result.</para>
<para>A <bold>strict mock</bold> turns uninteresting call warnings into errors. So making a mock strict may change the test&apos;s result.</para>
<para>Let&apos;s look at an example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockDomainRegistry&gt;<sp/>mock_registry;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(</highlight><highlight class="stringliteral">&quot;google.com&quot;</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(</highlight><highlight class="stringliteral">&quot;Larry<sp/>Page&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>mock_registry<sp/>in<sp/>code<sp/>under<sp/>test.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>&amp;mock_registry<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The sole <computeroutput>EXPECT_CALL</computeroutput> here says that all calls to <computeroutput>GetDomainOwner()</computeroutput> must have <computeroutput>&quot;google.com&quot;</computeroutput> as the argument. If <computeroutput>GetDomainOwner(&quot;yahoo.com&quot;)</computeroutput> is called, it will be an unexpected call, and thus an error. <emphasis>Having a nice mock doesn&apos;t change the severity of an unexpected call.</emphasis></para>
<para>So how do we tell gMock that <computeroutput>GetDomainOwner()</computeroutput> can be called with some other arguments as well? The standard technique is to add a &quot;catch all&quot; <computeroutput>EXPECT_CALL</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());<sp/><sp/></highlight><highlight class="comment">//<sp/>catches<sp/>all<sp/>other<sp/>calls<sp/>to<sp/>this<sp/>method.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(</highlight><highlight class="stringliteral">&quot;google.com&quot;</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(</highlight><highlight class="stringliteral">&quot;Larry<sp/>Page&quot;</highlight><highlight class="normal">));</highlight></codeline>
</programlisting></para>
<para>Remember that <computeroutput>_</computeroutput> is the wildcard matcher that matches anything. With this, if <computeroutput>GetDomainOwner(&quot;google.com&quot;)</computeroutput> is called, it will do what the second <computeroutput>EXPECT_CALL</computeroutput> says; if it is called with a different argument, it will do what the first <computeroutput>EXPECT_CALL</computeroutput> says.</para>
<para>Note that the order of the two <computeroutput>EXPECT_CALL</computeroutput>s is important, as a newer <computeroutput>EXPECT_CALL</computeroutput> takes precedence over an older one.</para>
<para>For more on uninteresting calls, nice mocks, and strict mocks, read <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1NiceStrictNaggy" kindref="member">"The Nice, the Strict, and the Naggy"</ref>.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1ParameterlessExpectations">
<title>Ignoring Uninteresting Arguments</title>
<para>If your test doesn&apos;t care about the parameters (it only cares about the number or order of calls), you can often simply omit the parameter list:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Expect<sp/>foo.Bar(<sp/>...<sp/>)<sp/>twice<sp/>with<sp/>any<sp/>arguments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>Bar).Times(2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Delegate<sp/>to<sp/>the<sp/>given<sp/>method<sp/>whenever<sp/>the<sp/>factory<sp/>is<sp/>invoked.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ON_CALL(foo_factory,<sp/>MakeFoo)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillByDefault(&amp;BuildFooForTest);</highlight></codeline>
</programlisting></para>
<para>This functionality is only available when a method is not overloaded; to prevent unexpected behavior it is a compilation error to try to set an expectation on a method where the specific overload is ambiguous. You can work around this by supplying a <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1SimplerInterfaces" kindref="member">simpler mock interface</ref> than the mocked class provides.</para>
<para>This pattern is also useful when the arguments are interesting, but match logic is substantially complex. You can leave the argument list unspecified and use SaveArg actions to <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1SaveArgVerify" kindref="member">save the values for later verification</ref>. If you do that, you can easily differentiate calling the method the wrong number of times from calling it with the wrong arguments.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_for_dummies_1OrderedCalls">
<title>Expecting Ordered Calls</title>
<para>Although an <computeroutput>EXPECT_CALL()</computeroutput> statement defined later takes precedence when gMock tries to match a function call with an expectation, by default calls don&apos;t have to happen in the order <computeroutput>EXPECT_CALL()</computeroutput> statements are written. For example, if the arguments match the matchers in the second <computeroutput>EXPECT_CALL()</computeroutput>, but not those in the first and third, then the second expectation will be used.</para>
<para>If you would rather have all calls occur in the order of the expectations, put the <computeroutput>EXPECT_CALL()</computeroutput> statements in a block where you define a variable of type <computeroutput>InSequence</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InSequence;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(bar,<sp/>DoThat(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.Times(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
</programlisting></para>
<para>In this example, we expect a call to <computeroutput>foo.DoThis(5)</computeroutput>, followed by two calls to <computeroutput>bar.DoThat()</computeroutput> where the argument can be anything, which are in turn followed by a call to <computeroutput>foo.DoThis(6)</computeroutput>. If a call occurred out-of-order, gMock will report an error.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1PartialOrder">
<title>Expecting Partially Ordered Calls</title>
<para>Sometimes requiring everything to occur in a predetermined order can lead to brittle tests. For example, we may care about <computeroutput>A</computeroutput> occurring before both <computeroutput>B</computeroutput> and <computeroutput>C</computeroutput>, but aren&apos;t interested in the relative order of <computeroutput>B</computeroutput> and <computeroutput>C</computeroutput>. In this case, the test should reflect our real intent, instead of being overly constraining.</para>
<para>gMock allows you to impose an arbitrary DAG (directed acyclic graph) on the calls. One way to express the DAG is to use the <ulink url="reference/mocking.md#EXPECT_CALL.After"><computeroutput>After</computeroutput> clause</ulink> of <computeroutput>EXPECT_CALL</computeroutput>.</para>
<para>Another way is via the <computeroutput>InSequence()</computeroutput> clause (not the same as the <computeroutput>InSequence</computeroutput> class), which we borrowed from jMock 2. It&apos;s less flexible than <computeroutput>After()</computeroutput>, but more convenient when you have long chains of sequential calls, as it doesn&apos;t require you to come up with different names for the expectations in the chains. Here&apos;s how it works:</para>
<para>If we view <computeroutput>EXPECT_CALL()</computeroutput> statements as nodes in a graph, and add an edge from node A to node B wherever A must occur before B, we can get a DAG. We use the term &quot;sequence&quot; to mean a directed path in this DAG. Now, if we decompose the DAG into sequences, we just need to know which sequences each <computeroutput>EXPECT_CALL()</computeroutput> belongs to in order to be able to reconstruct the original DAG.</para>
<para>So, to specify the partial order on the expectations we need to do two things: first to define some <computeroutput>Sequence</computeroutput> objects, and then for each <computeroutput>EXPECT_CALL()</computeroutput> say which <computeroutput>Sequence</computeroutput> objects it is part of.</para>
<para>Expectations in the same sequence must occur in the order they are written. For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Sequence;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sequence<sp/>s1,<sp/>s2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>A())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(bar,<sp/>B())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(bar,<sp/>C())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>D())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
</programlisting></para>
<para>specifies the following DAG (where <computeroutput>s1</computeroutput> is <computeroutput>A -&gt; B</computeroutput>, and <computeroutput>s2</computeroutput> is <computeroutput>A -&gt; C -&gt; D</computeroutput>):</para>
<para><programlisting filename=".text"><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>+---&gt;<sp/>B</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">A<sp/>---|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>+---&gt;<sp/>C<sp/>---&gt;<sp/>D</highlight></codeline>
</programlisting></para>
<para>This means that A must occur before B and C, and C must occur before D. There&apos;s no restriction about the order other than these.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md145">
<title>Controlling When an Expectation Retires</title>
<para>When a mock method is called, gMock only considers expectations that are still active. An expectation is active when created, and becomes inactive (aka <emphasis>retires</emphasis>) when a call that has to occur later has occurred. For example, in</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Sequence;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sequence<sp/>s1,<sp/>s2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/></highlight><highlight class="stringliteral">&quot;File<sp/>too<sp/>large.&quot;</highlight><highlight class="normal">))<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>#1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/></highlight><highlight class="stringliteral">&quot;Data<sp/>set<sp/>is<sp/>empty.&quot;</highlight><highlight class="normal">))<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>#2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/></highlight><highlight class="stringliteral">&quot;User<sp/>not<sp/>found.&quot;</highlight><highlight class="normal">))<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>#3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
</programlisting></para>
<para>as soon as either #2 or #3 is matched, #1 will retire. If a warning <computeroutput>&quot;File too
large.&quot;</computeroutput> is logged after this, it will be an error.</para>
<para>Note that an expectation doesn&apos;t retire automatically when it&apos;s saturated. For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>_));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>#1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/></highlight><highlight class="stringliteral">&quot;File<sp/>too<sp/>large.&quot;</highlight><highlight class="normal">));<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>#2</highlight></codeline>
</programlisting></para>
<para>says that there will be exactly one warning with the message <computeroutput>&quot;File too
large.&quot;</computeroutput>. If the second warning contains this message too, #2 will match again and result in an upper-bound-violated error.</para>
<para>If this is not what you want, you can ask an expectation to retire as soon as it becomes saturated:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>_));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>#1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/></highlight><highlight class="stringliteral">&quot;File<sp/>too<sp/>large.&quot;</highlight><highlight class="normal">))<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>#2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.RetiresOnSaturation();</highlight></codeline>
</programlisting></para>
<para>Here #2 can be used only once, so if you have two warnings with the message <computeroutput>&quot;File too large.&quot;</computeroutput>, the first will match #2 and the second will match #1 - there will be no error.</para>
</sect2>
</sect1>
<sect1 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md146">
<title>Using Actions</title>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md147">
<title>Returning References from Mock Methods</title>
<para>If a mock function&apos;s return type is a reference, you need to use <computeroutput>ReturnRef()</computeroutput> instead of <computeroutput>Return()</computeroutput> to return a result:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::ReturnRef;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>bar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetBar())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md148">
<title>Returning Live Values from Mock Methods</title>
<para>The <computeroutput>Return(x)</computeroutput> action saves a copy of <computeroutput>x</computeroutput> when the action is created, and always returns the same value whenever it&apos;s executed. Sometimes you may want to instead return the <emphasis>live</emphasis> value of <computeroutput>x</computeroutput> (i.e. its value at the time when the action is <emphasis>executed</emphasis>.). Use either <computeroutput>ReturnRef()</computeroutput> or <computeroutput>ReturnPointee()</computeroutput> for this purpose.</para>
<para>If the mock function&apos;s return type is a reference, you can do it using <computeroutput>ReturnRef(x)</computeroutput>, as shown in the previous recipe (&quot;Returning References from Mock
Methods&quot;). However, gMock doesn&apos;t let you use <computeroutput>ReturnRef()</computeroutput> in a mock function whose return type is not a reference, as doing that usually indicates a user error. So, what shall you do?</para>
<para>Though you may be tempted, DO NOT use <computeroutput>std::ref()</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>GetValue,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetValue())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(std::ref(x)));<sp/><sp/></highlight><highlight class="comment">//<sp/>Wrong!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>x<sp/>=<sp/>42;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(foo.GetValue(),<sp/>42);</highlight></codeline>
</programlisting></para>
<para>Unfortunately, it doesn&apos;t work here. The above code will fail with error:</para>
<para><programlisting filename=".text"><codeline><highlight class="normal">Value<sp/>of:<sp/>foo.GetValue()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>0</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>42</highlight></codeline>
</programlisting></para>
<para>The reason is that <computeroutput>Return(*value*)</computeroutput> converts <computeroutput>value</computeroutput> to the actual return type of the mock function at the time when the action is <emphasis>created</emphasis>, not when it is <emphasis>executed</emphasis>. (This behavior was chosen for the action to be safe when <computeroutput>value</computeroutput> is a proxy object that references some temporary objects.) As a result, <computeroutput>std::ref(x)</computeroutput> is converted to an <computeroutput>int</computeroutput> value (instead of a <computeroutput>const int&amp;</computeroutput>) when the expectation is set, and <computeroutput>Return(std::ref(x))</computeroutput> will always return 0.</para>
<para><computeroutput>ReturnPointee(pointer)</computeroutput> was provided to solve this problem specifically. It returns the value pointed to by <computeroutput>pointer</computeroutput> at the time the action is <emphasis>executed</emphasis>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::ReturnPointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetValue())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(ReturnPointee(&amp;x));<sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>the<sp/>&amp;<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>x<sp/>=<sp/>42;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(foo.GetValue(),<sp/>42);<sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>will<sp/>succeed<sp/>now.</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md149">
<title>Combining Actions</title>
<para>Want to do more than one thing when a function is called? That&apos;s fine. <computeroutput>DoAll()</computeroutput> allows you to do a sequence of actions every time. Only the return value of the last action in the sequence will be used.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>Bar,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(action_1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>action_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>action_n));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1SaveArgVerify">
<title>Verifying Complex Arguments</title>
<para>If you want to verify that a method is called with a particular argument but the match criteria is complex, it can be difficult to distinguish between cardinality failures (calling the method the wrong number of times) and argument match failures. Similarly, if you are matching multiple parameters, it may not be easy to distinguishing which argument failed to match. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Not<sp/>ideal:<sp/>this<sp/>could<sp/>fail<sp/>because<sp/>of<sp/>a<sp/>problem<sp/>with<sp/>arg1<sp/>or<sp/>arg2,<sp/>or<sp/>maybe</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>just<sp/>the<sp/>method<sp/>wasn&apos;t<sp/>called.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>SendValues(_,<sp/>ElementsAre(1,<sp/>4,<sp/>4,<sp/>7),<sp/>EqualsProto(<sp/>...<sp/>)));</highlight></codeline>
</programlisting></para>
<para>You can instead save the arguments and test them individually:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>SendValues)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(DoAll(SaveArg&lt;1&gt;(&amp;actual_array),<sp/>SaveArg&lt;2&gt;(&amp;actual_proto)));</highlight></codeline>
<codeline><highlight class="normal">...<sp/>run<sp/>the<sp/>test</highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(actual_array,<sp/>ElementsAre(1,<sp/>4,<sp/>4,<sp/>7));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(actual_proto,<sp/>EqualsProto(<sp/>...<sp/>));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1MockingSideEffects">
<title>Mocking Side Effects</title>
<para>Sometimes a method exhibits its effect not via returning a value but via side effects. For example, it may change some global state or modify an output argument. To mock side effects, in general you can define your own action by implementing <computeroutput><ref refid="classtesting_1_1ActionInterface" kindref="compound">testing::ActionInterface</ref></computeroutput>.</para>
<para>If all you need to do is to change an output argument, the built-in <computeroutput>SetArgPointee()</computeroutput> action is convenient:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArgPointee;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockMutator<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Mutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Mutate,<sp/>(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>mutate,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>value),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>Mutate(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArgPointee&lt;1&gt;(5));</highlight></codeline>
</programlisting></para>
<para>In this example, when <computeroutput>mutator.Mutate()</computeroutput> is called, we will assign 5 to the <computeroutput>int</computeroutput> variable pointed to by argument #1 (0-based).</para>
<para><computeroutput>SetArgPointee()</computeroutput> conveniently makes an internal copy of the value you pass to it, removing the need to keep the value in scope and alive. The implication however is that the value must have a copy constructor and assignment operator.</para>
<para>If the mock method also needs to return a value as well, you can chain <computeroutput>SetArgPointee()</computeroutput> with <computeroutput>Return()</computeroutput> using <computeroutput>DoAll()</computeroutput>, remembering to put the <computeroutput>Return()</computeroutput> statement last:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArgPointee;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockMutator<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Mutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>MutateInt,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>value),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>MutateInt(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(SetArgPointee&lt;0&gt;(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(</highlight><highlight class="keyword">true</highlight><highlight class="normal">)));</highlight></codeline>
</programlisting></para>
<para>Note, however, that if you use the <computeroutput>ReturnOKWith()</computeroutput> method, it will override the values provided by <computeroutput>SetArgPointee()</computeroutput> in the response parameters of your function call.</para>
<para>If the output argument is an array, use the <computeroutput>SetArrayArgument&lt;N&gt;(first, last)</computeroutput> action instead. It copies the elements in source range <computeroutput>[first, last)</computeroutput> to the array pointed to by the <computeroutput>N</computeroutput>-th (0-based) argument:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArrayArgument;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockArrayMutator<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>ArrayMutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Mutate,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>values,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_values),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockArrayMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>values[5]<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>Mutate(NotNull(),<sp/>5))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArrayArgument&lt;0&gt;(values,<sp/>values<sp/>+<sp/>5));</highlight></codeline>
</programlisting></para>
<para>This also works when the argument is an output iterator:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArrayArgument;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockRolodex<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Rolodex<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>GetNames,<sp/>(std::back_insert_iterator&lt;vector&lt;string&gt;&gt;),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockRolodex<sp/>rolodex;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vector&lt;string&gt;<sp/>names<sp/>=<sp/>{</highlight><highlight class="stringliteral">&quot;George&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;John&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Thomas&quot;</highlight><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(rolodex,<sp/>GetNames(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArrayArgument&lt;0&gt;(names.begin(),<sp/>names.end()));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md150">
<title>Changing a Mock Object&apos;s Behavior Based on the State</title>
<para>If you expect a call to change the behavior of a mock object, you can use <computeroutput>::testing::InSequence</computeroutput> to specify different behaviors before and after the call:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::InSequence;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>InSequence<sp/>seq;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>IsDirty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(</highlight><highlight class="keyword">true</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>Flush());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>IsDirty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(</highlight><highlight class="keyword">false</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_mock.FlushIfDirty();</highlight></codeline>
</programlisting></para>
<para>This makes <computeroutput>my_mock.IsDirty()</computeroutput> return <computeroutput>true</computeroutput> before <computeroutput>my_mock.Flush()</computeroutput> is called and return <computeroutput>false</computeroutput> afterwards.</para>
<para>If the behavior change is more complex, you can store the effects in a variable and make a mock method get its return value from that variable:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SaveArg;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ACTION_P(ReturnPointee,<sp/>p)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*p;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>previous_value<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(my_mock,<sp/>GetPrevValue)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(ReturnPointee(&amp;previous_value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(my_mock,<sp/>UpdateValue)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(SaveArg&lt;0&gt;(&amp;previous_value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_mock.DoSomethingToUpdateValue();</highlight></codeline>
</programlisting></para>
<para>Here <computeroutput>my_mock.GetPrevValue()</computeroutput> will always return the argument of the last <computeroutput>UpdateValue()</computeroutput> call.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_reference_mocking_1DefaultValue">
<title>Setting the Default Value for a Return Type</title>
<para>If a mock method&apos;s return type is a built-in C++ type or pointer, by default it will return 0 when invoked. Also, in C++ 11 and above, a mock method whose return type has a default constructor will return a default-constructed value by default. You only need to specify an action if this default value doesn&apos;t work for you.</para>
<para>Sometimes, you may want to change this default value, or you may want to specify a default value for types gMock doesn&apos;t know about. You can do this using the <computeroutput><ref refid="classtesting_1_1DefaultValue" kindref="compound">testing::DefaultValue</ref></computeroutput> class template:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::DefaultValue;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Bar,<sp/>CalculateBar,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>default_bar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Sets<sp/>the<sp/>default<sp/>return<sp/>value<sp/>for<sp/>type<sp/>Bar.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DefaultValue&lt;Bar&gt;::Set(default_bar);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>don&apos;t<sp/>need<sp/>to<sp/>specify<sp/>an<sp/>action<sp/>here,<sp/>as<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>return<sp/>value<sp/>works<sp/>for<sp/>us.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>CalculateBar());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.CalculateBar();<sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>should<sp/>return<sp/>default_bar.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Unsets<sp/>the<sp/>default<sp/>return<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DefaultValue&lt;Bar&gt;::Clear();</highlight></codeline>
</programlisting></para>
<para>Please note that changing the default value for a type can make your tests hard to understand. We recommend you to use this feature judiciously. For example, you may want to make sure the <computeroutput>Set()</computeroutput> and <computeroutput>Clear()</computeroutput> calls are right next to the code that uses your mock.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md151">
<title>Setting the Default Actions for a Mock Method</title>
<para>You&apos;ve learned how to change the default value of a given type. However, this may be too coarse for your purpose: perhaps you have two mock methods with the same return type and you want them to have different behaviors. The <computeroutput>ON_CALL()</computeroutput> macro allows you to customize your mock&apos;s behavior at the method level:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AnyNumber;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(0))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(Gt(0)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Sign(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(5);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>should<sp/>return<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(-9);<sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>should<sp/>return<sp/>-1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(0);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>should<sp/>return<sp/>0.</highlight></codeline>
</programlisting></para>
<para>As you may have guessed, when there are more than one <computeroutput>ON_CALL()</computeroutput> statements, the newer ones in the order take precedence over the older ones. In other words, the <bold>last</bold> one that matches the function arguments will be used. This matching order allows you to set up the common behavior in a mock object&apos;s constructor or the test fixture&apos;s set-up phase and specialize the mock&apos;s behavior later.</para>
<para>Note that both <computeroutput>ON_CALL</computeroutput> and <computeroutput>EXPECT_CALL</computeroutput> have the same &quot;later statements take
precedence&quot; rule, but they don&apos;t interact. That is, <computeroutput>EXPECT_CALL</computeroutput>s have their own precedence order distinct from the <computeroutput>ON_CALL</computeroutput> precedence order.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1FunctionsAsActions">
<title>Using Functions/Methods/Functors/Lambdas as Actions</title>
<para>If the built-in actions don&apos;t suit you, you can use an existing callable (function, <computeroutput>std::function</computeroutput>, method, functor, lambda) as an action.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;<sp/>using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>Sum,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>ComplexJob,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>CalculateSum(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>x<sp/>+<sp/>y;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Sum3(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>z)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>x<sp/>+<sp/>y<sp/>+<sp/>z;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Helper<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ComplexJob(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Helper<sp/>helper;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Sum(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(&amp;CalculateSum)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Invoke(NewPermanentCallback(Sum3,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>ComplexJob(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(&amp;helper,<sp/>&amp;Helper::ComplexJob))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce([]<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;<sp/>})</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly([](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>x<sp/>&gt;<sp/>0;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sum(5,<sp/>6);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Invokes<sp/>CalculateSum(5,<sp/>6).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sum(2,<sp/>3);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Invokes<sp/>Sum3(1,<sp/>2,<sp/>3).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(10);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Invokes<sp/>helper.ComplexJob(10).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(-1);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Invokes<sp/>the<sp/>inline<sp/>lambda.</highlight></codeline>
</programlisting></para>
<para>The only requirement is that the type of the function, etc must be <emphasis>compatible</emphasis> with the signature of the mock function, meaning that the latter&apos;s arguments (if it takes any) can be implicitly converted to the corresponding arguments of the former, and the former&apos;s return type can be implicitly converted to that of the latter. So, you can invoke something whose type is <emphasis>not</emphasis> exactly the same as the mock function, as long as it&apos;s safe to do so - nice, huh?</para>
<para>Note that:</para>
<para><itemizedlist>
<listitem><para>The action takes ownership of the callback and will delete it when the action itself is destructed.</para>
</listitem><listitem><para>If the type of a callback is derived from a base callback type <computeroutput>C</computeroutput>, you need to implicitly cast it to <computeroutput>C</computeroutput> to resolve the overloading, e.g.</para>
<para>```cpp using testing::Invoke; ... ResultCallback&lt;bool&gt;* is_ok = ...; ... Invoke(is_ok) ...; // This works.</para>
<para>BlockingClosure* done = new BlockingClosure; ... Invoke(implicit_cast&lt;Closure*&gt;(done)) ...; // The cast is necessary. ```</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md152">
<title>Using Functions with Extra Info as Actions</title>
<para>The function or functor you call using <computeroutput>Invoke()</computeroutput> must have the same number of arguments as the mock function you use it for. Sometimes you may have a function that takes more arguments, and you are willing to pass in the extra arguments yourself to fill the gap. You can do this in gMock using callbacks with pre-bound arguments. Here&apos;s an example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">,<sp/>DoThis,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>SignOfSum(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>sum<sp/>=<sp/>x<sp/>+<sp/>y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(sum<sp/>&gt;<sp/>0)<sp/>?<sp/></highlight><highlight class="charliteral">&apos;+&apos;</highlight><highlight class="normal"><sp/>:<sp/>(sum<sp/>&lt;<sp/>0)<sp/>?<sp/></highlight><highlight class="charliteral">&apos;-&apos;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="charliteral">&apos;0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST_F(FooTest,<sp/>Test)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(2))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(NewPermanentCallback(SignOfSum,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(foo.DoThis(2),<sp/></highlight><highlight class="charliteral">&apos;+&apos;</highlight><highlight class="normal">);<sp/><sp/></highlight><highlight class="comment">//<sp/>Invokes<sp/>SignOfSum(5,<sp/>2).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md153">
<title>Invoking a Function/Method/Functor/Lambda/Callback Without Arguments</title>
<para><computeroutput>Invoke()</computeroutput> passes the mock function&apos;s arguments to the function, etc being invoked such that the callee has the full context of the call to work with. If the invoked function is not interested in some or all of the arguments, it can simply ignore them.</para>
<para>Yet, a common pattern is that a test author wants to invoke a function without the arguments of the mock function. She could do that using a wrapper function that throws away the arguments before invoking an underlining nullary function. Needless to say, this can be tedious and obscures the intent of the test.</para>
<para>There are two solutions to this problem. First, you can pass any callable of zero args as an action. Alternatively, use <computeroutput>InvokeWithoutArgs()</computeroutput>, which is like <computeroutput>Invoke()</computeroutput> except that it doesn&apos;t pass the mock function&apos;s arguments to the callee. Here&apos;s an example of each:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeWithoutArgs;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>ComplexJob,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Job1()<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Job2(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>ComplexJob(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce([]<sp/>{<sp/>Job1();<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeWithoutArgs(NewPermanentCallback(Job2,<sp/>5,<sp/></highlight><highlight class="charliteral">&apos;a&apos;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(10);<sp/><sp/></highlight><highlight class="comment">//<sp/>Invokes<sp/>Job1().</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(20);<sp/><sp/></highlight><highlight class="comment">//<sp/>Invokes<sp/>Job2(5,<sp/>&apos;a&apos;).</highlight></codeline>
</programlisting></para>
<para>Note that:</para>
<para><itemizedlist>
<listitem><para>The action takes ownership of the callback and will delete it when the action itself is destructed.</para>
</listitem><listitem><para>If the type of a callback is derived from a base callback type <computeroutput>C</computeroutput>, you need to implicitly cast it to <computeroutput>C</computeroutput> to resolve the overloading, e.g.</para>
<para>```cpp using testing::InvokeWithoutArgs; ... ResultCallback&lt;bool&gt;* is_ok = ...; ... InvokeWithoutArgs(is_ok) ...; // This works.</para>
<para>BlockingClosure* done = ...; ... InvokeWithoutArgs(implicit_cast&lt;Closure*&gt;(done)) ...; // The cast is necessary. ```</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md154">
<title>Invoking an Argument of the Mock Function</title>
<para>Sometimes a mock function will receive a function pointer, a functor (in other words, a &quot;callable&quot;) as an argument, e.g.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>DoThis,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/>(ResultCallback1&lt;bool,<sp/>int&gt;*<sp/>callback)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>and you may want to invoke this callable argument:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Will<sp/>execute<sp/>callback-&gt;Run(5),<sp/>where<sp/>callback<sp/>is<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>second<sp/>argument<sp/>DoThis()<sp/>receives.</highlight></codeline>
</programlisting></para>
<para>{: .callout .note} NOTE: The section below is legacy documentation from before C++ had lambdas:</para>
<para>Arghh, you need to refer to a mock function argument but C++ has no lambda (yet), so you have to define your own action. :-( Or do you really?</para>
<para>Well, gMock has an action to solve <emphasis>exactly</emphasis> this problem:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">InvokeArgument&lt;N&gt;(arg_1,<sp/>arg_2,<sp/>...,<sp/>arg_m)</highlight></codeline>
</programlisting></para>
<para>will invoke the <computeroutput>N</computeroutput>-th (0-based) argument the mock function receives, with <computeroutput>arg_1</computeroutput>, <computeroutput>arg_2</computeroutput>, ..., and <computeroutput>arg_m</computeroutput>. No matter if the argument is a function pointer, a functor, or a callback. gMock handles them all.</para>
<para>With that, you could write:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;1&gt;(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Will<sp/>execute<sp/>callback-&gt;Run(5),<sp/>where<sp/>callback<sp/>is<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>second<sp/>argument<sp/>DoThis()<sp/>receives.</highlight></codeline>
</programlisting></para>
<para>What if the callable takes an argument by reference? No problem - just wrap it inside <computeroutput>std::ref()</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>Bar,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((ResultCallback2&lt;bool,<sp/>int,<sp/>const<sp/>Helper&amp;&gt;*<sp/>callback)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal">Helper<sp/>helper;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;0&gt;(5,<sp/>std::ref(helper)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::ref(helper)<sp/>guarantees<sp/>that<sp/>a<sp/>reference<sp/>to<sp/>helper,<sp/>not<sp/>a<sp/>copy<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>it,<sp/>will<sp/>be<sp/>passed<sp/>to<sp/>the<sp/>callback.</highlight></codeline>
</programlisting></para>
<para>What if the callable takes an argument by reference and we do <bold>not</bold> wrap the argument in <computeroutput>std::ref()</computeroutput>? Then <computeroutput>InvokeArgument()</computeroutput> will <emphasis>make a copy</emphasis> of the argument, and pass a <emphasis>reference to the copy</emphasis>, instead of a reference to the original value, to the callable. This is especially handy when the argument is a temporary value:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>DoThat,<sp/>(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>(*f)(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&amp;<sp/>x,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>s)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>DoThat(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;0&gt;(5.0,<sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">(</highlight><highlight class="stringliteral">&quot;Hi&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Will<sp/>execute<sp/>(*f)(5.0,<sp/>string(&quot;Hi&quot;)),<sp/>where<sp/>f<sp/>is<sp/>the<sp/>function<sp/>pointer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>DoThat()<sp/>receives.<sp/><sp/>Note<sp/>that<sp/>the<sp/>values<sp/>5.0<sp/>and<sp/>string(&quot;Hi&quot;)<sp/>are</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>temporary<sp/>and<sp/>dead<sp/>once<sp/>the<sp/>EXPECT_CALL()<sp/>statement<sp/>finishes.<sp/><sp/>Yet</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>it&apos;s<sp/>fine<sp/>to<sp/>perform<sp/>this<sp/>action<sp/>later,<sp/>since<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>are<sp/>kept<sp/>inside<sp/>the<sp/>InvokeArgument<sp/>action.</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md155">
<title>Ignoring an Action&apos;s Result</title>
<para>Sometimes you have an action that returns <emphasis>something</emphasis>, but you need an action that returns <computeroutput>void</computeroutput> (perhaps you want to use it in a mock function that returns <computeroutput>void</computeroutput>, or perhaps it needs to be used in <computeroutput>DoAll()</computeroutput> and it&apos;s not the last in the list). <computeroutput>IgnoreResult()</computeroutput> lets you do that. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::IgnoreResult;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Process(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>MyData&amp;<sp/>data);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>DoSomething();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Abc,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>MyData&amp;<sp/>data),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>Xyz,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Abc(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>.WillOnce(Invoke(Process));</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>above<sp/>line<sp/>won&apos;t<sp/>compile<sp/>as<sp/>Process()<sp/>returns<sp/>int<sp/>but<sp/>Abc()<sp/>needs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>to<sp/>return<sp/>void.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(IgnoreResult(Process));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Xyz())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(IgnoreResult(DoSomething),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ignores<sp/>the<sp/>string<sp/>DoSomething()<sp/>returns.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(</highlight><highlight class="keyword">true</highlight><highlight class="normal">)));</highlight></codeline>
</programlisting></para>
<para>Note that you <bold>cannot</bold> use <computeroutput>IgnoreResult()</computeroutput> on an action that already returns <computeroutput>void</computeroutput>. Doing so will lead to ugly compiler errors.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1SelectingArgs">
<title>Selecting an Action&apos;s Arguments</title>
<para>Say you have a mock function <computeroutput>Foo()</computeroutput> that takes seven arguments, and you have a custom action that you want to invoke when <computeroutput>Foo()</computeroutput> is called. Trouble is, the custom action only wants three arguments:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>Foo,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>visible,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>name,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>map&lt;pair&lt;int,<sp/>int&gt;&gt;),<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&amp;<sp/>weight,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>min_weight,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>max_wight));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>IsVisibleInQuadrant1(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>visible,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>visible<sp/>&amp;&amp;<sp/>x<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>y<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(IsVisibleInQuadrant1));<sp/><sp/></highlight><highlight class="comment">//<sp/>Uh,<sp/>won&apos;t<sp/>compile.<sp/>:-(</highlight></codeline>
</programlisting></para>
<para>To please the compiler God, you need to define an &quot;adaptor&quot; that has the same signature as <computeroutput>Foo()</computeroutput> and calls the custom action with the right arguments:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>MyIsVisibleInQuadrant1(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>visible,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>name,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>map&lt;pair&lt;int,<sp/>int&gt;,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&gt;&amp;<sp/>weight,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>min_weight,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>max_wight)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>IsVisibleInQuadrant1(visible,<sp/>x,<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(MyIsVisibleInQuadrant1));<sp/><sp/></highlight><highlight class="comment">//<sp/>Now<sp/>it<sp/>works.</highlight></codeline>
</programlisting></para>
<para>But isn&apos;t this awkward?</para>
<para>gMock provides a generic <emphasis>action adaptor</emphasis>, so you can spend your time minding more important business than writing your own adaptors. Here&apos;s the syntax:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">WithArgs&lt;N1,<sp/>N2,<sp/>...,<sp/>Nk&gt;(action)</highlight></codeline>
</programlisting></para>
<para>creates an action that passes the arguments of the mock function at the given indices (0-based) to the inner <computeroutput>action</computeroutput> and performs it. Using <computeroutput>WithArgs</computeroutput>, our original example can be written as:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::WithArgs;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(WithArgs&lt;0,<sp/>2,<sp/>3&gt;(Invoke(IsVisibleInQuadrant1)));<sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>need<sp/>to<sp/>define<sp/>your<sp/>own<sp/>adaptor.</highlight></codeline>
</programlisting></para>
<para>For better readability, gMock also gives you:</para>
<para><itemizedlist>
<listitem><para><computeroutput>WithoutArgs(action)</computeroutput> when the inner <computeroutput>action</computeroutput> takes <emphasis>no</emphasis> argument, and</para>
</listitem><listitem><para><computeroutput>WithArg&lt;N&gt;(action)</computeroutput> (no <computeroutput>s</computeroutput> after <computeroutput>Arg</computeroutput>) when the inner <computeroutput>action</computeroutput> takes <emphasis>one</emphasis> argument.</para>
</listitem></itemizedlist>
</para>
<para>As you may have realized, <computeroutput>InvokeWithoutArgs(...)</computeroutput> is just syntactic sugar for <computeroutput>WithoutArgs(Invoke(...))</computeroutput>.</para>
<para>Here are more tips:</para>
<para><itemizedlist>
<listitem><para>The inner action used in <computeroutput>WithArgs</computeroutput> and friends does not have to be <computeroutput>Invoke()</computeroutput> <ndash/> it can be anything.</para>
</listitem><listitem><para>You can repeat an argument in the argument list if necessary, e.g. <computeroutput>WithArgs&lt;2, 3, 3, 5&gt;(...)</computeroutput>.</para>
</listitem><listitem><para>You can change the order of the arguments, e.g. <computeroutput>WithArgs&lt;3, 2, 1&gt;(...)</computeroutput>.</para>
</listitem><listitem><para>The types of the selected arguments do <emphasis>not</emphasis> have to match the signature of the inner action exactly. It works as long as they can be implicitly converted to the corresponding arguments of the inner action. For example, if the 4-th argument of the mock function is an <computeroutput>int</computeroutput> and <computeroutput>my_action</computeroutput> takes a <computeroutput>double</computeroutput>, <computeroutput>WithArg&lt;4&gt;(my_action)</computeroutput> will work.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md156">
<title>Ignoring Arguments in Action Functions</title>
<para>The <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1SelectingArgs" kindref="member">selecting-an-action&apos;s-arguments</ref> recipe showed us one way to make a mock function and an action with incompatible argument lists fit together. The downside is that wrapping the action in <computeroutput>WithArgs&lt;...&gt;()</computeroutput> can get tedious for people writing the tests.</para>
<para>If you are defining a function (or method, functor, lambda, callback) to be used with <computeroutput>Invoke*()</computeroutput>, and you are not interested in some of its arguments, an alternative to <computeroutput>WithArgs</computeroutput> is to declare the uninteresting arguments as <computeroutput>Unused</computeroutput>. This makes the definition less cluttered and less fragile in case the types of the uninteresting arguments change. It could also increase the chance the action function can be reused. For example, given</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">,<sp/>Foo,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>label,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">,<sp/>Bar,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
</programlisting></para>
<para>instead of</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>DistanceToOriginWithLabel(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>label,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>DistanceToOriginWithIndex(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(</highlight><highlight class="stringliteral">&quot;abc&quot;</highlight><highlight class="normal">,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOriginWithLabel));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(5,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOriginWithIndex));</highlight></codeline>
</programlisting></para>
<para>you could write</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Unused;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>DistanceToOrigin(Unused,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(</highlight><highlight class="stringliteral">&quot;abc&quot;</highlight><highlight class="normal">,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOrigin));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(5,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOrigin));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md157">
<title>Sharing Actions</title>
<para>Just like matchers, a gMock action object consists of a pointer to a ref-counted implementation object. Therefore copying actions is also allowed and very efficient. When the last action that references the implementation object dies, the implementation object will be deleted.</para>
<para>If you have some complex action that you want to use again and again, you may not have to build it from scratch every time. If the action doesn&apos;t have an internal state (i.e. if it always does the same thing no matter how many times it has been called), you can assign it to an action variable and use that variable repeatedly. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Action;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArgPointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Action&lt;bool(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)&gt;<sp/>set_flag<sp/>=<sp/>DoAll(SetArgPointee&lt;0&gt;(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(</highlight><highlight class="keyword">true</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>set_flag<sp/>in<sp/>.WillOnce()<sp/>and<sp/>.WillRepeatedly()<sp/>...</highlight></codeline>
</programlisting></para>
<para>However, if the action has its own state, you may be surprised if you share the action object. Suppose you have an action factory <computeroutput>IncrementCounter(init)</computeroutput> which creates an action that increments and returns a counter whose initial value is <computeroutput>init</computeroutput>, using two actions created from the same expression and using a shared action will exhibit different behaviors. Example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillRepeatedly(IncrementCounter(0));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(foo,<sp/>DoThat())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillRepeatedly(IncrementCounter(0));</highlight></codeline>
<codeline><highlight class="normal">foo.DoThis();<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">foo.DoThis();<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">foo.DoThat();<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>1<sp/>-<sp/>DoThat()<sp/>uses<sp/>a<sp/>different</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>counter<sp/>than<sp/>DoThis()&apos;s.</highlight></codeline>
</programlisting></para>
<para>versus</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Action;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Action&lt;int()&gt;<sp/>increment<sp/>=<sp/>IncrementCounter(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(increment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(increment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat();<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>3<sp/>-<sp/>the<sp/>counter<sp/>is<sp/>shared.</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md158">
<title>Testing Asynchronous Behavior</title>
<para>One oft-encountered problem with gMock is that it can be hard to test asynchronous behavior. Suppose you had a <computeroutput>EventQueue</computeroutput> class that you wanted to test, and you created a separate <computeroutput>EventDispatcher</computeroutput> interface so that you could easily mock it out. However, the implementation of the class fired all the events on a background thread, which made test timings difficult. You could just insert <computeroutput>sleep()</computeroutput> statements and hope for the best, but that makes your test behavior nondeterministic. A better way is to use gMock actions and <computeroutput>Notification</computeroutput> objects to force your asynchronous test to behave synchronously.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockEventDispatcher<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>EventDispatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>DispatchEvent,<sp/>(int32),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST(EventQueueTest,<sp/>EnqueueEventTest)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockEventDispatcher<sp/>mock_event_dispatcher;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EventQueue<sp/>event_queue(&amp;mock_event_dispatcher);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>int32<sp/>kEventId<sp/>=<sp/>321;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>absl::Notification<sp/>done;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_event_dispatcher,<sp/>DispatchEvent(kEventId))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce([&amp;done]<sp/>{<sp/>done.Notify();<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>event_queue.EnqueueEvent(kEventId);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>done.WaitForNotification();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>In the example above, we set our normal gMock expectations, but then add an additional action to notify the <computeroutput>Notification</computeroutput> object. Now we can just call <computeroutput>Notification::WaitForNotification()</computeroutput> in the main thread to wait for the asynchronous call to finish. After that, our test suite is complete and we can safely exit.</para>
<para>{: .callout .note} Note: this example has a downside: namely, if the expectation is not satisfied, our test will run forever. It will eventually time-out and fail, but it will take longer and be slightly harder to debug. To alleviate this problem, you can use <computeroutput>WaitForNotificationWithTimeout(ms)</computeroutput> instead of <computeroutput>WaitForNotification()</computeroutput>.</para>
</sect2>
</sect1>
<sect1 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md159">
<title>Misc Recipes on Using gMock</title>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md160">
<title>Mocking Methods That Use Move-Only Types</title>
<para>C++11 introduced <emphasis>move-only types</emphasis>. A move-only-typed value can be moved from one object to another, but cannot be copied. <computeroutput>std::unique_ptr&lt;T&gt;</computeroutput> is probably the most commonly used move-only type.</para>
<para>Mocking a method that takes and/or returns move-only types presents some challenges, but nothing insurmountable. This recipe shows you how you can do it. Note that the support for move-only method arguments was only introduced to gMock in April 2017; in older code, you may find more complex <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1LegacyMoveOnly" kindref="member">workarounds</ref> for lack of this feature.</para>
<para>Lets say we are working on a fictional project that lets one post and share snippets called buzzes. Your code uses these types:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"><sp/>AccessLevel<sp/>{<sp/>kInternal,<sp/>kPublic<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Buzz<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">explicit</highlight><highlight class="normal"><sp/>Buzz(AccessLevel<sp/>access)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~Buzzer()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>std::unique_ptr&lt;Buzz&gt;<sp/>MakeBuzz(StringPiece<sp/>text)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ShareBuzz(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>int64_t<sp/>timestamp)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>A <computeroutput>Buzz</computeroutput> object represents a snippet being posted. A class that implements the <computeroutput>Buzzer</computeroutput> interface is capable of creating and sharing <computeroutput>Buzz</computeroutput>es. Methods in <computeroutput>Buzzer</computeroutput> may return a <computeroutput>unique_ptr&lt;Buzz&gt;</computeroutput> or take a <computeroutput>unique_ptr&lt;Buzz&gt;</computeroutput>. Now we need to mock <computeroutput>Buzzer</computeroutput> in our tests.</para>
<para>To mock a method that accepts or returns move-only types, you just use the familiar <computeroutput>MOCK_METHOD</computeroutput> syntax as usual:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockBuzzer<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(std::unique_ptr&lt;Buzz&gt;,<sp/>MakeBuzz,<sp/>(StringPiece<sp/>text),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>ShareBuzz,<sp/>(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>int64_t<sp/>timestamp),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Now that we have the mock class defined, we can use it in tests. In the following code examples, we assume that we have defined a <computeroutput>MockBuzzer</computeroutput> object named <computeroutput>mock_buzzer_</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MockBuzzer<sp/>mock_buzzer_;</highlight></codeline>
</programlisting></para>
<para>First lets see how we can set expectations on the <computeroutput>MakeBuzz()</computeroutput> method, which returns a <computeroutput>unique_ptr&lt;Buzz&gt;</computeroutput>.</para>
<para>As usual, if you set an expectation without an action (i.e. the <computeroutput>.WillOnce()</computeroutput> or <computeroutput>.WillRepeatedly()</computeroutput> clause), when that expectation fires, the default action for that method will be taken. Since <computeroutput>unique_ptr&lt;&gt;</computeroutput> has a default constructor that returns a null <computeroutput>unique_ptr</computeroutput>, thats what youll get if you dont specify an action:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::IsNull;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>the<sp/>default<sp/>action.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(</highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Triggers<sp/>the<sp/>previous<sp/>EXPECT_CALL.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(mock_buzzer_.MakeBuzz(</highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal">),<sp/>IsNull());</highlight></codeline>
</programlisting></para>
<para>If you are not happy with the default action, you can tweak it as usual; see <ref refid="md_build__deps_googletest_src_docs_gmock_cheat_sheet_1OnCall" kindref="member">Setting Default Actions</ref>.</para>
<para>If you just need to return a move-only value, you can use it in combination with <computeroutput>WillOnce</computeroutput>. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(</highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(Return(std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal)));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_NE(</highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,<sp/>mock_buzzer_.MakeBuzz(</highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal">));</highlight></codeline>
</programlisting></para>
<para>Quiz time! What do you think will happen if a <computeroutput>Return</computeroutput> action is performed more than once (e.g. you write <computeroutput>... .WillRepeatedly(Return(std::move(...)));</computeroutput>)? Come think of it, after the first time the action runs, the source value will be consumed (since its a move-only value), so the next time around, theres no value to move from <ndash/> youll get a run-time error that <computeroutput>Return(std::move(...))</computeroutput> can only be run once.</para>
<para>If you need your mock method to do more than just moving a pre-defined value, remember that you can always use a lambda or a callable object, which can do pretty much anything you want:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(</highlight><highlight class="stringliteral">&quot;x&quot;</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillRepeatedly([](StringPiece<sp/>text)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_NE(</highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,<sp/>mock_buzzer_.MakeBuzz(</highlight><highlight class="stringliteral">&quot;x&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_NE(</highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,<sp/>mock_buzzer_.MakeBuzz(</highlight><highlight class="stringliteral">&quot;x&quot;</highlight><highlight class="normal">));</highlight></codeline>
</programlisting></para>
<para>Every time this <computeroutput>EXPECT_CALL</computeroutput> fires, a new <computeroutput>unique_ptr&lt;Buzz&gt;</computeroutput> will be created and returned. You cannot do this with <computeroutput>Return(std::make_unique&lt;...&gt;(...))</computeroutput>.</para>
<para>That covers returning move-only values; but how do we work with methods accepting move-only arguments? The answer is that they work normally, although some actions will not compile when any of method&apos;s arguments are move-only. You can always use <computeroutput>Return</computeroutput>, or a <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1FunctionsAsActions" kindref="member">lambda or functor</ref>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Unused;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock_buzzer_,<sp/>ShareBuzz(NotNull(),<sp/>_)).WillOnce(Return(</highlight><highlight class="keyword">true</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_TRUE(mock_buzzer_.ShareBuzz(std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock_buzzer_,<sp/>ShareBuzz(_,<sp/>_)).WillOnce(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[](std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>Unused)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>buzz<sp/>!=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">EXPECT_FALSE(mock_buzzer_.ShareBuzz(</highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,<sp/>0));</highlight></codeline>
</programlisting></para>
<para>Many built-in actions (<computeroutput>WithArgs</computeroutput>, <computeroutput>WithoutArgs</computeroutput>,<computeroutput>DeleteArg</computeroutput>, <computeroutput>SaveArg</computeroutput>, ...) could in principle support move-only arguments, but the support for this is not implemented yet. If this is blocking you, please file a bug.</para>
<para>A few actions (e.g. <computeroutput>DoAll</computeroutput>) copy their arguments internally, so they can never work with non-copyable objects; you&apos;ll have to use functors instead.</para>
<sect3 id="md_build__deps_googletest_src_docs_gmock_cook_book_1LegacyMoveOnly">
<title>Legacy workarounds for move-only types</title>
<para>Support for move-only function arguments was only introduced to gMock in April of 2017. In older code, you may encounter the following workaround for the lack of this feature (it is no longer necessary - we&apos;re including it just for reference):</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockBuzzer<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>DoShareBuzz,<sp/>(Buzz*<sp/>buzz,<sp/>Time<sp/>timestamp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ShareBuzz(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>Time<sp/>timestamp)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>DoShareBuzz(buzz.get(),<sp/>timestamp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>The trick is to delegate the <computeroutput>ShareBuzz()</computeroutput> method to a mock method (lets call it <computeroutput>DoShareBuzz()</computeroutput>) that does not take move-only parameters. Then, instead of setting expectations on <computeroutput>ShareBuzz()</computeroutput>, you set them on the <computeroutput>DoShareBuzz()</computeroutput> mock method:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MockBuzzer<sp/>mock_buzzer_;</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock_buzzer_,<sp/>DoShareBuzz(NotNull(),<sp/>_));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>When<sp/>one<sp/>calls<sp/>ShareBuzz()<sp/>on<sp/>the<sp/>MockBuzzer<sp/>like<sp/>this,<sp/>the<sp/>call<sp/>is</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>forwarded<sp/>to<sp/>DoShareBuzz(),<sp/>which<sp/>is<sp/>mocked.<sp/><sp/>Therefore<sp/>this<sp/>statement</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>will<sp/>trigger<sp/>the<sp/>above<sp/>EXPECT_CALL.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mock_buzzer_.ShareBuzz(std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal),<sp/>0);</highlight></codeline>
</programlisting></para>
</sect3>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md161">
<title>Making the Compilation Faster</title>
<para>Believe it or not, the <emphasis>vast majority</emphasis> of the time spent on compiling a mock class is in generating its constructor and destructor, as they perform non-trivial tasks (e.g. verification of the expectations). What&apos;s more, mock methods with different signatures have different types and thus their constructors/destructors need to be generated by the compiler separately. As a result, if you mock many different types of methods, compiling your mock class can get really slow.</para>
<para>If you are experiencing slow compilation, you can move the definition of your mock class&apos; constructor and destructor out of the class body and into a <computeroutput>.cc</computeroutput> file. This way, even if you <computeroutput>#include</computeroutput> your mock class in N files, the compiler only needs to generate its constructor and destructor once, resulting in a much faster compilation.</para>
<para>Let&apos;s illustrate the idea using an example. Here&apos;s the definition of a mock class before applying this recipe:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>File<sp/>mock_foo.h.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Since<sp/>we<sp/>don&apos;t<sp/>declare<sp/>the<sp/>constructor<sp/>or<sp/>the<sp/>destructor,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>compiler<sp/>will<sp/>generate<sp/>them<sp/>in<sp/>every<sp/>translation<sp/>unit</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>where<sp/>this<sp/>mock<sp/>class<sp/>is<sp/>used.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>DoThis,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>DoThat,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>more<sp/>mock<sp/>methods<sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>After the change, it would look like:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>File<sp/>mock_foo.h.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>constructor<sp/>and<sp/>destructor<sp/>are<sp/>declared,<sp/>but<sp/>not<sp/>defined,<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~MockFoo();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>DoThis,<sp/>(),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">,<sp/>DoThat,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>more<sp/>mock<sp/>methods<sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>and</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>File<sp/>mock_foo.cc.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;path/to/mock_foo.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>definitions<sp/>may<sp/>appear<sp/>trivial,<sp/>but<sp/>the<sp/>functions<sp/>actually<sp/>do<sp/>a</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>lot<sp/>of<sp/>things<sp/>through<sp/>the<sp/>constructors/destructors<sp/>of<sp/>the<sp/>member</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>variables<sp/>used<sp/>to<sp/>implement<sp/>the<sp/>mock<sp/>methods.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MockFoo::MockFoo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">MockFoo::~MockFoo()<sp/>{}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md162">
<title>Forcing a Verification</title>
<para>When it&apos;s being destroyed, your friendly mock object will automatically verify that all expectations on it have been satisfied, and will generate googletest failures if not. This is convenient as it leaves you with one less thing to worry about. That is, unless you are not sure if your mock object will be destroyed.</para>
<para>How could it be that your mock object won&apos;t eventually be destroyed? Well, it might be created on the heap and owned by the code you are testing. Suppose there&apos;s a bug in that code and it doesn&apos;t delete the mock object properly - you could end up with a passing test when there&apos;s actually a bug.</para>
<para>Using a heap checker is a good idea and can alleviate the concern, but its implementation is not 100% reliable. So, sometimes you do want to <emphasis>force</emphasis> gMock to verify a mock object before it is (hopefully) destructed. You can do this with <computeroutput>Mock::VerifyAndClearExpectations(&amp;mock_object)</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">TEST(MyServerTest,<sp/>ProcessesRequest)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::Mock;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>foo<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>MockFoo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(*foo,<sp/>...)...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/>other<sp/>expectations<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>server<sp/>now<sp/>owns<sp/>foo.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyServer<sp/>server(foo);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>server.ProcessRequest(...);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>case<sp/>that<sp/>server&apos;s<sp/>destructor<sp/>will<sp/>forget<sp/>to<sp/>delete<sp/>foo,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>this<sp/>will<sp/>verify<sp/>the<sp/>expectations<sp/>anyway.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mock::VerifyAndClearExpectations(foo);</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/></highlight><highlight class="comment">//<sp/>server<sp/>is<sp/>destroyed<sp/>when<sp/>it<sp/>goes<sp/>out<sp/>of<sp/>scope<sp/>here.</highlight></codeline>
</programlisting></para>
<para>{: .callout .tip} <bold>Tip:</bold> The <computeroutput>Mock::VerifyAndClearExpectations()</computeroutput> function returns a <computeroutput>bool</computeroutput> to indicate whether the verification was successful (<computeroutput>true</computeroutput> for yes), so you can wrap that function call inside a <computeroutput>ASSERT_TRUE()</computeroutput> if there is no point going further when the verification has failed.</para>
<para>Do not set new expectations after verifying and clearing a mock after its use. Setting expectations after code that exercises the mock has undefined behavior. See <ulink url="gmock_for_dummies.md#using-mocks-in-tests">Using Mocks in Tests</ulink> for more information.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1UsingCheckPoints">
<title>Using Checkpoints</title>
<para>Sometimes you might want to test a mock object&apos;s behavior in phases whose sizes are each manageable, or you might want to set more detailed expectations about which API calls invoke which mock functions.</para>
<para>A technique you can use is to put the expectations in a sequence and insert calls to a dummy &quot;checkpoint&quot; function at specific places. Then you can verify that the mock function calls do happen at the right time. For example, if you are exercising the code:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">Foo(1);</highlight></codeline>
<codeline><highlight class="normal">Foo(2);</highlight></codeline>
<codeline><highlight class="normal">Foo(3);</highlight></codeline>
</programlisting></para>
<para>and want to verify that <computeroutput>Foo(1)</computeroutput> and <computeroutput>Foo(3)</computeroutput> both invoke <computeroutput>mock.Bar(&quot;a&quot;)</computeroutput>, but <computeroutput>Foo(2)</computeroutput> doesn&apos;t invoke anything, you can write:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::MockFunction;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST(FooTest,<sp/>InvokesBarCorrectly)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyMock<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Class<sp/>MockFunction&lt;F&gt;<sp/>has<sp/>exactly<sp/>one<sp/>mock<sp/>method.<sp/><sp/>It<sp/>is<sp/>named</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Call()<sp/>and<sp/>has<sp/>type<sp/>F.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFunction&lt;void(</highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>check_point_name)&gt;<sp/>check;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(check,<sp/>Call(</highlight><highlight class="stringliteral">&quot;1&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(check,<sp/>Call(</highlight><highlight class="stringliteral">&quot;2&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>check.Call(</highlight><highlight class="stringliteral">&quot;1&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>check.Call(</highlight><highlight class="stringliteral">&quot;2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(3);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The expectation spec says that the first <computeroutput>Bar(&quot;a&quot;)</computeroutput> call must happen before checkpoint &quot;1&quot;, the second <computeroutput>Bar(&quot;a&quot;)</computeroutput> call must happen after checkpoint &quot;2&quot;, and nothing should happen between the two checkpoints. The explicit checkpoints make it clear which <computeroutput>Bar(&quot;a&quot;)</computeroutput> is called by which call to <computeroutput>Foo()</computeroutput>.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md163">
<title>Mocking Destructors</title>
<para>Sometimes you want to make sure a mock object is destructed at the right time, e.g. after <computeroutput>bar-&gt;A()</computeroutput> is called but before <computeroutput>bar-&gt;B()</computeroutput> is called. We already know that you can specify constraints on the <ref refid="md_build__deps_googletest_src_docs_gmock_for_dummies_1OrderedCalls" kindref="member">order</ref> of mock function calls, so all we need to do is to mock the destructor of the mock function.</para>
<para>This sounds simple, except for one problem: a destructor is a special function with special syntax and special semantics, and the <computeroutput>MOCK_METHOD</computeroutput> macro doesn&apos;t work for it:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>~MockFoo,<sp/>());<sp/><sp/></highlight><highlight class="comment">//<sp/>Won&apos;t<sp/>compile!</highlight></codeline>
</programlisting></para>
<para>The good news is that you can use a simple pattern to achieve the same effect. First, add a mock function <computeroutput>Die()</computeroutput> to your mock class and call it in the destructor, like this:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>the<sp/>following<sp/>two<sp/>lines<sp/>to<sp/>the<sp/>mock<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>Die,<sp/>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>~MockFoo()</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{<sp/>Die();<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>(If the name <computeroutput>Die()</computeroutput> clashes with an existing symbol, choose another name.) Now, we have translated the problem of testing when a <computeroutput><ref refid="classMockFoo" kindref="compound">MockFoo</ref></computeroutput> object dies to testing when its <computeroutput>Die()</computeroutput> method is called:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MockFoo*<sp/>foo<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>MockFoo;</highlight></codeline>
<codeline><highlight class="normal">MockBar*<sp/>bar<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>MockBar;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Expects<sp/>*foo<sp/>to<sp/>die<sp/>after<sp/>bar-&gt;A()<sp/>and<sp/>before<sp/>bar-&gt;B().</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(*bar,<sp/>A());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(*foo,<sp/>Die());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(*bar,<sp/>B());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>And that&apos;s that.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1UsingThreads">
<title>Using gMock and Threads</title>
<para>In a <bold>unit</bold> test, it&apos;s best if you could isolate and test a piece of code in a single-threaded context. That avoids race conditions and dead locks, and makes debugging your test much easier.</para>
<para>Yet most programs are multi-threaded, and sometimes to test something we need to pound on it from more than one thread. gMock works for this purpose too.</para>
<para>Remember the steps for using a mock:</para>
<para><orderedlist>
<listitem><para>Create a mock object <computeroutput>foo</computeroutput>.</para>
</listitem><listitem><para>Set its default actions and expectations using <computeroutput>ON_CALL()</computeroutput> and <computeroutput>EXPECT_CALL()</computeroutput>.</para>
</listitem><listitem><para>The code under test calls methods of <computeroutput>foo</computeroutput>.</para>
</listitem><listitem><para>Optionally, verify and reset the mock.</para>
</listitem><listitem><para>Destroy the mock yourself, or let the code under test destroy it. The destructor will automatically verify it.</para>
</listitem></orderedlist>
</para>
<para>If you follow the following simple rules, your mocks and threads can live happily together:</para>
<para><itemizedlist>
<listitem><para>Execute your <emphasis>test code</emphasis> (as opposed to the code being tested) in <emphasis>one</emphasis> thread. This makes your test easy to follow.</para>
</listitem><listitem><para>Obviously, you can do step #1 without locking.</para>
</listitem><listitem><para>When doing step #2 and #5, make sure no other thread is accessing <computeroutput>foo</computeroutput>. Obvious too, huh?</para>
</listitem><listitem><para>#3 and #4 can be done either in one thread or in multiple threads - anyway you want. gMock takes care of the locking, so you don&apos;t have to do any - unless required by your test logic.</para>
</listitem></itemizedlist>
</para>
<para>If you violate the rules (for example, if you set expectations on a mock while another thread is calling its methods), you get undefined behavior. That&apos;s not fun, so don&apos;t do it.</para>
<para>gMock guarantees that the action for a mock function is done in the same thread that called the mock function. For example, in</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Foo(1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(action1);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Foo(2))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillOnce(action2);</highlight></codeline>
</programlisting></para>
<para>if <computeroutput>Foo(1)</computeroutput> is called in thread 1 and <computeroutput>Foo(2)</computeroutput> is called in thread 2, gMock will execute <computeroutput>action1</computeroutput> in thread 1 and <computeroutput>action2</computeroutput> in thread 2.</para>
<para>gMock does <emphasis>not</emphasis> impose a sequence on actions performed in different threads (doing so may create deadlocks as the actions may need to cooperate). This means that the execution of <computeroutput>action1</computeroutput> and <computeroutput>action2</computeroutput> in the above example <emphasis>may</emphasis> interleave. If this is a problem, you should add proper synchronization logic to <computeroutput>action1</computeroutput> and <computeroutput>action2</computeroutput> to make the test thread-safe.</para>
<para>Also, remember that <computeroutput>DefaultValue&lt;T&gt;</computeroutput> is a global resource that potentially affects <emphasis>all</emphasis> living mock objects in your program. Naturally, you won&apos;t want to mess with it from multiple threads or when there still are mocks in action.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md164">
<title>Controlling How Much Information gMock Prints</title>
<para>When gMock sees something that has the potential of being an error (e.g. a mock function with no expectation is called, a.k.a. an uninteresting call, which is allowed but perhaps you forgot to explicitly ban the call), it prints some warning messages, including the arguments of the function, the return value, and the stack trace. Hopefully this will remind you to take a look and see if there is indeed a problem.</para>
<para>Sometimes you are confident that your tests are correct and may not appreciate such friendly messages. Some other times, you are debugging your tests or learning about the behavior of the code you are testing, and wish you could observe every mock call that happens (including argument values, the return value, and the stack trace). Clearly, one size doesn&apos;t fit all.</para>
<para>You can control how much gMock tells you using the <computeroutput>--gmock_verbose=LEVEL</computeroutput> command-line flag, where <computeroutput>LEVEL</computeroutput> is a string with three possible values:</para>
<para><itemizedlist>
<listitem><para><computeroutput>info</computeroutput>: gMock will print all informational messages, warnings, and errors (most verbose). At this setting, gMock will also log any calls to the <computeroutput>ON_CALL/EXPECT_CALL</computeroutput> macros. It will include a stack trace in &quot;uninteresting call&quot; warnings.</para>
</listitem><listitem><para><computeroutput>warning</computeroutput>: gMock will print both warnings and errors (less verbose); it will omit the stack traces in &quot;uninteresting call&quot; warnings. This is the default.</para>
</listitem><listitem><para><computeroutput>error</computeroutput>: gMock will print errors only (least verbose).</para>
</listitem></itemizedlist>
</para>
<para>Alternatively, you can adjust the value of that flag from within your tests like so:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">::testing::FLAGS_gmock_verbose<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;error&quot;</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para>
<para>If you find gMock printing too many stack frames with its informational or warning messages, remember that you can control their amount with the <computeroutput>--gtest_stack_trace_depth=max_depth</computeroutput> flag.</para>
<para>Now, judiciously use the right flag to enable gMock serve you better!</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md165">
<title>Gaining Super Vision into Mock Calls</title>
<para>You have a test using gMock. It fails: gMock tells you some expectations aren&apos;t satisfied. However, you aren&apos;t sure why: Is there a typo somewhere in the matchers? Did you mess up the order of the <computeroutput>EXPECT_CALL</computeroutput>s? Or is the code under test doing something wrong? How can you find out the cause?</para>
<para>Won&apos;t it be nice if you have X-ray vision and can actually see the trace of all <computeroutput>EXPECT_CALL</computeroutput>s and mock method calls as they are made? For each call, would you like to see its actual argument values and which <computeroutput>EXPECT_CALL</computeroutput> gMock thinks it matches? If you still need some help to figure out who made these calls, how about being able to see the complete stack trace at each mock call?</para>
<para>You can unlock this power by running your test with the <computeroutput>--gmock_verbose=info</computeroutput> flag. For example, given the test program:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;gmock/gmock.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::HasSubstr;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">,<sp/>F,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>x,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">&amp;<sp/>y));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">TEST(Foo,<sp/>Bar)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_)).WillRepeatedly(Return());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;b&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(</highlight><highlight class="stringliteral">&quot;c&quot;</highlight><highlight class="normal">,<sp/>HasSubstr(</highlight><highlight class="stringliteral">&quot;d&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock.F(</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;good&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock.F(</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;b&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>if you run it with <computeroutput>--gmock_verbose=info</computeroutput>, you will see this output:</para>
<para><programlisting filename=".shell"><codeline><highlight class="normal">[<sp/>RUN<sp/><sp/><sp/><sp/><sp/><sp/><sp/>]<sp/>Foo.Bar</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:14:<sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:15:<sp/>EXPECT_CALL(mock,<sp/>F(&quot;a&quot;,<sp/>&quot;b&quot;))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:16:<sp/>EXPECT_CALL(mock,<sp/>F(&quot;c&quot;,<sp/>HasSubstr(&quot;d&quot;)))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:14:<sp/>Mock<sp/>function<sp/>call<sp/>matches<sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Function<sp/>call:<sp/>F(@0x7fff7c8dad40&quot;a&quot;,@0x7fff7c8dad10&quot;good&quot;)</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:15:<sp/>Mock<sp/>function<sp/>call<sp/>matches<sp/>EXPECT_CALL(mock,<sp/>F(&quot;a&quot;,<sp/>&quot;b&quot;))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Function<sp/>call:<sp/>F(@0x7fff7c8dada0&quot;a&quot;,@0x7fff7c8dad70&quot;b&quot;)</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:16:<sp/>Failure</highlight></codeline>
<codeline><highlight class="normal">Actual<sp/>function<sp/>call<sp/>count<sp/>doesn&apos;t<sp/>match<sp/>EXPECT_CALL(mock,<sp/>F(&quot;c&quot;,<sp/>HasSubstr(&quot;d&quot;)))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Expected:<sp/>to<sp/>be<sp/>called<sp/>once</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Actual:<sp/>never<sp/>called<sp/>-<sp/>unsatisfied<sp/>and<sp/>active</highlight></codeline>
<codeline><highlight class="normal">[<sp/><sp/>FAILED<sp/><sp/>]<sp/>Foo.Bar</highlight></codeline>
</programlisting></para>
<para>Suppose the bug is that the <computeroutput>&quot;c&quot;</computeroutput> in the third <computeroutput>EXPECT_CALL</computeroutput> is a typo and should actually be <computeroutput>&quot;a&quot;</computeroutput>. With the above message, you should see that the actual <computeroutput>F(&quot;a&quot;, &quot;good&quot;)</computeroutput> call is matched by the first <computeroutput>EXPECT_CALL</computeroutput>, not the third as you thought. From that it should be obvious that the third <computeroutput>EXPECT_CALL</computeroutput> is written wrong. Case solved.</para>
<para>If you are interested in the mock call trace but not the stack traces, you can combine <computeroutput>--gmock_verbose=info</computeroutput> with <computeroutput>--gtest_stack_trace_depth=0</computeroutput> on the test command line.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md166">
<title>Running Tests in Emacs</title>
<para>If you build and run your tests in Emacs using the <computeroutput>M-x google-compile</computeroutput> command (as many googletest users do), the source file locations of gMock and googletest errors will be highlighted. Just press <computeroutput>&lt;Enter&gt;</computeroutput> on one of them and you&apos;ll be taken to the offending line. Or, you can just type <computeroutput>C-x</computeroutput>` to jump to the next error.</para>
<para>To make it even easier, you can add the following lines to your <computeroutput>~/.emacs</computeroutput> file:</para>
<para><programlisting filename=".text"><codeline><highlight class="normal">(global-set-key<sp/>&quot;\M-m&quot;<sp/><sp/>&apos;google-compile)<sp/><sp/>;<sp/>m<sp/>is<sp/>for<sp/>make</highlight></codeline>
<codeline><highlight class="normal">(global-set-key<sp/>[M-down]<sp/>&apos;next-error)</highlight></codeline>
<codeline><highlight class="normal">(global-set-key<sp/>[M-up]<sp/><sp/>&apos;(lambda<sp/>()<sp/>(interactive)<sp/>(next-error<sp/>-1)))</highlight></codeline>
</programlisting></para>
<para>Then you can type <computeroutput>M-m</computeroutput> to start a build (if you want to run the test as well, just make sure <computeroutput>foo_test.run</computeroutput> or <computeroutput>runtests</computeroutput> is in the build command you supply after typing <computeroutput>M-m</computeroutput>), or <computeroutput>M-up</computeroutput>/<computeroutput>M-down</computeroutput> to move back and forth between errors.</para>
</sect2>
</sect1>
<sect1 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md167">
<title>Extending gMock</title>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1NewMatchers">
<title>Writing New Matchers Quickly</title>
<para>{: .callout .warning} WARNING: gMock does not guarantee when or how many times a matcher will be invoked. Therefore, all matchers must be functionally pure. See <ref refid="md_build__deps_googletest_src_docs_gmock_cook_book_1PureMatchers" kindref="member">this section</ref> for more details.</para>
<para>The <computeroutput>MATCHER*</computeroutput> family of macros can be used to define custom matchers easily. The syntax:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER(name,<sp/>description_string_expression)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
</programlisting></para>
<para>will define a matcher with the given name that executes the statements, which must return a <computeroutput>bool</computeroutput> to indicate if the match succeeds. Inside the statements, you can refer to the value being matched by <computeroutput>arg</computeroutput>, and refer to its type by <computeroutput>arg_type</computeroutput>.</para>
<para>The <emphasis>description string</emphasis> is a <computeroutput>string</computeroutput>-typed expression that documents what the matcher does, and is used to generate the failure message when the match fails. It can (and should) reference the special <computeroutput>bool</computeroutput> variable <computeroutput>negation</computeroutput>, and should evaluate to the description of the matcher when <computeroutput>negation</computeroutput> is <computeroutput>false</computeroutput>, or that of the matcher&apos;s negation when <computeroutput>negation</computeroutput> is <computeroutput>true</computeroutput>.</para>
<para>For convenience, we allow the description string to be empty (<computeroutput>&quot;&quot;</computeroutput>), in which case gMock will use the sequence of words in the matcher name as the description.</para>
<para>For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER(IsDivisibleBy7,<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(arg<sp/>%<sp/>7)<sp/>==<sp/>0;<sp/>}</highlight></codeline>
</programlisting></para>
<para>allows you to write</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Expects<sp/>mock_foo.Bar(n)<sp/>to<sp/>be<sp/>called<sp/>where<sp/>n<sp/>is<sp/>divisible<sp/>by<sp/>7.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock_foo,<sp/>Bar(IsDivisibleBy7()));</highlight></codeline>
</programlisting></para>
<para>or,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Not;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Verifies<sp/>that<sp/>a<sp/>value<sp/>is<sp/>divisible<sp/>by<sp/>7<sp/>and<sp/>the<sp/>other<sp/>is<sp/>not.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(some_expression,<sp/>IsDivisibleBy7());</highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(some_other_expression,<sp/>Not(IsDivisibleBy7()));</highlight></codeline>
</programlisting></para>
<para>If the above assertions fail, they will print something like:</para>
<para><programlisting filename=".shell"><codeline><highlight class="normal">Value<sp/>of:<sp/>some_expression</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>27</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>of:<sp/>some_other_expression</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>not<sp/>(is<sp/>divisible<sp/>by<sp/>7)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>21</highlight></codeline>
</programlisting></para>
<para>where the descriptions <computeroutput>&quot;is divisible by 7&quot;</computeroutput> and <computeroutput>&quot;not (is divisible by 7)&quot;</computeroutput> are automatically calculated from the matcher name <computeroutput>IsDivisibleBy7</computeroutput>.</para>
<para>As you may have noticed, the auto-generated descriptions (especially those for the negation) may not be so great. You can always override them with a <computeroutput>string</computeroutput> expression of your own:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER(IsDivisibleBy7,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>absl::StrCat(negation<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;isn&apos;t&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;is&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>divisible<sp/>by<sp/>7&quot;</highlight><highlight class="normal">))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(arg<sp/>%<sp/>7)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Optionally, you can stream additional information to a hidden argument named <computeroutput>result_listener</computeroutput> to explain the match result. For example, a better definition of <computeroutput>IsDivisibleBy7</computeroutput> is:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER(IsDivisibleBy7,<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((arg<sp/>%<sp/>7)<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result_listener<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>remainder<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(arg<sp/>%<sp/>7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>With this definition, the above assertion will give a better message:</para>
<para><programlisting filename=".shell"><codeline><highlight class="normal">Value<sp/>of:<sp/>some_expression</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>27<sp/>(the<sp/>remainder<sp/>is<sp/>6)</highlight></codeline>
</programlisting></para>
<para>You should let <computeroutput>MatchAndExplain()</computeroutput> print <emphasis>any additional information</emphasis> that can help a user understand the match result. Note that it should explain why the match succeeds in case of a success (unless it&apos;s obvious) - this is useful when the matcher is used inside <computeroutput>Not()</computeroutput>. There is no need to print the argument value itself, as gMock already prints it for you.</para>
<para>{: .callout .note} NOTE: The type of the value being matched (<computeroutput>arg_type</computeroutput>) is determined by the context in which you use the matcher and is supplied to you by the compiler, so you don&apos;t need to worry about declaring it (nor can you). This allows the matcher to be polymorphic. For example, <computeroutput>IsDivisibleBy7()</computeroutput> can be used to match any type where the value of <computeroutput>(arg % 7) == 0</computeroutput> can be implicitly converted to a <computeroutput>bool</computeroutput>. In the <computeroutput>Bar(IsDivisibleBy7())</computeroutput> example above, if method <computeroutput>Bar()</computeroutput> takes an <computeroutput>int</computeroutput>, <computeroutput>arg_type</computeroutput> will be <computeroutput>int</computeroutput>; if it takes an <computeroutput>unsigned long</computeroutput>, <computeroutput>arg_type</computeroutput> will be <computeroutput>unsigned long</computeroutput>; and so on.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md168">
<title>Writing New Parameterized Matchers Quickly</title>
<para>Sometimes you&apos;ll want to define a matcher that has parameters. For that you can use the macro:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER_P(name,<sp/>param_name,<sp/>description_string)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
</programlisting></para>
<para>where the description string can be either <computeroutput>&quot;&quot;</computeroutput> or a <computeroutput>string</computeroutput> expression that references <computeroutput>negation</computeroutput> and <computeroutput>param_name</computeroutput>.</para>
<para>For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER_P(HasAbsoluteValue,<sp/>value,<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>abs(arg)<sp/>==<sp/>value;<sp/>}</highlight></codeline>
</programlisting></para>
<para>will allow you to write:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">EXPECT_THAT(Blah(</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">),<sp/>HasAbsoluteValue(n));</highlight></codeline>
</programlisting></para>
<para>which may lead to this message (assuming <computeroutput>n</computeroutput> is 10):</para>
<para><programlisting filename=".shell"><codeline><highlight class="normal">Value<sp/>of:<sp/>Blah(&quot;a&quot;)</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>has<sp/>absolute<sp/>value<sp/>10</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>-9</highlight></codeline>
</programlisting></para>
<para>Note that both the matcher description and its parameter are printed, making the message human-friendly.</para>
<para>In the matcher definition body, you can write <computeroutput>foo_type</computeroutput> to reference the type of a parameter named <computeroutput>foo</computeroutput>. For example, in the body of <computeroutput>MATCHER_P(HasAbsoluteValue, value)</computeroutput> above, you can write <computeroutput>value_type</computeroutput> to refer to the type of <computeroutput>value</computeroutput>.</para>
<para>gMock also provides <computeroutput>MATCHER_P2</computeroutput>, <computeroutput>MATCHER_P3</computeroutput>, ..., up to <computeroutput>MATCHER_P10</computeroutput> to support multi-parameter matchers:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER_Pk(name,<sp/>param_1,<sp/>...,<sp/>param_k,<sp/>description_string)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
</programlisting></para>
<para>Please note that the custom description string is for a particular <emphasis>instance</emphasis> of the matcher, where the parameters have been bound to actual values. Therefore usually you&apos;ll want the parameter values to be part of the description. gMock lets you do that by referencing the matcher parameters in the description string expression.</para>
<para>For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::PrintToString;</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P2(InClosedRange,<sp/>low,<sp/>hi,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>absl::StrFormat(</highlight><highlight class="stringliteral">&quot;%s<sp/>in<sp/>range<sp/>[%s,<sp/>%s]&quot;</highlight><highlight class="normal">,<sp/>negation<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;isn&apos;t&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;is&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintToString(low),<sp/>PrintToString(hi)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>low<sp/>&lt;=<sp/>arg<sp/>&amp;&amp;<sp/>arg<sp/>&lt;=<sp/>hi;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(3,<sp/>InClosedRange(4,<sp/>6));</highlight></codeline>
</programlisting></para>
<para>would generate a failure that contains the message:</para>
<para><programlisting filename=".shell"><codeline><highlight class="normal">Expected:<sp/>is<sp/>in<sp/>range<sp/>[4,<sp/>6]</highlight></codeline>
</programlisting></para>
<para>If you specify <computeroutput>&quot;&quot;</computeroutput> as the description, the failure message will contain the sequence of words in the matcher name followed by the parameter values printed as a tuple. For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER_P2(InClosedRange,<sp/>low,<sp/>hi,<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(3,<sp/>InClosedRange(4,<sp/>6));</highlight></codeline>
</programlisting></para>
<para>would generate a failure that contains the text:</para>
<para><programlisting filename=".shell"><codeline><highlight class="normal">Expected:<sp/>in<sp/>closed<sp/>range<sp/>(4,<sp/>6)</highlight></codeline>
</programlisting></para>
<para>For the purpose of typing, you can view</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER_Pk(Foo,<sp/>p1,<sp/>...,<sp/>pk,<sp/>description_string)<sp/>{<sp/>...<sp/>}</highlight></codeline>
</programlisting></para>
<para>as shorthand for</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>p1_type,<sp/>...,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>pk_type&gt;</highlight></codeline>
<codeline><highlight class="normal">FooMatcherPk&lt;p1_type,<sp/>...,<sp/>pk_type&gt;</highlight></codeline>
<codeline><highlight class="normal">Foo(p1_type<sp/>p1,<sp/>...,<sp/>pk_type<sp/>pk)<sp/>{<sp/>...<sp/>}</highlight></codeline>
</programlisting></para>
<para>When you write <computeroutput>Foo(v1, ..., vk)</computeroutput>, the compiler infers the types of the parameters <computeroutput>v1</computeroutput>, ..., and <computeroutput>vk</computeroutput> for you. If you are not happy with the result of the type inference, you can specify the types by explicitly instantiating the template, as in <computeroutput>Foo&lt;long, bool&gt;(5, false)</computeroutput>. As said earlier, you don&apos;t get to (or need to) specify <computeroutput>arg_type</computeroutput> as that&apos;s determined by the context in which the matcher is used.</para>
<para>You can assign the result of expression <computeroutput>Foo(p1, ..., pk)</computeroutput> to a variable of type <computeroutput>FooMatcherPk&lt;p1_type, ..., pk_type&gt;</computeroutput>. This can be useful when composing matchers. Matchers that don&apos;t have a parameter or have only one parameter have special types: you can assign <computeroutput>Foo()</computeroutput> to a <computeroutput>FooMatcher</computeroutput>-typed variable, and assign <computeroutput>Foo(p)</computeroutput> to a <computeroutput>FooMatcherP&lt;p_type&gt;</computeroutput>-typed variable.</para>
<para>While you can instantiate a matcher template with reference types, passing the parameters by pointer usually makes your code more readable. If, however, you still want to pass a parameter by reference, be aware that in the failure message generated by the matcher you will see the value of the referenced object but not its address.</para>
<para>You can overload matchers with different numbers of parameters:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MATCHER_P(Blah,<sp/>a,<sp/>description_string_1)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P2(Blah,<sp/>a,<sp/>b,<sp/>description_string_2)<sp/>{<sp/>...<sp/>}</highlight></codeline>
</programlisting></para>
<para>While it&apos;s tempting to always use the <computeroutput>MATCHER*</computeroutput> macros when defining a new matcher, you should also consider implementing the matcher interface directly instead (see the recipes that follow), especially if you need to use the matcher a lot. While these approaches require more work, they give you more control on the types of the value being matched and the matcher parameters, which in general leads to better compiler error messages that pay off in the long run. They also allow overloading matchers based on parameter types (as opposed to just based on the number of parameters).</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md169">
<title>Writing New Monomorphic Matchers</title>
<para>A matcher of argument type <computeroutput>T</computeroutput> implements the matcher interface for <computeroutput>T</computeroutput> and does two things: it tests whether a value of type <computeroutput>T</computeroutput> matches the matcher, and can describe what kind of values it matches. The latter ability is used for generating readable error messages when expectations are violated.</para>
<para>A matcher of <computeroutput>T</computeroutput> must declare a typedef like:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">is_gtest_matcher<sp/>=<sp/>void;</highlight></codeline>
</programlisting></para>
<para>and supports the following operations:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Match<sp/>a<sp/>value<sp/>and<sp/>optionally<sp/>explain<sp/>into<sp/>an<sp/>ostream.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>matched<sp/>=<sp/>matcher.MatchAndExplain(value,<sp/>maybe_os);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>where<sp/>`value`<sp/>is<sp/>of<sp/>type<sp/>`T`<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>`maybe_os`<sp/>is<sp/>of<sp/>type<sp/>`std::ostream*`,<sp/>where<sp/>it<sp/>can<sp/>be<sp/>null<sp/>if<sp/>the<sp/>caller</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>is<sp/>not<sp/>interested<sp/>in<sp/>there<sp/>textual<sp/>explanation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">matcher.DescribeTo(os);</highlight></codeline>
<codeline><highlight class="normal">matcher.DescribeNegationTo(os);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>where<sp/>`os`<sp/>is<sp/>of<sp/>type<sp/>`std::ostream*`.</highlight></codeline>
</programlisting></para>
<para>If you need a custom matcher but <computeroutput>Truly()</computeroutput> is not a good option (for example, you may not be happy with the way <computeroutput>Truly(predicate)</computeroutput> describes itself, or you may want your matcher to be polymorphic as <computeroutput>Eq(value)</computeroutput> is), you can define a matcher to do whatever you want in two steps: first implement the matcher interface, and then define a factory function to create a matcher instance. The second step is not strictly needed but it makes the syntax of using the matcher nicer.</para>
<para>For example, you can define a matcher to test whether an <computeroutput>int</computeroutput> is divisible by 7 and then use it like this:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">DivisibleBy7Matcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">is_gtest_matcher<sp/>=<sp/>void;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>MatchAndExplain(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/>std::ostream*)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(n<sp/>%<sp/>7)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;is<sp/>divisible<sp/>by<sp/>7&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeNegationTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;is<sp/>not<sp/>divisible<sp/>by<sp/>7&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Matcher&lt;int&gt;<sp/>DivisibleBy7()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>DivisibleBy7Matcher();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(DivisibleBy7()));</highlight></codeline>
</programlisting></para>
<para>You may improve the matcher message by streaming additional information to the <computeroutput>os</computeroutput> argument in <computeroutput>MatchAndExplain()</computeroutput>:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">DivisibleBy7Matcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>MatchAndExplain(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,<sp/>std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>remainder<sp/>=<sp/>n<sp/>%<sp/>7;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(remainder<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>os<sp/>!=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>remainder<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>remainder;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>remainder<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Then, <computeroutput>EXPECT_THAT(x, DivisibleBy7());</computeroutput> may generate a message like this:</para>
<para><programlisting filename=".shell"><codeline><highlight class="normal">Value<sp/>of:<sp/>x</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>23<sp/>(the<sp/>remainder<sp/>is<sp/>2)</highlight></codeline>
</programlisting></para>
<para>{: .callout .tip} Tip: for convenience, <computeroutput>MatchAndExplain()</computeroutput> can take a <computeroutput>MatchResultListener*</computeroutput> instead of <computeroutput>std::ostream*</computeroutput>.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md170">
<title>Writing New Polymorphic Matchers</title>
<para>Expanding what we learned above to <emphasis>polymorphic</emphasis> matchers is now just as simple as adding templates in the right place.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">NotNullMatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">is_gtest_matcher<sp/>=<sp/>void;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>To<sp/>implement<sp/>a<sp/>polymorphic<sp/>matcher,<sp/>we<sp/>just<sp/>need<sp/>to<sp/>make<sp/>MatchAndExplain<sp/>a</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>template<sp/>on<sp/>its<sp/>first<sp/>argument.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>this<sp/>example,<sp/>we<sp/>want<sp/>to<sp/>use<sp/>NotNull()<sp/>with<sp/>any<sp/>pointer,<sp/>so</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>MatchAndExplain()<sp/>accepts<sp/>a<sp/>pointer<sp/>of<sp/>any<sp/>type<sp/>as<sp/>its<sp/>first<sp/>argument.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>general,<sp/>you<sp/>can<sp/>define<sp/>MatchAndExplain()<sp/>as<sp/>an<sp/>ordinary<sp/>method<sp/>or</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>method<sp/>template,<sp/>or<sp/>even<sp/>overload<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>MatchAndExplain(T*<sp/>p,<sp/>std::ostream*)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p<sp/>!=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>matching<sp/>this<sp/>matcher.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;is<sp/>not<sp/>NULL&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>NOT<sp/>matching<sp/>this<sp/>matcher.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeNegationTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;is<sp/>NULL&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">NotNullMatcher<sp/>NotNull()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NotNullMatcher();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(NotNull()));<sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>a<sp/>non-NULL<sp/>pointer.</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md171">
<title>Legacy Matcher Implementation</title>
<para>Defining matchers used to be somewhat more complicated, in which it required several supporting classes and virtual functions. To implement a matcher for type <computeroutput>T</computeroutput> using the legacy API you have to derive from <computeroutput>MatcherInterface&lt;T&gt;</computeroutput> and call <computeroutput>MakeMatcher</computeroutput> to construct the object.</para>
<para>The interface looks like this:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MatchResultListener<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Streams<sp/>x<sp/>to<sp/>the<sp/>underlying<sp/>ostream;<sp/>does<sp/>nothing<sp/>if<sp/>the<sp/>ostream</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>is<sp/>NULL.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatchResultListener&amp;<sp/>operator&lt;&lt;(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>underlying<sp/>ostream.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ostream*<sp/>stream();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MatcherInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~MatcherInterface();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>true<sp/>if<sp/>and<sp/>only<sp/>if<sp/>the<sp/>matcher<sp/>matches<sp/>x;<sp/>also<sp/>explains<sp/>the<sp/>match</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>result<sp/>to<sp/>&apos;listener&apos;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>MatchAndExplain(T<sp/>x,<sp/>MatchResultListener*<sp/>listener)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Describes<sp/>this<sp/>matcher<sp/>to<sp/>an<sp/>ostream.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeTo(std::ostream*<sp/>os)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Describes<sp/>the<sp/>negation<sp/>of<sp/>this<sp/>matcher<sp/>to<sp/>an<sp/>ostream.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeNegationTo(std::ostream*<sp/>os)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Fortunately, most of the time you can define a polymorphic matcher easily with the help of <computeroutput>MakePolymorphicMatcher()</computeroutput>. Here&apos;s how you can define <computeroutput>NotNull()</computeroutput> as an example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::MakePolymorphicMatcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MatchResultListener;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::PolymorphicMatcher;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">NotNullMatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>To<sp/>implement<sp/>a<sp/>polymorphic<sp/>matcher,<sp/>first<sp/>define<sp/>a<sp/>COPYABLE<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>has<sp/>three<sp/>members<sp/>MatchAndExplain(),<sp/>DescribeTo(),<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>DescribeNegationTo(),<sp/>like<sp/>the<sp/>following.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>this<sp/>example,<sp/>we<sp/>want<sp/>to<sp/>use<sp/>NotNull()<sp/>with<sp/>any<sp/>pointer,<sp/>so</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>MatchAndExplain()<sp/>accepts<sp/>a<sp/>pointer<sp/>of<sp/>any<sp/>type<sp/>as<sp/>its<sp/>first<sp/>argument.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>general,<sp/>you<sp/>can<sp/>define<sp/>MatchAndExplain()<sp/>as<sp/>an<sp/>ordinary<sp/>method<sp/>or</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>method<sp/>template,<sp/>or<sp/>even<sp/>overload<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>MatchAndExplain(T*<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MatchResultListener*<sp/></highlight><highlight class="comment">/*<sp/>listener<sp/>*/</highlight><highlight class="normal">)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p<sp/>!=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>matching<sp/>this<sp/>matcher.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;is<sp/>not<sp/>NULL&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>NOT<sp/>matching<sp/>this<sp/>matcher.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeNegationTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;is<sp/>NULL&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>To<sp/>construct<sp/>a<sp/>polymorphic<sp/>matcher,<sp/>pass<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>to<sp/>MakePolymorphicMatcher().<sp/><sp/>Note<sp/>the<sp/>return<sp/>type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">PolymorphicMatcher&lt;NotNullMatcher&gt;<sp/>NotNull()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MakePolymorphicMatcher(NotNullMatcher());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(NotNull()));<sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>a<sp/>non-NULL<sp/>pointer.</highlight></codeline>
</programlisting></para>
<para>{: .callout .note} <bold>Note:</bold> Your polymorphic matcher class does <bold>not</bold> need to inherit from <computeroutput>MatcherInterface</computeroutput> or any other class, and its methods do <bold>not</bold> need to be virtual.</para>
<para>Like in a monomorphic matcher, you may explain the match result by streaming additional information to the <computeroutput>listener</computeroutput> argument in <computeroutput>MatchAndExplain()</computeroutput>.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md172">
<title>Writing New Cardinalities</title>
<para>A cardinality is used in <computeroutput>Times()</computeroutput> to tell gMock how many times you expect a call to occur. It doesn&apos;t have to be exact. For example, you can say <computeroutput>AtLeast(5)</computeroutput> or <computeroutput>Between(2, 4)</computeroutput>.</para>
<para>If the <ulink url="gmock_cheat_sheet.md#CardinalityList">built-in set</ulink> of cardinalities doesn&apos;t suit you, you are free to define your own by implementing the following interface (in namespace <computeroutput>testing</computeroutput>):</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">CardinalityInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~CardinalityInterface();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>true<sp/>if<sp/>and<sp/>only<sp/>if<sp/>call_count<sp/>calls<sp/>will<sp/>satisfy<sp/>this<sp/>cardinality.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsSatisfiedByCallCount(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>call_count)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>true<sp/>if<sp/>and<sp/>only<sp/>if<sp/>call_count<sp/>calls<sp/>will<sp/>saturate<sp/>this</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>cardinality.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsSaturatedByCallCount(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>call_count)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Describes<sp/>self<sp/>to<sp/>an<sp/>ostream.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeTo(std::ostream*<sp/>os)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>For example, to specify that a call must occur even number of times, you can write</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::Cardinality;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::CardinalityInterface;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakeCardinality;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">EvenNumberCardinality<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>CardinalityInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsSatisfiedByCallCount(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>call_count)</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(call_count<sp/>%<sp/>2)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsSaturatedByCallCount(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>call_count)</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DescribeTo(std::ostream*<sp/>os)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;called<sp/>even<sp/>number<sp/>of<sp/>times&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Cardinality<sp/>EvenNumber()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MakeCardinality(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>EvenNumberCardinality);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(3))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(EvenNumber());</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1QuickNewActions">
<title>Writing New Actions</title>
<para>If the built-in actions don&apos;t work for you, you can easily define your own one. All you need is a call operator with a signature compatible with the mocked function. So you can use a lambda:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MockFunction&lt;int(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)&gt;<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Call).WillOnce([](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>input)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>input<sp/>*<sp/>7;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(mock.AsStdFunction()(2),<sp/>14);</highlight></codeline>
</programlisting></para>
<para>Or a struct with a call operator (even a templated one):</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MultiplyBy<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>operator()(T<sp/>arg)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>arg<sp/>*<sp/>multiplier;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>multiplier;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Then<sp/>use:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>EXPECT_CALL(...).WillOnce(MultiplyBy{7});</highlight></codeline>
</programlisting></para>
<para>It&apos;s also fine for the callable to take no arguments, ignoring the arguments supplied to the mock function:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">MockFunction&lt;int(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)&gt;<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Call).WillOnce([]<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>17;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(mock.AsStdFunction()(0),<sp/>17);</highlight></codeline>
</programlisting></para>
<para>When used with <computeroutput>WillOnce</computeroutput>, the callable can assume it will be called at most once and is allowed to be a move-only type:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>An<sp/>action<sp/>that<sp/>contains<sp/>move-only<sp/>types<sp/>and<sp/>has<sp/>an<sp/>&amp;&amp;-qualified<sp/>operator,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>demanding<sp/>in<sp/>the<sp/>type<sp/>system<sp/>that<sp/>it<sp/>be<sp/>called<sp/>at<sp/>most<sp/>once.<sp/>This<sp/>can<sp/>be</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>used<sp/>with<sp/>WillOnce,<sp/>but<sp/>the<sp/>compiler<sp/>will<sp/>reject<sp/>it<sp/>if<sp/>handed<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>WillRepeatedly.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MoveOnlyAction<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::unique_ptr&lt;int&gt;<sp/>move_only_state;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::unique_ptr&lt;int&gt;<sp/>operator()()<sp/>&amp;&amp;<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::move(move_only_state);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MockFunction&lt;std::unique_ptr&lt;int&gt;()&gt;<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Call).WillOnce(MoveOnlyAction{std::make_unique&lt;int&gt;(17)});</highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(mock.AsStdFunction()(),<sp/>Pointee(Eq(17)));</highlight></codeline>
</programlisting></para>
<para>More generally, to use with a mock function whose signature is <computeroutput>R(Args...)</computeroutput> the object can be anything convertible to <computeroutput>OnceAction&lt;R(Args...)&gt;</computeroutput> or <computeroutput>Action&lt;R(Args...)</computeroutput>&gt;. The difference between the two is that <computeroutput>OnceAction</computeroutput> has weaker requirements (<computeroutput>Action</computeroutput> requires a copy-constructible input that can be called repeatedly whereas <computeroutput>OnceAction</computeroutput> requires only move-constructible and supports <computeroutput>&amp;&amp;</computeroutput>-qualified call operators), but can be used only with <computeroutput>WillOnce</computeroutput>. <computeroutput>OnceAction</computeroutput> is typically relevant only when supporting move-only types or actions that want a type-system guarantee that they will be called at most once.</para>
<para>Typically the <computeroutput>OnceAction</computeroutput> and <computeroutput>Action</computeroutput> templates need not be referenced directly in your actions: a struct or class with a call operator is sufficient, as in the examples above. But fancier polymorphic actions that need to know the specific return type of the mock function can define templated conversion operators to make that possible. See <computeroutput><ref refid="gmock-actions_8h_source" kindref="compound">gmock-actions.h</ref></computeroutput> for examples.</para>
<sect3 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md173">
<title>Legacy macro-based Actions</title>
<para>Before C++11, the functor-based actions were not supported; the old way of writing actions was through a set of <computeroutput>ACTION*</computeroutput> macros. We suggest to avoid them in new code; they hide a lot of logic behind the macro, potentially leading to harder-to-understand compiler errors. Nevertheless, we cover them here for completeness.</para>
<para>By writing</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION(name)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
</programlisting></para>
<para>in a namespace scope (i.e. not inside a class or function), you will define an action with the given name that executes the statements. The value returned by <computeroutput>statements</computeroutput> will be used as the return value of the action. Inside the statements, you can refer to the K-th (0-based) argument of the mock function as <computeroutput>argK</computeroutput>. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION(IncrementArg1)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>++(*arg1);<sp/>}</highlight></codeline>
</programlisting></para>
<para>allows you to write</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">...<sp/>WillOnce(IncrementArg1());</highlight></codeline>
</programlisting></para>
<para>Note that you don&apos;t need to specify the types of the mock function arguments. Rest assured that your code is type-safe though: you&apos;ll get a compiler error if <computeroutput>*arg1</computeroutput> doesn&apos;t support the <computeroutput>++</computeroutput> operator, or if the type of <computeroutput>++(*arg1)</computeroutput> isn&apos;t compatible with the mock function&apos;s return type.</para>
<para>Another example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION(Foo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(*arg2)(5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Blah();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*arg1<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>arg0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>defines an action <computeroutput>Foo()</computeroutput> that invokes argument #2 (a function pointer) with 5, calls function <computeroutput>Blah()</computeroutput>, sets the value pointed to by argument #1 to 0, and returns argument #0.</para>
<para>For more convenience and flexibility, you can also use the following pre-defined symbols in the body of <computeroutput>ACTION</computeroutput>:</para>
<para><table rows="5" cols="2"><row>
<entry thead="yes" align='left'><para><computeroutput>argK_type</computeroutput>   </para>
</entry><entry thead="yes" align='left'><para>The type of the K-th (0-based) argument of the mock function    </para>
</entry></row>
<row>
<entry thead="no" align='left'><para><computeroutput>args</computeroutput>   </para>
</entry><entry thead="no" align='left'><para>All arguments of the mock function as a tuple    </para>
</entry></row>
<row>
<entry thead="no" align='left'><para><computeroutput>args_type</computeroutput>   </para>
</entry><entry thead="no" align='left'><para>The type of all arguments of the mock function as a tuple    </para>
</entry></row>
<row>
<entry thead="no" align='left'><para><computeroutput>return_type</computeroutput>   </para>
</entry><entry thead="no" align='left'><para>The return type of the mock function    </para>
</entry></row>
<row>
<entry thead="no" align='left'><para><computeroutput>function_type</computeroutput>   </para>
</entry><entry thead="no" align='left'><para>The type of the mock function   </para>
</entry></row>
</table>
</para>
<para>For example, when using an <computeroutput>ACTION</computeroutput> as a stub action for mock function:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>DoSomething(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>flag,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>ptr);</highlight></codeline>
</programlisting></para>
<para>we have:</para>
<para><table rows="9" cols="2"><row>
<entry thead="yes"><para>Pre-defined Symbol   </para>
</entry><entry thead="yes"><para>Is Bound To    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>arg0</computeroutput>   </para>
</entry><entry thead="no"><para>the value of <computeroutput>flag</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>arg0_type</computeroutput>   </para>
</entry><entry thead="no"><para>the type <computeroutput>bool</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>arg1</computeroutput>   </para>
</entry><entry thead="no"><para>the value of <computeroutput>ptr</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>arg1_type</computeroutput>   </para>
</entry><entry thead="no"><para>the type <computeroutput>int*</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>args</computeroutput>   </para>
</entry><entry thead="no"><para>the tuple <computeroutput>(flag, ptr)</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>args_type</computeroutput>   </para>
</entry><entry thead="no"><para>the type <computeroutput>std::tuple&lt;bool, int*&gt;</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>return_type</computeroutput>   </para>
</entry><entry thead="no"><para>the type <computeroutput>int</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>function_type</computeroutput>   </para>
</entry><entry thead="no"><para>the type <computeroutput>int(bool, int*)</computeroutput>   </para>
</entry></row>
</table>
</para>
</sect3>
<sect3 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md174">
<title>Legacy macro-based parameterized Actions</title>
<para>Sometimes you&apos;ll want to parameterize an action you define. For that we have another macro</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION_P(name,<sp/>param)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
</programlisting></para>
<para>For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION_P(Add,<sp/>n)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>arg0<sp/>+<sp/>n;<sp/>}</highlight></codeline>
</programlisting></para>
<para>will allow you to write</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Returns<sp/>argument<sp/>#0<sp/>+<sp/>5.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...<sp/>WillOnce(Add(5));</highlight></codeline>
</programlisting></para>
<para>For convenience, we use the term <emphasis>arguments</emphasis> for the values used to invoke the mock function, and the term <emphasis>parameters</emphasis> for the values used to instantiate an action.</para>
<para>Note that you don&apos;t need to provide the type of the parameter either. Suppose the parameter is named <computeroutput>param</computeroutput>, you can also use the gMock-defined symbol <computeroutput>param_type</computeroutput> to refer to the type of the parameter as inferred by the compiler. For example, in the body of <computeroutput>ACTION_P(Add, n)</computeroutput> above, you can write <computeroutput>n_type</computeroutput> for the type of <computeroutput>n</computeroutput>.</para>
<para>gMock also provides <computeroutput>ACTION_P2</computeroutput>, <computeroutput>ACTION_P3</computeroutput>, and etc to support multi-parameter actions. For example,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION_P2(ReturnDistanceTo,<sp/>x,<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dx<sp/>=<sp/>arg0<sp/>-<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dy<sp/>=<sp/>arg1<sp/>-<sp/>y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sqrt(dx*dx<sp/>+<sp/>dy*dy);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>lets you write</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">...<sp/>WillOnce(ReturnDistanceTo(5.0,<sp/>26.5));</highlight></codeline>
</programlisting></para>
<para>You can view <computeroutput>ACTION</computeroutput> as a degenerated parameterized action where the number of parameters is 0.</para>
<para>You can also easily define actions overloaded on the number of parameters:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION_P(Plus,<sp/>a)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">ACTION_P2(Plus,<sp/>a,<sp/>b)<sp/>{<sp/>...<sp/>}</highlight></codeline>
</programlisting></para>
</sect3>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md175">
<title>Restricting the Type of an Argument or Parameter in an ACTION</title>
<para>For maximum brevity and reusability, the <computeroutput>ACTION*</computeroutput> macros don&apos;t ask you to provide the types of the mock function arguments and the action parameters. Instead, we let the compiler infer the types for us.</para>
<para>Sometimes, however, we may want to be more explicit about the types. There are several tricks to do that. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION(Foo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Makes<sp/>sure<sp/>arg0<sp/>can<sp/>be<sp/>converted<sp/>to<sp/>int.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>arg0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>n<sp/>instead<sp/>of<sp/>arg0<sp/>here<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ACTION_P(Bar,<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Makes<sp/>sure<sp/>the<sp/>type<sp/>of<sp/>arg1<sp/>is<sp/>const<sp/>char*.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>::testing::StaticAssertTypeEq&lt;const<sp/>char*,<sp/>arg1_type&gt;();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Makes<sp/>sure<sp/>param<sp/>can<sp/>be<sp/>converted<sp/>to<sp/>bool.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>flag<sp/>=<sp/>param;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>where <computeroutput>StaticAssertTypeEq</computeroutput> is a compile-time assertion in googletest that verifies two types are the same.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md176">
<title>Writing New Action Templates Quickly</title>
<para>Sometimes you want to give an action explicit template parameters that cannot be inferred from its value parameters. <computeroutput>ACTION_TEMPLATE()</computeroutput> supports that and can be viewed as an extension to <computeroutput>ACTION()</computeroutput> and <computeroutput>ACTION_P*()</computeroutput>.</para>
<para>The syntax:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ACTION_TEMPLATE(ActionName,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HAS_m_TEMPLATE_PARAMS(kind1,<sp/>name1,<sp/>...,<sp/>kind_m,<sp/>name_m),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AND_n_VALUE_PARAMS(p1,<sp/>...,<sp/>p_n))<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
</programlisting></para>
<para>defines an action template that takes <emphasis>m</emphasis> explicit template parameters and <emphasis>n</emphasis> value parameters, where <emphasis>m</emphasis> is in [1, 10] and <emphasis>n</emphasis> is in [0, 10]. <computeroutput>name_i</computeroutput> is the name of the <emphasis>i</emphasis>-th template parameter, and <computeroutput>kind_i</computeroutput> specifies whether it&apos;s a <computeroutput>typename</computeroutput>, an integral constant, or a template. <computeroutput>p_i</computeroutput> is the name of the <emphasis>i</emphasis>-th value parameter.</para>
<para>Example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>DuplicateArg&lt;k,<sp/>T&gt;(output)<sp/>converts<sp/>the<sp/>k-th<sp/>argument<sp/>of<sp/>the<sp/>mock</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>function<sp/>to<sp/>type<sp/>T<sp/>and<sp/>copies<sp/>it<sp/>to<sp/>*output.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ACTION_TEMPLATE(DuplicateArg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>the<sp/>comma<sp/>between<sp/>int<sp/>and<sp/>k:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HAS_2_TEMPLATE_PARAMS(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>k,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal">,<sp/>T),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AND_1_VALUE_PARAMS(output))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*output<sp/>=<sp/>T(std::get&lt;k&gt;(args));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>To create an instance of an action template, write:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ActionName&lt;t1,<sp/>...,<sp/>t_m&gt;(v1,<sp/>...,<sp/>v_n)</highlight></codeline>
</programlisting></para>
<para>where the <computeroutput>t</computeroutput>s are the template arguments and the <computeroutput>v</computeroutput>s are the value arguments. The value argument types are inferred by the compiler. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo).WillOnce(DuplicateArg&lt;1,<sp/>unsigned<sp/>char&gt;(&amp;n));</highlight></codeline>
</programlisting></para>
<para>If you want to explicitly specify the value argument types, you can provide additional template arguments:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">ActionName&lt;t1,<sp/>...,<sp/>t_m,<sp/>u1,<sp/>...,<sp/>u_k&gt;(v1,<sp/>...,<sp/>v_n)</highlight></codeline>
</programlisting></para>
<para>where <computeroutput>u_i</computeroutput> is the desired type of <computeroutput>v_i</computeroutput>.</para>
<para><computeroutput>ACTION_TEMPLATE</computeroutput> and <computeroutput>ACTION</computeroutput>/<computeroutput>ACTION_P*</computeroutput> can be overloaded on the number of value parameters, but not on the number of template parameters. Without the restriction, the meaning of the following is unclear:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">OverloadedAction&lt;int,<sp/>bool&gt;(x);</highlight></codeline>
</programlisting></para>
<para>Are we using a single-template-parameter action where <computeroutput>bool</computeroutput> refers to the type of <computeroutput>x</computeroutput>, or a two-template-parameter action where the compiler is asked to infer the type of <computeroutput>x</computeroutput>?</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md177">
<title>Using the ACTION Object&apos;s Type</title>
<para>If you are writing a function that returns an <computeroutput>ACTION</computeroutput> object, you&apos;ll need to know its type. The type depends on the macro used to define the action and the parameter types. The rule is relatively simple:</para>
<para><table rows="8" cols="3"><row>
<entry thead="yes"><para>Given Definition   </para>
</entry><entry thead="yes"><para>Expression   </para>
</entry><entry thead="yes"><para>Has Type    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>ACTION(Foo)</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>Foo()</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>FooAction</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>ACTION_TEMPLATE(Foo, HAS_m_TEMPLATE_PARAMS(...), AND_0_VALUE_PARAMS())</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>Foo&lt;t1, ..., t_m&gt;()</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>FooAction&lt;t1, ..., t_m&gt;</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>ACTION_P(Bar, param)</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>Bar(int_value)</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>BarActionP&lt;int&gt;</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>ACTION_TEMPLATE(Bar, HAS_m_TEMPLATE_PARAMS(...), AND_1_VALUE_PARAMS(p1))</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>Bar&lt;t1, ..., t_m&gt;(int_value)</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>BarActionP&lt;t1, ..., t_m, int&gt;</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>ACTION_P2(Baz, p1, p2)</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>Baz(bool_value, int_value)</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>BazActionP2&lt;bool, int&gt;</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para><computeroutput>ACTION_TEMPLATE(Baz, HAS_m_TEMPLATE_PARAMS(...), AND_2_VALUE_PARAMS(p1, p2))</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>Baz&lt;t1, ..., t_m&gt;(bool_value, int_value)</computeroutput>   </para>
</entry><entry thead="no"><para><computeroutput>BazActionP2&lt;t1, ..., t_m, bool, int&gt;</computeroutput>    </para>
</entry></row>
<row>
<entry thead="no"><para>...   </para>
</entry><entry thead="no"><para>...   </para>
</entry><entry thead="no"><para>...   </para>
</entry></row>
</table>
</para>
<para>Note that we have to pick different suffixes (<computeroutput>Action</computeroutput>, <computeroutput>ActionP</computeroutput>, <computeroutput>ActionP2</computeroutput>, and etc) for actions with different numbers of value parameters, or the action definitions cannot be overloaded on the number of them.</para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1NewMonoActions">
<title>Writing New Monomorphic Actions</title>
<para>While the <computeroutput>ACTION*</computeroutput> macros are very convenient, sometimes they are inappropriate. For example, despite the tricks shown in the previous recipes, they don&apos;t let you directly specify the types of the mock function arguments and the action parameters, which in general leads to unoptimized compiler error messages that can baffle unfamiliar users. They also don&apos;t allow overloading actions based on parameter types without jumping through some hoops.</para>
<para>An alternative to the <computeroutput>ACTION*</computeroutput> macros is to implement <computeroutput><ref refid="classtesting_1_1ActionInterface" kindref="compound">testing::ActionInterface</ref>&lt;F&gt;</computeroutput>, where <computeroutput>F</computeroutput> is the type of the mock function in which the action will be used. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>F&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">ActionInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~ActionInterface();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Performs<sp/>the<sp/>action.<sp/><sp/>Result<sp/>is<sp/>the<sp/>return<sp/>type<sp/>of<sp/>function<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>F,<sp/>and<sp/>ArgumentTuple<sp/>is<sp/>the<sp/>tuple<sp/>of<sp/>arguments<sp/>of<sp/>F.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>example,<sp/>if<sp/>F<sp/>is<sp/>int(bool,<sp/>const<sp/>string&amp;),<sp/>then<sp/>Result<sp/>would</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>be<sp/>int,<sp/>and<sp/>ArgumentTuple<sp/>would<sp/>be<sp/>std::tuple&lt;bool,<sp/>const<sp/>string&amp;&gt;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>Result<sp/>Perform(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ArgumentTuple&amp;<sp/>args)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Action;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ActionInterface;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakeAction;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>IncrementMethod(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">IncrementArgumentAction<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>ActionInterface&lt;IncrementMethod&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Perform(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::tuple&lt;int*&gt;&amp;<sp/>args)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>p<sp/>=<sp/>std::get&lt;0&gt;(args);<sp/><sp/></highlight><highlight class="comment">//<sp/>Grabs<sp/>the<sp/>first<sp/>argument.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*p++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Action&lt;IncrementMethod&gt;<sp/>IncrementArgument()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MakeAction(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>IncrementArgumentAction);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Baz(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(IncrementArgument());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Baz(&amp;n);<sp/><sp/></highlight><highlight class="comment">//<sp/>Should<sp/>return<sp/>5<sp/>and<sp/>change<sp/>n<sp/>to<sp/>6.</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1NewPolyActions">
<title>Writing New Polymorphic Actions</title>
<para>The previous recipe showed you how to define your own action. This is all good, except that you need to know the type of the function in which the action will be used. Sometimes that can be a problem. For example, if you want to use the action in functions with <emphasis>different</emphasis> types (e.g. like <computeroutput>Return()</computeroutput> and <computeroutput>SetArgPointee()</computeroutput>).</para>
<para>If an action can be used in several types of mock functions, we say it&apos;s <emphasis>polymorphic</emphasis>. The <computeroutput>MakePolymorphicAction()</computeroutput> function template makes it easy to define such an action:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">testing<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Impl&gt;</highlight></codeline>
<codeline><highlight class="normal">PolymorphicAction&lt;Impl&gt;<sp/>MakePolymorphicAction(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Impl&amp;<sp/>impl);</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>testing</highlight></codeline>
</programlisting></para>
<para>As an example, let&apos;s define an action that returns the second argument in the mock function&apos;s argument list. The first step is to define an implementation class:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">ReturnSecondArgumentAction<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Result,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ArgumentTuple&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Result<sp/>Perform(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ArgumentTuple&amp;<sp/>args)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>To<sp/>get<sp/>the<sp/>i-th<sp/>(0-based)<sp/>argument,<sp/>use<sp/>std::get(args).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::get&lt;1&gt;(args);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>This implementation class does <emphasis>not</emphasis> need to inherit from any particular class. What matters is that it must have a <computeroutput>Perform()</computeroutput> method template. This method template takes the mock function&apos;s arguments as a tuple in a <bold>single</bold> argument, and returns the result of the action. It can be either <computeroutput>const</computeroutput> or not, but must be invocable with exactly one template argument, which is the result type. In other words, you must be able to call <computeroutput>Perform&lt;R&gt;(args)</computeroutput> where <computeroutput>R</computeroutput> is the mock function&apos;s return type and <computeroutput>args</computeroutput> is its arguments in a tuple.</para>
<para>Next, we use <computeroutput>MakePolymorphicAction()</computeroutput> to turn an instance of the implementation class into the polymorphic action we need. It will be convenient to have a wrapper for this:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::MakePolymorphicAction;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::PolymorphicAction;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">PolymorphicAction&lt;ReturnSecondArgumentAction&gt;<sp/>ReturnSecondArgument()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MakePolymorphicAction(ReturnSecondArgumentAction());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Now, you can use this polymorphic action the same way you use the built-in ones:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MockFoo<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>DoThis,<sp/>(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>flag,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n),<sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(</highlight><highlight class="keywordtype">string</highlight><highlight class="normal">,<sp/>DoThat,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">override</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis).WillOnce(ReturnSecondArgument());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat).WillOnce(ReturnSecondArgument());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis(</highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>5);<sp/><sp/></highlight><highlight class="comment">//<sp/>Will<sp/>return<sp/>5.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat(1,<sp/></highlight><highlight class="stringliteral">&quot;Hi&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Bye&quot;</highlight><highlight class="normal">);<sp/><sp/></highlight><highlight class="comment">//<sp/>Will<sp/>return<sp/>&quot;Hi&quot;.</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md178">
<title>Teaching gMock How to Print Your Values</title>
<para>When an uninteresting or unexpected call occurs, gMock prints the argument values and the stack trace to help you debug. Assertion macros like <computeroutput>EXPECT_THAT</computeroutput> and <computeroutput>EXPECT_EQ</computeroutput> also print the values in question when the assertion fails. gMock and googletest do this using googletest&apos;s user-extensible value printer.</para>
<para>This printer knows how to print built-in C++ types, native arrays, STL containers, and any type that supports the <computeroutput>&lt;&lt;</computeroutput> operator. For other types, it prints the raw bytes in the value and hopes that you the user can figure it out. <ulink url="advanced.md#teaching-googletest-how-to-print-your-values">The GoogleTest advanced guide</ulink> explains how to extend the printer to do a better job at printing your particular type than to dump the bytes.</para>
</sect2>
</sect1>
<sect1 id="md_build__deps_googletest_src_docs_gmock_cook_book_1autotoc_md179">
<title>Useful Mocks Created Using gMock</title>
<sect2 id="md_build__deps_googletest_src_docs_gmock_cook_book_1MockFunction">
<title>Mock std::function</title>
<para><computeroutput>std::function</computeroutput> is a general function type introduced in C++11. It is a preferred way of passing callbacks to new interfaces. Functions are copyable, and are not usually passed around by pointer, which makes them tricky to mock. But fear not - <computeroutput>MockFunction</computeroutput> can help you with that.</para>
<para><computeroutput>MockFunction&lt;R(T1, ..., Tn)&gt;</computeroutput> has a mock method <computeroutput>Call()</computeroutput> with the signature:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">R<sp/>Call(T1,<sp/>...,<sp/>Tn);</highlight></codeline>
</programlisting></para>
<para>It also has a <computeroutput>AsStdFunction()</computeroutput> method, which creates a <computeroutput>std::function</computeroutput> proxy forwarding to Call:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">std::function&lt;R(T1,<sp/>...,<sp/>Tn)&gt;<sp/>AsStdFunction();</highlight></codeline>
</programlisting></para>
<para>To use <computeroutput>MockFunction</computeroutput>, first create <computeroutput>MockFunction</computeroutput> object and set up expectations on its <computeroutput>Call</computeroutput> method. Then pass proxy obtained from <computeroutput>AsStdFunction()</computeroutput> to the code you are testing. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">TEST(FooTest,<sp/>RunsCallbackWithBarArgument)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Create<sp/>a<sp/>mock<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFunction&lt;int(</highlight><highlight class="keywordtype">string</highlight><highlight class="normal">)&gt;<sp/>mock_function;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Set<sp/>expectations<sp/>on<sp/>Call()<sp/>method.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_function,<sp/>Call(</highlight><highlight class="stringliteral">&quot;bar&quot;</highlight><highlight class="normal">)).WillOnce(Return(1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Exercise<sp/>code<sp/>that<sp/>uses<sp/>std::function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(mock_function.AsStdFunction());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Foo&apos;s<sp/>signature<sp/>can<sp/>be<sp/>either<sp/>of:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>void<sp/>Foo(const<sp/>std::function&lt;int(string)&gt;&amp;<sp/>fun);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>void<sp/>Foo(std::function&lt;int(string)&gt;<sp/>fun);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>4.<sp/>All<sp/>expectations<sp/>will<sp/>be<sp/>verified<sp/>when<sp/>mock_function</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>goes<sp/>out<sp/>of<sp/>scope<sp/>and<sp/>is<sp/>destroyed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Remember that function objects created with <computeroutput>AsStdFunction()</computeroutput> are just forwarders. If you create multiple of them, they will share the same set of expectations.</para>
<para>Although <computeroutput>std::function</computeroutput> supports unlimited number of arguments, <computeroutput>MockFunction</computeroutput> implementation is limited to ten. If you ever hit that limit... well, your callback has bigger problems than being mockable. :-) </para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="build/_deps/googletest-src/docs/gmock_cook_book.md"/>
  </compounddef>
</doxygen>
