<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="gmock__cook__book_8md" kind="file" language="Markdown">
    <compoundname>gmock_cook_book.md</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#<sp/>gMock<sp/>Cookbook</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>find<sp/>recipes<sp/>for<sp/>using<sp/>gMock<sp/>here.<sp/>If<sp/>you<sp/>haven&apos;t<sp/>yet,<sp/>please<sp/>read</highlight></codeline>
<codeline><highlight class="normal">[the<sp/>dummy<sp/>guide](gmock_for_dummies.md)<sp/>first<sp/>to<sp/>make<sp/>sure<sp/>you<sp/>understand<sp/>the</highlight></codeline>
<codeline><highlight class="normal">basics.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.note}</highlight></codeline>
<codeline><highlight class="normal">**Note:**<sp/>gMock<sp/>lives<sp/>in<sp/>the<sp/>`testing`<sp/>name<sp/>space.<sp/>For<sp/>readability,<sp/>it<sp/>is</highlight></codeline>
<codeline><highlight class="normal">recommended<sp/>to<sp/>write<sp/>`using<sp/>::testing::Foo;`<sp/>once<sp/>in<sp/>your<sp/>file<sp/>before<sp/>using<sp/>the</highlight></codeline>
<codeline><highlight class="normal">name<sp/>`Foo`<sp/>defined<sp/>by<sp/>gMock.<sp/>We<sp/>omit<sp/>such<sp/>`using`<sp/>statements<sp/>in<sp/>this<sp/>section<sp/>for</highlight></codeline>
<codeline><highlight class="normal">brevity,<sp/>but<sp/>you<sp/>should<sp/>do<sp/>it<sp/>in<sp/>your<sp/>own<sp/>code.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Creating<sp/>Mock<sp/>Classes</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Mock<sp/>classes<sp/>are<sp/>defined<sp/>as<sp/>normal<sp/>classes,<sp/>using<sp/>the<sp/>`MOCK_METHOD`<sp/>macro<sp/>to</highlight></codeline>
<codeline><highlight class="normal">generate<sp/>mocked<sp/>methods.<sp/>The<sp/>macro<sp/>gets<sp/>3<sp/>or<sp/>4<sp/>parameters:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MyMock<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(ReturnType,<sp/>MethodName,<sp/>(Args...));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(ReturnType,<sp/>MethodName,<sp/>(Args...),<sp/>(Specs...));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>first<sp/>3<sp/>parameters<sp/>are<sp/>simply<sp/>the<sp/>method<sp/>declaration,<sp/>split<sp/>into<sp/>3<sp/>parts.</highlight></codeline>
<codeline><highlight class="normal">The<sp/>4th<sp/>parameter<sp/>accepts<sp/>a<sp/>closed<sp/>list<sp/>of<sp/>qualifiers,<sp/>which<sp/>affect<sp/>the</highlight></codeline>
<codeline><highlight class="normal">generated<sp/>method:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>**`const`**<sp/>-<sp/>Makes<sp/>the<sp/>mocked<sp/>method<sp/>a<sp/>`const`<sp/>method.<sp/>Required<sp/>if</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>overriding<sp/>a<sp/>`const`<sp/>method.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>**`override`**<sp/>-<sp/>Marks<sp/>the<sp/>method<sp/>with<sp/>`override`.<sp/>Recommended<sp/>if<sp/>overriding</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>a<sp/>`virtual`<sp/>method.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>**`noexcept`**<sp/>-<sp/>Marks<sp/>the<sp/>method<sp/>with<sp/>`noexcept`.<sp/>Required<sp/>if<sp/>overriding<sp/>a</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`noexcept`<sp/>method.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>**`Calltype(...)`**<sp/>-<sp/>Sets<sp/>the<sp/>call<sp/>type<sp/>for<sp/>the<sp/>method<sp/>(e.g.<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`STDMETHODCALLTYPE`),<sp/>useful<sp/>in<sp/>Windows.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>**`ref(...)`**<sp/>-<sp/>Marks<sp/>the<sp/>method<sp/>with<sp/>the<sp/>reference<sp/>qualification</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>specified.<sp/>Required<sp/>if<sp/>overriding<sp/>a<sp/>method<sp/>that<sp/>has<sp/>reference</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>qualifications.<sp/>Eg<sp/>`ref(&amp;)`<sp/>or<sp/>`ref(&amp;&amp;)`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Dealing<sp/>with<sp/>unprotected<sp/>commas</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Unprotected<sp/>commas,<sp/>i.e.<sp/>commas<sp/>which<sp/>are<sp/>not<sp/>surrounded<sp/>by<sp/>parentheses,<sp/>prevent</highlight></codeline>
<codeline><highlight class="normal">`MOCK_METHOD`<sp/>from<sp/>parsing<sp/>its<sp/>arguments<sp/>correctly:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.bad}</highlight></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(std::pair&lt;bool,<sp/>int&gt;,<sp/>GetPair,<sp/>());<sp/><sp/>//<sp/>Won&apos;t<sp/>compile!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>CheckMap,<sp/>(std::map&lt;int,<sp/>double&gt;,<sp/>bool));<sp/><sp/>//<sp/>Won&apos;t<sp/>compile!</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Solution<sp/>1<sp/>-<sp/>wrap<sp/>with<sp/>parentheses:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.good}</highlight></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD((std::pair&lt;bool,<sp/>int&gt;),<sp/>GetPair,<sp/>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>CheckMap,<sp/>((std::map&lt;int,<sp/>double&gt;),<sp/>bool));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>wrapping<sp/>a<sp/>return<sp/>or<sp/>argument<sp/>type<sp/>with<sp/>parentheses<sp/>is,<sp/>in<sp/>general,</highlight></codeline>
<codeline><highlight class="normal">invalid<sp/>C++.<sp/>`MOCK_METHOD`<sp/>removes<sp/>the<sp/>parentheses.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Solution<sp/>2<sp/>-<sp/>define<sp/>an<sp/>alias:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.good}</highlight></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>BoolAndInt<sp/>=<sp/>std::pair&lt;bool,<sp/>int&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(BoolAndInt,<sp/>GetPair,<sp/>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>MapIntDouble<sp/>=<sp/>std::map&lt;int,<sp/>double&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>CheckMap,<sp/>(MapIntDouble,<sp/>bool));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mocking<sp/>Private<sp/>or<sp/>Protected<sp/>Methods</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>must<sp/>always<sp/>put<sp/>a<sp/>mock<sp/>method<sp/>definition<sp/>(`MOCK_METHOD`)<sp/>in<sp/>a<sp/>`public:`</highlight></codeline>
<codeline><highlight class="normal">section<sp/>of<sp/>the<sp/>mock<sp/>class,<sp/>regardless<sp/>of<sp/>the<sp/>method<sp/>being<sp/>mocked<sp/>being<sp/>`public`,</highlight></codeline>
<codeline><highlight class="normal">`protected`,<sp/>or<sp/>`private`<sp/>in<sp/>the<sp/>base<sp/>class.<sp/>This<sp/>allows<sp/>`ON_CALL`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL`<sp/>to<sp/>reference<sp/>the<sp/>mock<sp/>function<sp/>from<sp/>outside<sp/>of<sp/>the<sp/>mock<sp/>class.</highlight></codeline>
<codeline><highlight class="normal">(Yes,<sp/>C++<sp/>allows<sp/>a<sp/>subclass<sp/>to<sp/>change<sp/>the<sp/>access<sp/>level<sp/>of<sp/>a<sp/>virtual<sp/>function<sp/>in</highlight></codeline>
<codeline><highlight class="normal">the<sp/>base<sp/>class.)<sp/>Example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>Transform(Gadget*<sp/>g)<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>Resume();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>GetTimeOut();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>Transform,<sp/>(Gadget*<sp/>g),<sp/>(override));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>following<sp/>must<sp/>be<sp/>in<sp/>the<sp/>public<sp/>section,<sp/>even<sp/>though<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>methods<sp/>are<sp/>protected<sp/>or<sp/>private<sp/>in<sp/>the<sp/>base<sp/>class.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Resume,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>GetTimeOut,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mocking<sp/>Overloaded<sp/>Methods</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>mock<sp/>overloaded<sp/>functions<sp/>as<sp/>usual.<sp/>No<sp/>special<sp/>attention<sp/>is<sp/>required:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Must<sp/>be<sp/>virtual<sp/>as<sp/>we&apos;ll<sp/>inherit<sp/>from<sp/>Foo.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Foo();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Overloaded<sp/>on<sp/>the<sp/>types<sp/>and/or<sp/>numbers<sp/>of<sp/>arguments.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>Add(Element<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>Add(int<sp/>times,<sp/>Element<sp/>x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Overloaded<sp/>on<sp/>the<sp/>const-ness<sp/>of<sp/>this<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>Bar&amp;<sp/>GetBar();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>const<sp/>Bar&amp;<sp/>GetBar()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>Add,<sp/>(Element<sp/>x),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>Add,<sp/>(int<sp/>times,<sp/>Element<sp/>x),<sp/>(override));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(const<sp/>Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(const,<sp/>override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.note}</highlight></codeline>
<codeline><highlight class="normal">**Note:**<sp/>if<sp/>you<sp/>don&apos;t<sp/>mock<sp/>all<sp/>versions<sp/>of<sp/>the<sp/>overloaded<sp/>method,<sp/>the<sp/>compiler</highlight></codeline>
<codeline><highlight class="normal">will<sp/>give<sp/>you<sp/>a<sp/>warning<sp/>about<sp/>some<sp/>methods<sp/>in<sp/>the<sp/>base<sp/>class<sp/>being<sp/>hidden.<sp/>To</highlight></codeline>
<codeline><highlight class="normal">fix<sp/>that,<sp/>use<sp/>`using`<sp/>to<sp/>bring<sp/>them<sp/>in<sp/>scope:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>Foo::Add;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>Add,<sp/>(Element<sp/>x),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>want<sp/>to<sp/>mock<sp/>int<sp/>Add(int<sp/>times,<sp/>Element<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mocking<sp/>Class<sp/>Templates</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>mock<sp/>class<sp/>templates<sp/>just<sp/>like<sp/>any<sp/>class.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Elem&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>StackInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Must<sp/>be<sp/>virtual<sp/>as<sp/>we&apos;ll<sp/>inherit<sp/>from<sp/>StackInterface.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~StackInterface();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>GetSize()<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>Push(const<sp/>Elem&amp;<sp/>x)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Elem&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockStack<sp/>:<sp/>public<sp/>StackInterface&lt;Elem&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>GetSize,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Push,<sp/>(const<sp/>Elem&amp;<sp/>x),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mocking<sp/>Non-virtual<sp/>Methods<sp/>{#MockingNonVirtualMethods}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>can<sp/>mock<sp/>non-virtual<sp/>functions<sp/>to<sp/>be<sp/>used<sp/>in<sp/>Hi-perf<sp/>dependency<sp/>injection.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>this<sp/>case,<sp/>instead<sp/>of<sp/>sharing<sp/>a<sp/>common<sp/>base<sp/>class<sp/>with<sp/>the<sp/>real<sp/>class,<sp/>your</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>class<sp/>will<sp/>be<sp/>*unrelated*<sp/>to<sp/>the<sp/>real<sp/>class,<sp/>but<sp/>contain<sp/>methods<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">same<sp/>signatures.<sp/>The<sp/>syntax<sp/>for<sp/>mocking<sp/>non-virtual<sp/>methods<sp/>is<sp/>the<sp/>*same*<sp/>as</highlight></codeline>
<codeline><highlight class="normal">mocking<sp/>virtual<sp/>methods<sp/>(just<sp/>don&apos;t<sp/>add<sp/>`override`):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>A<sp/>simple<sp/>packet<sp/>stream<sp/>class.<sp/><sp/>None<sp/>of<sp/>its<sp/>members<sp/>is<sp/>virtual.</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ConcretePacketStream<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>AppendPacket(Packet*<sp/>new_packet);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Packet*<sp/>GetPacket(size_t<sp/>packet_number)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>NumberOfPackets()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>A<sp/>mock<sp/>packet<sp/>stream<sp/>class.<sp/><sp/>It<sp/>inherits<sp/>from<sp/>no<sp/>other,<sp/>but<sp/>defines</highlight></codeline>
<codeline><highlight class="normal">//<sp/>GetPacket()<sp/>and<sp/>NumberOfPackets().</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockPacketStream<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(const<sp/>Packet*,<sp/>GetPacket,<sp/>(size_t<sp/>packet_number),<sp/>(const));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(size_t,<sp/>NumberOfPackets,<sp/>(),<sp/>(const));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>mock<sp/>class<sp/>doesn&apos;t<sp/>define<sp/>`AppendPacket()`,<sp/>unlike<sp/>the<sp/>real<sp/>class.</highlight></codeline>
<codeline><highlight class="normal">That&apos;s<sp/>fine<sp/>as<sp/>long<sp/>as<sp/>the<sp/>test<sp/>doesn&apos;t<sp/>need<sp/>to<sp/>call<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Next,<sp/>you<sp/>need<sp/>a<sp/>way<sp/>to<sp/>say<sp/>that<sp/>you<sp/>want<sp/>to<sp/>use<sp/>`ConcretePacketStream`<sp/>in</highlight></codeline>
<codeline><highlight class="normal">production<sp/>code,<sp/>and<sp/>use<sp/>`MockPacketStream`<sp/>in<sp/>tests.<sp/>Since<sp/>the<sp/>functions<sp/>are</highlight></codeline>
<codeline><highlight class="normal">not<sp/>virtual<sp/>and<sp/>the<sp/>two<sp/>classes<sp/>are<sp/>unrelated,<sp/>you<sp/>must<sp/>specify<sp/>your<sp/>choice<sp/>at</highlight></codeline>
<codeline><highlight class="normal">*compile<sp/>time*<sp/>(as<sp/>opposed<sp/>to<sp/>run<sp/>time).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">One<sp/>way<sp/>to<sp/>do<sp/>it<sp/>is<sp/>to<sp/>templatize<sp/>your<sp/>code<sp/>that<sp/>needs<sp/>to<sp/>use<sp/>a<sp/>packet<sp/>stream.</highlight></codeline>
<codeline><highlight class="normal">More<sp/>specifically,<sp/>you<sp/>will<sp/>give<sp/>your<sp/>code<sp/>a<sp/>template<sp/>type<sp/>argument<sp/>for<sp/>the<sp/>type</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>packet<sp/>stream.<sp/>In<sp/>production,<sp/>you<sp/>will<sp/>instantiate<sp/>your<sp/>template<sp/>with</highlight></codeline>
<codeline><highlight class="normal">`ConcretePacketStream`<sp/>as<sp/>the<sp/>type<sp/>argument.<sp/>In<sp/>tests,<sp/>you<sp/>will<sp/>instantiate<sp/>the</highlight></codeline>
<codeline><highlight class="normal">same<sp/>template<sp/>with<sp/>`MockPacketStream`.<sp/>For<sp/>example,<sp/>you<sp/>may<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>PacketStream&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>CreateConnection(PacketStream*<sp/>stream)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>PacketStream&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>PacketReader<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>ReadPackets(PacketStream*<sp/>stream,<sp/>size_t<sp/>packet_num);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Then<sp/>you<sp/>can<sp/>use<sp/>`CreateConnection&lt;ConcretePacketStream&gt;()`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`PacketReader&lt;ConcretePacketStream&gt;`<sp/>in<sp/>production<sp/>code,<sp/>and<sp/>use</highlight></codeline>
<codeline><highlight class="normal">`CreateConnection&lt;MockPacketStream&gt;()`<sp/>and<sp/>`PacketReader&lt;MockPacketStream&gt;`<sp/>in</highlight></codeline>
<codeline><highlight class="normal">tests.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockPacketStream<sp/>mock_stream;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_stream,<sp/>...)...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>..<sp/>set<sp/>more<sp/>expectations<sp/>on<sp/>mock_stream<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PacketReader&lt;MockPacketStream&gt;<sp/>reader(&amp;mock_stream);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>exercise<sp/>reader<sp/>...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mocking<sp/>Free<sp/>Functions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It<sp/>is<sp/>not<sp/>possible<sp/>to<sp/>directly<sp/>mock<sp/>a<sp/>free<sp/>function<sp/>(i.e.<sp/>a<sp/>C-style<sp/>function<sp/>or</highlight></codeline>
<codeline><highlight class="normal">a<sp/>static<sp/>method).<sp/>If<sp/>you<sp/>need<sp/>to,<sp/>you<sp/>can<sp/>rewrite<sp/>your<sp/>code<sp/>to<sp/>use<sp/>an<sp/>interface</highlight></codeline>
<codeline><highlight class="normal">(abstract<sp/>class).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Instead<sp/>of<sp/>calling<sp/>a<sp/>free<sp/>function<sp/>(say,<sp/>`OpenFile`)<sp/>directly,<sp/>introduce<sp/>an</highlight></codeline>
<codeline><highlight class="normal">interface<sp/>for<sp/>it<sp/>and<sp/>have<sp/>a<sp/>concrete<sp/>subclass<sp/>that<sp/>calls<sp/>the<sp/>free<sp/>function:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>FileInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>Open(const<sp/>char*<sp/>path,<sp/>const<sp/>char*<sp/>mode)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>File<sp/>:<sp/>public<sp/>FileInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>Open(const<sp/>char*<sp/>path,<sp/>const<sp/>char*<sp/>mode)<sp/>override<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>return<sp/>OpenFile(path,<sp/>mode);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Your<sp/>code<sp/>should<sp/>talk<sp/>to<sp/>`FileInterface`<sp/>to<sp/>open<sp/>a<sp/>file.<sp/>Now<sp/>it&apos;s<sp/>easy<sp/>to<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">out<sp/>the<sp/>function.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>may<sp/>seem<sp/>like<sp/>a<sp/>lot<sp/>of<sp/>hassle,<sp/>but<sp/>in<sp/>practice<sp/>you<sp/>often<sp/>have<sp/>multiple</highlight></codeline>
<codeline><highlight class="normal">related<sp/>functions<sp/>that<sp/>you<sp/>can<sp/>put<sp/>in<sp/>the<sp/>same<sp/>interface,<sp/>so<sp/>the<sp/>per-function</highlight></codeline>
<codeline><highlight class="normal">syntactic<sp/>overhead<sp/>will<sp/>be<sp/>much<sp/>lower.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>concerned<sp/>about<sp/>the<sp/>performance<sp/>overhead<sp/>incurred<sp/>by<sp/>virtual</highlight></codeline>
<codeline><highlight class="normal">functions,<sp/>and<sp/>profiling<sp/>confirms<sp/>your<sp/>concern,<sp/>you<sp/>can<sp/>combine<sp/>this<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">recipe<sp/>for<sp/>[mocking<sp/>non-virtual<sp/>methods](#MockingNonVirtualMethods).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Alternatively,<sp/>instead<sp/>of<sp/>introducing<sp/>a<sp/>new<sp/>interface,<sp/>you<sp/>can<sp/>rewrite<sp/>your<sp/>code</highlight></codeline>
<codeline><highlight class="normal">to<sp/>accept<sp/>a<sp/>std::function<sp/>instead<sp/>of<sp/>the<sp/>free<sp/>function,<sp/>and<sp/>then<sp/>use</highlight></codeline>
<codeline><highlight class="normal">[MockFunction](#MockFunction)<sp/>to<sp/>mock<sp/>the<sp/>std::function.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Old-Style<sp/>`MOCK_METHODn`<sp/>Macros</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Before<sp/>the<sp/>generic<sp/>`MOCK_METHOD`<sp/>macro</highlight></codeline>
<codeline><highlight class="normal">[was<sp/>introduced<sp/>in<sp/>2018](https://github.com/google/googletest/commit/c5f08bf91944ce1b19bcf414fa1760e69d20afc2),</highlight></codeline>
<codeline><highlight class="normal">mocks<sp/>where<sp/>created<sp/>using<sp/>a<sp/>family<sp/>of<sp/>macros<sp/>collectively<sp/>called<sp/>`MOCK_METHODn`.</highlight></codeline>
<codeline><highlight class="normal">These<sp/>macros<sp/>are<sp/>still<sp/>supported,<sp/>though<sp/>migration<sp/>to<sp/>the<sp/>new<sp/>`MOCK_METHOD`<sp/>is</highlight></codeline>
<codeline><highlight class="normal">recommended.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>macros<sp/>in<sp/>the<sp/>`MOCK_METHODn`<sp/>family<sp/>differ<sp/>from<sp/>`MOCK_METHOD`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>The<sp/>general<sp/>structure<sp/>is<sp/>`MOCK_METHODn(MethodName,<sp/>ReturnType(Args))`,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>instead<sp/>of<sp/>`MOCK_METHOD(ReturnType,<sp/>MethodName,<sp/>(Args))`.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>The<sp/>number<sp/>`n`<sp/>must<sp/>equal<sp/>the<sp/>number<sp/>of<sp/>arguments.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>When<sp/>mocking<sp/>a<sp/>const<sp/>method,<sp/>one<sp/>must<sp/>use<sp/>`MOCK_CONST_METHODn`.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>When<sp/>mocking<sp/>a<sp/>class<sp/>template,<sp/>the<sp/>macro<sp/>name<sp/>must<sp/>be<sp/>suffixed<sp/>with<sp/>`_T`.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>In<sp/>order<sp/>to<sp/>specify<sp/>the<sp/>call<sp/>type,<sp/>the<sp/>macro<sp/>name<sp/>must<sp/>be<sp/>suffixed<sp/>with</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`_WITH_CALLTYPE`,<sp/>and<sp/>the<sp/>call<sp/>type<sp/>is<sp/>the<sp/>first<sp/>macro<sp/>argument.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Old<sp/>macros<sp/>and<sp/>their<sp/>new<sp/>equivalents:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">&lt;table&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;&lt;th<sp/>colspan=2&gt;Simple&lt;/th&gt;&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;Old&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD1(Foo,<sp/>bool(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;New&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD(bool,<sp/>Foo,<sp/>(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;&lt;th<sp/>colspan=2&gt;Const<sp/>Method&lt;/th&gt;&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;Old&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_CONST_METHOD1(Foo,<sp/>bool(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;New&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD(bool,<sp/>Foo,<sp/>(int),<sp/>(const))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;&lt;th<sp/>colspan=2&gt;Method<sp/>in<sp/>a<sp/>Class<sp/>Template&lt;/th&gt;&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;Old&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD1_T(Foo,<sp/>bool(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;New&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD(bool,<sp/>Foo,<sp/>(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;&lt;th<sp/>colspan=2&gt;Const<sp/>Method<sp/>in<sp/>a<sp/>Class<sp/>Template&lt;/th&gt;&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;Old&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_CONST_METHOD1_T(Foo,<sp/>bool(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;New&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD(bool,<sp/>Foo,<sp/>(int),<sp/>(const))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;&lt;th<sp/>colspan=2&gt;Method<sp/>with<sp/>Call<sp/>Type&lt;/th&gt;&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;Old&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE,<sp/>Foo,<sp/>bool(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;New&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD(bool,<sp/>Foo,<sp/>(int),<sp/>(Calltype(STDMETHODCALLTYPE)))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;&lt;th<sp/>colspan=2&gt;Const<sp/>Method<sp/>with<sp/>Call<sp/>Type&lt;/th&gt;&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;Old&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_CONST_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE,<sp/>Foo,<sp/>bool(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;New&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD(bool,<sp/>Foo,<sp/>(int),<sp/>(const,<sp/>Calltype(STDMETHODCALLTYPE)))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;&lt;th<sp/>colspan=2&gt;Method<sp/>with<sp/>Call<sp/>Type<sp/>in<sp/>a<sp/>Class<sp/>Template&lt;/th&gt;&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;Old&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE,<sp/>Foo,<sp/>bool(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;New&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD(bool,<sp/>Foo,<sp/>(int),<sp/>(Calltype(STDMETHODCALLTYPE)))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;&lt;th<sp/>colspan=2&gt;Const<sp/>Method<sp/>with<sp/>Call<sp/>Type<sp/>in<sp/>a<sp/>Class<sp/>Template&lt;/th&gt;&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;Old&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_CONST_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE,<sp/>Foo,<sp/>bool(int))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;tr&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;New&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;td&gt;&lt;code&gt;MOCK_METHOD(bool,<sp/>Foo,<sp/>(int),<sp/>(const,<sp/>Calltype(STDMETHODCALLTYPE)))&lt;/code&gt;&lt;/td&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;/tr&gt;</highlight></codeline>
<codeline><highlight class="normal">&lt;/table&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>The<sp/>Nice,<sp/>the<sp/>Strict,<sp/>and<sp/>the<sp/>Naggy<sp/>{#NiceStrictNaggy}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>mock<sp/>method<sp/>has<sp/>no<sp/>`EXPECT_CALL`<sp/>spec<sp/>but<sp/>is<sp/>called,<sp/>we<sp/>say<sp/>that<sp/>it&apos;s<sp/>an</highlight></codeline>
<codeline><highlight class="normal">&quot;uninteresting<sp/>call&quot;,<sp/>and<sp/>the<sp/>default<sp/>action<sp/>(which<sp/>can<sp/>be<sp/>specified<sp/>using</highlight></codeline>
<codeline><highlight class="normal">`ON_CALL()`)<sp/>of<sp/>the<sp/>method<sp/>will<sp/>be<sp/>taken.<sp/>Currently,<sp/>an<sp/>uninteresting<sp/>call<sp/>will</highlight></codeline>
<codeline><highlight class="normal">also<sp/>by<sp/>default<sp/>cause<sp/>gMock<sp/>to<sp/>print<sp/>a<sp/>warning.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">However,<sp/>sometimes<sp/>you<sp/>may<sp/>want<sp/>to<sp/>ignore<sp/>these<sp/>uninteresting<sp/>calls,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">sometimes<sp/>you<sp/>may<sp/>want<sp/>to<sp/>treat<sp/>them<sp/>as<sp/>errors.<sp/>gMock<sp/>lets<sp/>you<sp/>make<sp/>the<sp/>decision</highlight></codeline>
<codeline><highlight class="normal">on<sp/>a<sp/>per-mock-object<sp/>basis.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Suppose<sp/>your<sp/>test<sp/>uses<sp/>a<sp/>mock<sp/>class<sp/>`MockFoo`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>method<sp/>of<sp/>`mock_foo`<sp/>other<sp/>than<sp/>`DoThis()`<sp/>is<sp/>called,<sp/>you<sp/>will<sp/>get<sp/>a</highlight></codeline>
<codeline><highlight class="normal">warning.<sp/>However,<sp/>if<sp/>you<sp/>rewrite<sp/>your<sp/>test<sp/>to<sp/>use<sp/>`NiceMock&lt;MockFoo&gt;`<sp/>instead,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>can<sp/>suppress<sp/>the<sp/>warning:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NiceMock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockFoo&gt;<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`NiceMock&lt;MockFoo&gt;`<sp/>is<sp/>a<sp/>subclass<sp/>of<sp/>`MockFoo`,<sp/>so<sp/>it<sp/>can<sp/>be<sp/>used<sp/>wherever</highlight></codeline>
<codeline><highlight class="normal">`MockFoo`<sp/>is<sp/>accepted.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It<sp/>also<sp/>works<sp/>if<sp/>`MockFoo`&apos;s<sp/>constructor<sp/>takes<sp/>some<sp/>arguments,<sp/>as</highlight></codeline>
<codeline><highlight class="normal">`NiceMock&lt;MockFoo&gt;`<sp/>&quot;inherits&quot;<sp/>`MockFoo`&apos;s<sp/>constructors:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NiceMock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockFoo&gt;<sp/>mock_foo(5,<sp/>&quot;hi&quot;);<sp/><sp/>//<sp/>Calls<sp/>MockFoo(5,<sp/>&quot;hi&quot;).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>usage<sp/>of<sp/>`StrictMock`<sp/>is<sp/>similar,<sp/>except<sp/>that<sp/>it<sp/>makes<sp/>all<sp/>uninteresting</highlight></codeline>
<codeline><highlight class="normal">calls<sp/>failures:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::StrictMock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>StrictMock&lt;MockFoo&gt;<sp/>mock_foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>DoThis());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>code<sp/>that<sp/>uses<sp/>mock_foo<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>test<sp/>will<sp/>fail<sp/>if<sp/>a<sp/>method<sp/>of<sp/>mock_foo<sp/>other<sp/>than<sp/>DoThis()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>is<sp/>called.</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.note}</highlight></codeline>
<codeline><highlight class="normal">NOTE:<sp/>`NiceMock`<sp/>and<sp/>`StrictMock`<sp/>only<sp/>affects<sp/>*uninteresting*<sp/>calls<sp/>(calls<sp/>of</highlight></codeline>
<codeline><highlight class="normal">*methods*<sp/>with<sp/>no<sp/>expectations);<sp/>they<sp/>do<sp/>not<sp/>affect<sp/>*unexpected*<sp/>calls<sp/>(calls<sp/>of</highlight></codeline>
<codeline><highlight class="normal">methods<sp/>with<sp/>expectations,<sp/>but<sp/>they<sp/>don&apos;t<sp/>match).<sp/>See</highlight></codeline>
<codeline><highlight class="normal">[Understanding<sp/>Uninteresting<sp/>vs<sp/>Unexpected<sp/>Calls](#uninteresting-vs-unexpected).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">There<sp/>are<sp/>some<sp/>caveats<sp/>though<sp/>(sadly<sp/>they<sp/>are<sp/>side<sp/>effects<sp/>of<sp/>C++&apos;s</highlight></codeline>
<codeline><highlight class="normal">limitations):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/><sp/>`NiceMock&lt;MockFoo&gt;`<sp/>and<sp/>`StrictMock&lt;MockFoo&gt;`<sp/>only<sp/>work<sp/>for<sp/>mock<sp/>methods</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>defined<sp/>using<sp/>the<sp/>`MOCK_METHOD`<sp/>macro<sp/>**directly**<sp/>in<sp/>the<sp/>`MockFoo`<sp/>class.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>If<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>defined<sp/>in<sp/>a<sp/>**base<sp/>class**<sp/>of<sp/>`MockFoo`,<sp/>the<sp/>&quot;nice&quot;<sp/>or</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;strict&quot;<sp/>modifier<sp/>may<sp/>not<sp/>affect<sp/>it,<sp/>depending<sp/>on<sp/>the<sp/>compiler.<sp/>In</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>particular,<sp/>nesting<sp/>`NiceMock`<sp/>and<sp/>`StrictMock`<sp/>(e.g.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`NiceMock&lt;StrictMock&lt;MockFoo&gt;<sp/>&gt;`)<sp/>is<sp/>**not**<sp/>supported.</highlight></codeline>
<codeline><highlight class="normal">2.<sp/><sp/>`NiceMock&lt;MockFoo&gt;`<sp/>and<sp/>`StrictMock&lt;MockFoo&gt;`<sp/>may<sp/>not<sp/>work<sp/>correctly<sp/>if<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>destructor<sp/>of<sp/>`MockFoo`<sp/>is<sp/>not<sp/>virtual.<sp/>We<sp/>would<sp/>like<sp/>to<sp/>fix<sp/>this,<sp/>but<sp/>it</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>requires<sp/>cleaning<sp/>up<sp/>existing<sp/>tests.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Finally,<sp/>you<sp/>should<sp/>be<sp/>**very<sp/>cautious**<sp/>about<sp/>when<sp/>to<sp/>use<sp/>naggy<sp/>or<sp/>strict</highlight></codeline>
<codeline><highlight class="normal">mocks,<sp/>as<sp/>they<sp/>tend<sp/>to<sp/>make<sp/>tests<sp/>more<sp/>brittle<sp/>and<sp/>harder<sp/>to<sp/>maintain.<sp/>When<sp/>you</highlight></codeline>
<codeline><highlight class="normal">refactor<sp/>your<sp/>code<sp/>without<sp/>changing<sp/>its<sp/>externally<sp/>visible<sp/>behavior,<sp/>ideally<sp/>you</highlight></codeline>
<codeline><highlight class="normal">shouldn&apos;t<sp/>need<sp/>to<sp/>update<sp/>any<sp/>tests.<sp/>If<sp/>your<sp/>code<sp/>interacts<sp/>with<sp/>a<sp/>naggy<sp/>mock,</highlight></codeline>
<codeline><highlight class="normal">however,<sp/>you<sp/>may<sp/>start<sp/>to<sp/>get<sp/>spammed<sp/>with<sp/>warnings<sp/>as<sp/>the<sp/>result<sp/>of<sp/>your</highlight></codeline>
<codeline><highlight class="normal">change.<sp/>Worse,<sp/>if<sp/>your<sp/>code<sp/>interacts<sp/>with<sp/>a<sp/>strict<sp/>mock,<sp/>your<sp/>tests<sp/>may<sp/>start</highlight></codeline>
<codeline><highlight class="normal">to<sp/>fail<sp/>and<sp/>you&apos;ll<sp/>be<sp/>forced<sp/>to<sp/>fix<sp/>them.<sp/>Our<sp/>general<sp/>recommendation<sp/>is<sp/>to<sp/>use</highlight></codeline>
<codeline><highlight class="normal">nice<sp/>mocks<sp/>(not<sp/>yet<sp/>the<sp/>default)<sp/>most<sp/>of<sp/>the<sp/>time,<sp/>use<sp/>naggy<sp/>mocks<sp/>(the<sp/>current</highlight></codeline>
<codeline><highlight class="normal">default)<sp/>when<sp/>developing<sp/>or<sp/>debugging<sp/>tests,<sp/>and<sp/>use<sp/>strict<sp/>mocks<sp/>only<sp/>as<sp/>the</highlight></codeline>
<codeline><highlight class="normal">last<sp/>resort.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Simplifying<sp/>the<sp/>Interface<sp/>without<sp/>Breaking<sp/>Existing<sp/>Code<sp/>{#SimplerInterfaces}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>a<sp/>method<sp/>has<sp/>a<sp/>long<sp/>list<sp/>of<sp/>arguments<sp/>that<sp/>is<sp/>mostly<sp/>uninteresting.</highlight></codeline>
<codeline><highlight class="normal">For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>LogSink<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>send(LogSeverity<sp/>severity,<sp/>const<sp/>char*<sp/>full_filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>char*<sp/>base_filename,<sp/>int<sp/>line,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>struct<sp/>tm*<sp/>tm_time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>char*<sp/>message,<sp/>size_t<sp/>message_len)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>method&apos;s<sp/>argument<sp/>list<sp/>is<sp/>lengthy<sp/>and<sp/>hard<sp/>to<sp/>work<sp/>with<sp/>(the<sp/>`message`</highlight></codeline>
<codeline><highlight class="normal">argument<sp/>is<sp/>not<sp/>even<sp/>0-terminated).<sp/>If<sp/>we<sp/>mock<sp/>it<sp/>as<sp/>is,<sp/>using<sp/>the<sp/>mock<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">awkward.<sp/>If,<sp/>however,<sp/>we<sp/>try<sp/>to<sp/>simplify<sp/>this<sp/>interface,<sp/>we&apos;ll<sp/>need<sp/>to<sp/>fix<sp/>all</highlight></codeline>
<codeline><highlight class="normal">clients<sp/>depending<sp/>on<sp/>it,<sp/>which<sp/>is<sp/>often<sp/>infeasible.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>trick<sp/>is<sp/>to<sp/>redispatch<sp/>the<sp/>method<sp/>in<sp/>the<sp/>mock<sp/>class:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ScopedMockLog<sp/>:<sp/>public<sp/>LogSink<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>send(LogSeverity<sp/>severity,<sp/>const<sp/>char*<sp/>full_filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>char*<sp/>base_filename,<sp/>int<sp/>line,<sp/>const<sp/>tm*<sp/>tm_time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>char*<sp/>message,<sp/>size_t<sp/>message_len)<sp/>override<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>We<sp/>are<sp/>only<sp/>interested<sp/>in<sp/>the<sp/>log<sp/>severity,<sp/>full<sp/>file<sp/>name,<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>log<sp/>message.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Log(severity,<sp/>full_filename,<sp/>std::string(message,<sp/>message_len));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Implements<sp/>the<sp/>mock<sp/>method:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/>void<sp/>Log(LogSeverity<sp/>severity,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>string&amp;<sp/>file_path,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>string&amp;<sp/>message);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Log,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(LogSeverity<sp/>severity,<sp/>const<sp/>string&amp;<sp/>file_path,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>string&amp;<sp/>message));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">By<sp/>defining<sp/>a<sp/>new<sp/>mock<sp/>method<sp/>with<sp/>a<sp/>trimmed<sp/>argument<sp/>list,<sp/>we<sp/>make<sp/>the<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">class<sp/>more<sp/>user-friendly.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>technique<sp/>may<sp/>also<sp/>be<sp/>applied<sp/>to<sp/>make<sp/>overloaded<sp/>methods<sp/>more<sp/>amenable<sp/>to</highlight></codeline>
<codeline><highlight class="normal">mocking.<sp/>For<sp/>example,<sp/>when<sp/>overloads<sp/>have<sp/>been<sp/>used<sp/>to<sp/>implement<sp/>default</highlight></codeline>
<codeline><highlight class="normal">arguments:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockTurtleFactory<sp/>:<sp/>public<sp/>TurtleFactory<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Turtle*<sp/>MakeTurtle(int<sp/>length,<sp/>int<sp/>weight)<sp/>override<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Turtle*<sp/>MakeTurtle(int<sp/>length,<sp/>int<sp/>weight,<sp/>int<sp/>speed)<sp/>override<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>the<sp/>above<sp/>methods<sp/>delegate<sp/>to<sp/>this<sp/>one:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Turtle*,<sp/>DoMakeTurtle,<sp/>());</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>allows<sp/>tests<sp/>that<sp/>don&apos;t<sp/>care<sp/>which<sp/>overload<sp/>was<sp/>invoked<sp/>to<sp/>avoid<sp/>specifying</highlight></codeline>
<codeline><highlight class="normal">argument<sp/>matchers:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ON_CALL(factory,<sp/>DoMakeTurtle)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.WillByDefault(Return(MakeMockTurtle()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Alternative<sp/>to<sp/>Mocking<sp/>Concrete<sp/>Classes</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Often<sp/>you<sp/>may<sp/>find<sp/>yourself<sp/>using<sp/>classes<sp/>that<sp/>don&apos;t<sp/>implement<sp/>interfaces.<sp/>In</highlight></codeline>
<codeline><highlight class="normal">order<sp/>to<sp/>test<sp/>your<sp/>code<sp/>that<sp/>uses<sp/>such<sp/>a<sp/>class<sp/>(let&apos;s<sp/>call<sp/>it<sp/>`Concrete`),<sp/>you</highlight></codeline>
<codeline><highlight class="normal">may<sp/>be<sp/>tempted<sp/>to<sp/>make<sp/>the<sp/>methods<sp/>of<sp/>`Concrete`<sp/>virtual<sp/>and<sp/>then<sp/>mock<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Try<sp/>not<sp/>to<sp/>do<sp/>that.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Making<sp/>a<sp/>non-virtual<sp/>function<sp/>virtual<sp/>is<sp/>a<sp/>big<sp/>decision.<sp/>It<sp/>creates<sp/>an<sp/>extension</highlight></codeline>
<codeline><highlight class="normal">point<sp/>where<sp/>subclasses<sp/>can<sp/>tweak<sp/>your<sp/>class&apos;<sp/>behavior.<sp/>This<sp/>weakens<sp/>your<sp/>control</highlight></codeline>
<codeline><highlight class="normal">on<sp/>the<sp/>class<sp/>because<sp/>now<sp/>it&apos;s<sp/>harder<sp/>to<sp/>maintain<sp/>the<sp/>class<sp/>invariants.<sp/>You</highlight></codeline>
<codeline><highlight class="normal">should<sp/>make<sp/>a<sp/>function<sp/>virtual<sp/>only<sp/>when<sp/>there<sp/>is<sp/>a<sp/>valid<sp/>reason<sp/>for<sp/>a<sp/>subclass</highlight></codeline>
<codeline><highlight class="normal">to<sp/>override<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Mocking<sp/>concrete<sp/>classes<sp/>directly<sp/>is<sp/>problematic<sp/>as<sp/>it<sp/>creates<sp/>a<sp/>tight<sp/>coupling</highlight></codeline>
<codeline><highlight class="normal">between<sp/>the<sp/>class<sp/>and<sp/>the<sp/>tests<sp/>-<sp/>any<sp/>small<sp/>change<sp/>in<sp/>the<sp/>class<sp/>may<sp/>invalidate</highlight></codeline>
<codeline><highlight class="normal">your<sp/>tests<sp/>and<sp/>make<sp/>test<sp/>maintenance<sp/>a<sp/>pain.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>avoid<sp/>such<sp/>problems,<sp/>many<sp/>programmers<sp/>have<sp/>been<sp/>practicing<sp/>&quot;coding<sp/>to</highlight></codeline>
<codeline><highlight class="normal">interfaces&quot;:<sp/>instead<sp/>of<sp/>talking<sp/>to<sp/>the<sp/>`Concrete`<sp/>class,<sp/>your<sp/>code<sp/>would<sp/>define</highlight></codeline>
<codeline><highlight class="normal">an<sp/>interface<sp/>and<sp/>talk<sp/>to<sp/>it.<sp/>Then<sp/>you<sp/>implement<sp/>that<sp/>interface<sp/>as<sp/>an<sp/>adaptor<sp/>on</highlight></codeline>
<codeline><highlight class="normal">top<sp/>of<sp/>`Concrete`.<sp/>In<sp/>tests,<sp/>you<sp/>can<sp/>easily<sp/>mock<sp/>that<sp/>interface<sp/>to<sp/>observe<sp/>how</highlight></codeline>
<codeline><highlight class="normal">your<sp/>code<sp/>is<sp/>doing.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>technique<sp/>incurs<sp/>some<sp/>overhead:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>You<sp/>pay<sp/>the<sp/>cost<sp/>of<sp/>virtual<sp/>function<sp/>calls<sp/>(usually<sp/>not<sp/>a<sp/>problem).</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>There<sp/>is<sp/>more<sp/>abstraction<sp/>for<sp/>the<sp/>programmers<sp/>to<sp/>learn.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">However,<sp/>it<sp/>can<sp/>also<sp/>bring<sp/>significant<sp/>benefits<sp/>in<sp/>addition<sp/>to<sp/>better</highlight></codeline>
<codeline><highlight class="normal">testability:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>`Concrete`&apos;s<sp/>API<sp/>may<sp/>not<sp/>fit<sp/>your<sp/>problem<sp/>domain<sp/>very<sp/>well,<sp/>as<sp/>you<sp/>may<sp/>not</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>be<sp/>the<sp/>only<sp/>client<sp/>it<sp/>tries<sp/>to<sp/>serve.<sp/>By<sp/>designing<sp/>your<sp/>own<sp/>interface,<sp/>you</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>have<sp/>a<sp/>chance<sp/>to<sp/>tailor<sp/>it<sp/>to<sp/>your<sp/>need<sp/>-<sp/>you<sp/>may<sp/>add<sp/>higher-level</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>functionalities,<sp/>rename<sp/>stuff,<sp/>etc<sp/>instead<sp/>of<sp/>just<sp/>trimming<sp/>the<sp/>class.<sp/>This</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>allows<sp/>you<sp/>to<sp/>write<sp/>your<sp/>code<sp/>(user<sp/>of<sp/>the<sp/>interface)<sp/>in<sp/>a<sp/>more<sp/>natural<sp/>way,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>which<sp/>means<sp/>it<sp/>will<sp/>be<sp/>more<sp/>readable,<sp/>more<sp/>maintainable,<sp/>and<sp/>you&apos;ll<sp/>be<sp/>more</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>productive.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>If<sp/>`Concrete`&apos;s<sp/>implementation<sp/>ever<sp/>has<sp/>to<sp/>change,<sp/>you<sp/>don&apos;t<sp/>have<sp/>to<sp/>rewrite</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>everywhere<sp/>it<sp/>is<sp/>used.<sp/>Instead,<sp/>you<sp/>can<sp/>absorb<sp/>the<sp/>change<sp/>in<sp/>your</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>implementation<sp/>of<sp/>the<sp/>interface,<sp/>and<sp/>your<sp/>other<sp/>code<sp/>and<sp/>tests<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insulated<sp/>from<sp/>this<sp/>change.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Some<sp/>people<sp/>worry<sp/>that<sp/>if<sp/>everyone<sp/>is<sp/>practicing<sp/>this<sp/>technique,<sp/>they<sp/>will<sp/>end</highlight></codeline>
<codeline><highlight class="normal">up<sp/>writing<sp/>lots<sp/>of<sp/>redundant<sp/>code.<sp/>This<sp/>concern<sp/>is<sp/>totally<sp/>understandable.</highlight></codeline>
<codeline><highlight class="normal">However,<sp/>there<sp/>are<sp/>two<sp/>reasons<sp/>why<sp/>it<sp/>may<sp/>not<sp/>be<sp/>the<sp/>case:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>Different<sp/>projects<sp/>may<sp/>need<sp/>to<sp/>use<sp/>`Concrete`<sp/>in<sp/>different<sp/>ways,<sp/>so<sp/>the<sp/>best</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>interfaces<sp/>for<sp/>them<sp/>will<sp/>be<sp/>different.<sp/>Therefore,<sp/>each<sp/>of<sp/>them<sp/>will<sp/>have<sp/>its</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>own<sp/>domain-specific<sp/>interface<sp/>on<sp/>top<sp/>of<sp/>`Concrete`,<sp/>and<sp/>they<sp/>will<sp/>not<sp/>be<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>same<sp/>code.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>If<sp/>enough<sp/>projects<sp/>want<sp/>to<sp/>use<sp/>the<sp/>same<sp/>interface,<sp/>they<sp/>can<sp/>always<sp/>share<sp/>it,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>just<sp/>like<sp/>they<sp/>have<sp/>been<sp/>sharing<sp/>`Concrete`.<sp/>You<sp/>can<sp/>check<sp/>in<sp/>the<sp/>interface</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>and<sp/>the<sp/>adaptor<sp/>somewhere<sp/>near<sp/>`Concrete`<sp/>(perhaps<sp/>in<sp/>a<sp/>`contrib`</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sub-directory)<sp/>and<sp/>let<sp/>many<sp/>projects<sp/>use<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>need<sp/>to<sp/>weigh<sp/>the<sp/>pros<sp/>and<sp/>cons<sp/>carefully<sp/>for<sp/>your<sp/>particular<sp/>problem,<sp/>but</highlight></codeline>
<codeline><highlight class="normal">I&apos;d<sp/>like<sp/>to<sp/>assure<sp/>you<sp/>that<sp/>the<sp/>Java<sp/>community<sp/>has<sp/>been<sp/>practicing<sp/>this<sp/>for<sp/>a</highlight></codeline>
<codeline><highlight class="normal">long<sp/>time<sp/>and<sp/>it&apos;s<sp/>a<sp/>proven<sp/>effective<sp/>technique<sp/>applicable<sp/>in<sp/>a<sp/>wide<sp/>variety<sp/>of</highlight></codeline>
<codeline><highlight class="normal">situations.<sp/>:-)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Delegating<sp/>Calls<sp/>to<sp/>a<sp/>Fake<sp/>{#DelegatingToFake}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Some<sp/>times<sp/>you<sp/>have<sp/>a<sp/>non-trivial<sp/>fake<sp/>implementation<sp/>of<sp/>an<sp/>interface.<sp/>For</highlight></codeline>
<codeline><highlight class="normal">example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Foo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>char<sp/>DoThis(int<sp/>n)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DoThat(const<sp/>char*<sp/>s,<sp/>int*<sp/>p)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>FakeFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char<sp/>DoThis(int<sp/>n)<sp/>override<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(n<sp/>&gt;<sp/>0)<sp/>?<sp/>&apos;+&apos;<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(n<sp/>&lt;<sp/>0)<sp/>?<sp/>&apos;-&apos;<sp/>:<sp/>&apos;0&apos;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DoThat(const<sp/>char*<sp/>s,<sp/>int*<sp/>p)<sp/>override<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*p<sp/>=<sp/>strlen(s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now<sp/>you<sp/>want<sp/>to<sp/>mock<sp/>this<sp/>interface<sp/>such<sp/>that<sp/>you<sp/>can<sp/>set<sp/>expectations<sp/>on<sp/>it.</highlight></codeline>
<codeline><highlight class="normal">However,<sp/>you<sp/>also<sp/>want<sp/>to<sp/>use<sp/>`FakeFoo`<sp/>for<sp/>the<sp/>default<sp/>behavior,<sp/>as<sp/>duplicating</highlight></codeline>
<codeline><highlight class="normal">it<sp/>in<sp/>the<sp/>mock<sp/>object<sp/>is,<sp/>well,<sp/>a<sp/>lot<sp/>of<sp/>work.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>you<sp/>define<sp/>the<sp/>mock<sp/>class<sp/>using<sp/>gMock,<sp/>you<sp/>can<sp/>have<sp/>it<sp/>delegate<sp/>its<sp/>default</highlight></codeline>
<codeline><highlight class="normal">action<sp/>to<sp/>a<sp/>fake<sp/>class<sp/>you<sp/>already<sp/>have,<sp/>using<sp/>this<sp/>pattern:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Normal<sp/>mock<sp/>method<sp/>definitions<sp/>using<sp/>gMock.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(char,<sp/>DoThis,<sp/>(int<sp/>n),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>DoThat,<sp/>(const<sp/>char*<sp/>s,<sp/>int*<sp/>p),<sp/>(override));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Delegates<sp/>the<sp/>default<sp/>actions<sp/>of<sp/>the<sp/>methods<sp/>to<sp/>a<sp/>FakeFoo<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>must<sp/>be<sp/>called<sp/>*before*<sp/>the<sp/>custom<sp/>ON_CALL()<sp/>statements.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DelegateToFake()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoThis).WillByDefault([this](int<sp/>n)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>fake_.DoThis(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoThat).WillByDefault([this](const<sp/>char*<sp/>s,<sp/>int*<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>fake_.DoThat(s,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FakeFoo<sp/>fake_;<sp/><sp/>//<sp/>Keeps<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>fake<sp/>in<sp/>the<sp/>mock.</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">With<sp/>that,<sp/>you<sp/>can<sp/>use<sp/>`MockFoo`<sp/>in<sp/>your<sp/>tests<sp/>as<sp/>usual.<sp/>Just<sp/>remember<sp/>that<sp/>if</highlight></codeline>
<codeline><highlight class="normal">you<sp/>don&apos;t<sp/>explicitly<sp/>set<sp/>an<sp/>action<sp/>in<sp/>an<sp/>`ON_CALL()`<sp/>or<sp/>`EXPECT_CALL()`,<sp/>the</highlight></codeline>
<codeline><highlight class="normal">fake<sp/>will<sp/>be<sp/>called<sp/>upon<sp/>to<sp/>do<sp/>it.:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(AbcTest,<sp/>Xyz)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DelegateToFake();<sp/><sp/>//<sp/>Enables<sp/>the<sp/>fake<sp/>for<sp/>delegation.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Put<sp/>your<sp/>ON_CALL(foo,<sp/>...)s<sp/>here,<sp/>if<sp/>any.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>No<sp/>action<sp/>specified,<sp/>meaning<sp/>to<sp/>use<sp/>the<sp/>default<sp/>action.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(_,<sp/>_));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(foo.DoThis(5),<sp/>&apos;+&apos;);<sp/><sp/>//<sp/>FakeFoo::DoThis()<sp/>is<sp/>invoked.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat(&quot;Hi&quot;,<sp/>&amp;n);<sp/><sp/>//<sp/>FakeFoo::DoThat()<sp/>is<sp/>invoked.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(n,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Some<sp/>tips:**</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>If<sp/>you<sp/>want,<sp/>you<sp/>can<sp/>still<sp/>override<sp/>the<sp/>default<sp/>action<sp/>by<sp/>providing<sp/>your<sp/>own</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`ON_CALL()`<sp/>or<sp/>using<sp/>`.WillOnce()`<sp/>/<sp/>`.WillRepeatedly()`<sp/>in<sp/>`EXPECT_CALL()`.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>In<sp/>`DelegateToFake()`,<sp/>you<sp/>only<sp/>need<sp/>to<sp/>delegate<sp/>the<sp/>methods<sp/>whose<sp/>fake</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>implementation<sp/>you<sp/>intend<sp/>to<sp/>use.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>The<sp/>general<sp/>technique<sp/>discussed<sp/>here<sp/>works<sp/>for<sp/>overloaded<sp/>methods,<sp/>but</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>you&apos;ll<sp/>need<sp/>to<sp/>tell<sp/>the<sp/>compiler<sp/>which<sp/>version<sp/>you<sp/>mean.<sp/>To<sp/>disambiguate<sp/>a</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mock<sp/>function<sp/>(the<sp/>one<sp/>you<sp/>specify<sp/>inside<sp/>the<sp/>parentheses<sp/>of<sp/>`ON_CALL()`),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>use<sp/>[this<sp/>technique](#SelectOverload);<sp/>to<sp/>disambiguate<sp/>a<sp/>fake<sp/>function<sp/>(the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>one<sp/>you<sp/>place<sp/>inside<sp/>`Invoke()`),<sp/>use<sp/>a<sp/>`static_cast`<sp/>to<sp/>specify<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>function&apos;s<sp/>type.<sp/>For<sp/>instance,<sp/>if<sp/>class<sp/>`Foo`<sp/>has<sp/>methods<sp/>`char<sp/>DoThis(int</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n)`<sp/>and<sp/>`bool<sp/>DoThis(double<sp/>x)<sp/>const`,<sp/>and<sp/>you<sp/>want<sp/>to<sp/>invoke<sp/>the<sp/>latter,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>you<sp/>need<sp/>to<sp/>write<sp/>`Invoke(&amp;fake_,<sp/>static_cast&lt;bool<sp/>(FakeFoo::*)(double)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const&gt;(&amp;FakeFoo::DoThis))`<sp/>instead<sp/>of<sp/>`Invoke(&amp;fake_,<sp/>&amp;FakeFoo::DoThis)`</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(The<sp/>strange-looking<sp/>thing<sp/>inside<sp/>the<sp/>angled<sp/>brackets<sp/>of<sp/>`static_cast`<sp/>is</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>the<sp/>type<sp/>of<sp/>a<sp/>function<sp/>pointer<sp/>to<sp/>the<sp/>second<sp/>`DoThis()`<sp/>method.).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>Having<sp/>to<sp/>mix<sp/>a<sp/>mock<sp/>and<sp/>a<sp/>fake<sp/>is<sp/>often<sp/>a<sp/>sign<sp/>of<sp/>something<sp/>gone<sp/>wrong.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Perhaps<sp/>you<sp/>haven&apos;t<sp/>got<sp/>used<sp/>to<sp/>the<sp/>interaction-based<sp/>way<sp/>of<sp/>testing<sp/>yet.<sp/>Or</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>perhaps<sp/>your<sp/>interface<sp/>is<sp/>taking<sp/>on<sp/>too<sp/>many<sp/>roles<sp/>and<sp/>should<sp/>be<sp/>split<sp/>up.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Therefore,<sp/>**don&apos;t<sp/>abuse<sp/>this**.<sp/>We<sp/>would<sp/>only<sp/>recommend<sp/>to<sp/>do<sp/>it<sp/>as<sp/>an</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>intermediate<sp/>step<sp/>when<sp/>you<sp/>are<sp/>refactoring<sp/>your<sp/>code.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Regarding<sp/>the<sp/>tip<sp/>on<sp/>mixing<sp/>a<sp/>mock<sp/>and<sp/>a<sp/>fake,<sp/>here&apos;s<sp/>an<sp/>example<sp/>on<sp/>why<sp/>it<sp/>may</highlight></codeline>
<codeline><highlight class="normal">be<sp/>a<sp/>bad<sp/>sign:<sp/>Suppose<sp/>you<sp/>have<sp/>a<sp/>class<sp/>`System`<sp/>for<sp/>low-level<sp/>system</highlight></codeline>
<codeline><highlight class="normal">operations.<sp/>In<sp/>particular,<sp/>it<sp/>does<sp/>file<sp/>and<sp/>I/O<sp/>operations.<sp/>And<sp/>suppose<sp/>you<sp/>want</highlight></codeline>
<codeline><highlight class="normal">to<sp/>test<sp/>how<sp/>your<sp/>code<sp/>uses<sp/>`System`<sp/>to<sp/>do<sp/>I/O,<sp/>and<sp/>you<sp/>just<sp/>want<sp/>the<sp/>file</highlight></codeline>
<codeline><highlight class="normal">operations<sp/>to<sp/>work<sp/>normally.<sp/>If<sp/>you<sp/>mock<sp/>out<sp/>the<sp/>entire<sp/>`System`<sp/>class,<sp/>you&apos;ll</highlight></codeline>
<codeline><highlight class="normal">have<sp/>to<sp/>provide<sp/>a<sp/>fake<sp/>implementation<sp/>for<sp/>the<sp/>file<sp/>operation<sp/>part,<sp/>which</highlight></codeline>
<codeline><highlight class="normal">suggests<sp/>that<sp/>`System`<sp/>is<sp/>taking<sp/>on<sp/>too<sp/>many<sp/>roles.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Instead,<sp/>you<sp/>can<sp/>define<sp/>a<sp/>`FileOps`<sp/>interface<sp/>and<sp/>an<sp/>`IOOps`<sp/>interface<sp/>and<sp/>split</highlight></codeline>
<codeline><highlight class="normal">`System`&apos;s<sp/>functionalities<sp/>into<sp/>the<sp/>two.<sp/>Then<sp/>you<sp/>can<sp/>mock<sp/>`IOOps`<sp/>without</highlight></codeline>
<codeline><highlight class="normal">mocking<sp/>`FileOps`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Delegating<sp/>Calls<sp/>to<sp/>a<sp/>Real<sp/>Object</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>using<sp/>testing<sp/>doubles<sp/>(mocks,<sp/>fakes,<sp/>stubs,<sp/>and<sp/>etc),<sp/>sometimes<sp/>their</highlight></codeline>
<codeline><highlight class="normal">behaviors<sp/>will<sp/>differ<sp/>from<sp/>those<sp/>of<sp/>the<sp/>real<sp/>objects.<sp/>This<sp/>difference<sp/>could<sp/>be</highlight></codeline>
<codeline><highlight class="normal">either<sp/>intentional<sp/>(as<sp/>in<sp/>simulating<sp/>an<sp/>error<sp/>such<sp/>that<sp/>you<sp/>can<sp/>test<sp/>the<sp/>error</highlight></codeline>
<codeline><highlight class="normal">handling<sp/>code)<sp/>or<sp/>unintentional.<sp/>If<sp/>your<sp/>mocks<sp/>have<sp/>different<sp/>behaviors<sp/>than<sp/>the</highlight></codeline>
<codeline><highlight class="normal">real<sp/>objects<sp/>by<sp/>mistake,<sp/>you<sp/>could<sp/>end<sp/>up<sp/>with<sp/>code<sp/>that<sp/>passes<sp/>the<sp/>tests<sp/>but</highlight></codeline>
<codeline><highlight class="normal">fails<sp/>in<sp/>production.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>use<sp/>the<sp/>*delegating-to-real*<sp/>technique<sp/>to<sp/>ensure<sp/>that<sp/>your<sp/>mock<sp/>has<sp/>the</highlight></codeline>
<codeline><highlight class="normal">same<sp/>behavior<sp/>as<sp/>the<sp/>real<sp/>object<sp/>while<sp/>retaining<sp/>the<sp/>ability<sp/>to<sp/>validate<sp/>calls.</highlight></codeline>
<codeline><highlight class="normal">This<sp/>technique<sp/>is<sp/>very<sp/>similar<sp/>to<sp/>the<sp/>[delegating-to-fake](#DelegatingToFake)</highlight></codeline>
<codeline><highlight class="normal">technique,<sp/>the<sp/>difference<sp/>being<sp/>that<sp/>we<sp/>use<sp/>a<sp/>real<sp/>object<sp/>instead<sp/>of<sp/>a<sp/>fake.</highlight></codeline>
<codeline><highlight class="normal">Here&apos;s<sp/>an<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AtLeast;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>By<sp/>default,<sp/>all<sp/>calls<sp/>are<sp/>delegated<sp/>to<sp/>the<sp/>real<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoThis).WillByDefault([this](int<sp/>n)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>real_.DoThis(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ON_CALL(*this,<sp/>DoThat).WillByDefault([this](const<sp/>char*<sp/>s,<sp/>int*<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>real_.DoThat(s,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(char,<sp/>DoThis,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>DoThat,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo<sp/>real_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>DoThat(&quot;Hi&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AtLeast(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>mock<sp/>in<sp/>test<sp/>...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">With<sp/>this,<sp/>gMock<sp/>will<sp/>verify<sp/>that<sp/>your<sp/>code<sp/>made<sp/>the<sp/>right<sp/>calls<sp/>(with<sp/>the<sp/>right</highlight></codeline>
<codeline><highlight class="normal">arguments,<sp/>in<sp/>the<sp/>right<sp/>order,<sp/>called<sp/>the<sp/>right<sp/>number<sp/>of<sp/>times,<sp/>etc),<sp/>and<sp/>a</highlight></codeline>
<codeline><highlight class="normal">real<sp/>object<sp/>will<sp/>answer<sp/>the<sp/>calls<sp/>(so<sp/>the<sp/>behavior<sp/>will<sp/>be<sp/>the<sp/>same<sp/>as<sp/>in</highlight></codeline>
<codeline><highlight class="normal">production).<sp/>This<sp/>gives<sp/>you<sp/>the<sp/>best<sp/>of<sp/>both<sp/>worlds.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Delegating<sp/>Calls<sp/>to<sp/>a<sp/>Parent<sp/>Class</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Ideally,<sp/>you<sp/>should<sp/>code<sp/>to<sp/>interfaces,<sp/>whose<sp/>methods<sp/>are<sp/>all<sp/>pure<sp/>virtual.<sp/>In</highlight></codeline>
<codeline><highlight class="normal">reality,<sp/>sometimes<sp/>you<sp/>do<sp/>need<sp/>to<sp/>mock<sp/>a<sp/>virtual<sp/>method<sp/>that<sp/>is<sp/>not<sp/>pure<sp/>(i.e,</highlight></codeline>
<codeline><highlight class="normal">it<sp/>already<sp/>has<sp/>an<sp/>implementation).<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Foo();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>Pure(int<sp/>n)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>int<sp/>Concrete(const<sp/>char*<sp/>str)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Mocking<sp/>a<sp/>pure<sp/>method.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Pure,<sp/>(int<sp/>n),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Mocking<sp/>a<sp/>concrete<sp/>method.<sp/><sp/>Foo::Concrete()<sp/>is<sp/>shadowed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>Concrete,<sp/>(const<sp/>char*<sp/>str),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>may<sp/>want<sp/>to<sp/>call<sp/>`Foo::Concrete()`<sp/>instead<sp/>of</highlight></codeline>
<codeline><highlight class="normal">`MockFoo::Concrete()`.<sp/>Perhaps<sp/>you<sp/>want<sp/>to<sp/>do<sp/>it<sp/>as<sp/>part<sp/>of<sp/>a<sp/>stub<sp/>action,<sp/>or</highlight></codeline>
<codeline><highlight class="normal">perhaps<sp/>your<sp/>test<sp/>doesn&apos;t<sp/>need<sp/>to<sp/>mock<sp/>`Concrete()`<sp/>at<sp/>all<sp/>(but<sp/>it<sp/>would<sp/>be</highlight></codeline>
<codeline><highlight class="normal">oh-so<sp/>painful<sp/>to<sp/>have<sp/>to<sp/>define<sp/>a<sp/>new<sp/>mock<sp/>class<sp/>whenever<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">one<sp/>of<sp/>its<sp/>methods).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>call<sp/>`Foo::Concrete()`<sp/>inside<sp/>an<sp/>action<sp/>by:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Concrete).WillOnce([&amp;foo](const<sp/>char*<sp/>str)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>foo.Foo::Concrete(str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">or<sp/>tell<sp/>the<sp/>mock<sp/>object<sp/>that<sp/>you<sp/>don&apos;t<sp/>want<sp/>to<sp/>mock<sp/>`Concrete()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Concrete).WillByDefault([&amp;foo](const<sp/>char*<sp/>str)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>foo.Foo::Concrete(str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">(Why<sp/>don&apos;t<sp/>we<sp/>just<sp/>write<sp/>`{<sp/>return<sp/>foo.Concrete(str);<sp/>}`?<sp/>If<sp/>you<sp/>do<sp/>that,</highlight></codeline>
<codeline><highlight class="normal">`MockFoo::Concrete()`<sp/>will<sp/>be<sp/>called<sp/>(and<sp/>cause<sp/>an<sp/>infinite<sp/>recursion)<sp/>since</highlight></codeline>
<codeline><highlight class="normal">`Foo::Concrete()`<sp/>is<sp/>virtual.<sp/>That&apos;s<sp/>just<sp/>how<sp/>C++<sp/>works.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Matchers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Matching<sp/>Argument<sp/>Values<sp/>Exactly</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>specify<sp/>exactly<sp/>which<sp/>arguments<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>expecting:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Return(&apos;a&apos;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(&quot;Hello&quot;,<sp/>bar));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>Simple<sp/>Matchers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>use<sp/>matchers<sp/>to<sp/>match<sp/>arguments<sp/>that<sp/>have<sp/>a<sp/>certain<sp/>property:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(Ge(5)))<sp/><sp/>//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>&gt;=<sp/>5.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Return(&apos;a&apos;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(&quot;Hello&quot;,<sp/>NotNull()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>second<sp/>argument<sp/>must<sp/>not<sp/>be<sp/>NULL.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>frequently<sp/>used<sp/>matcher<sp/>is<sp/>`_`,<sp/>which<sp/>matches<sp/>anything:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(_,<sp/>NotNull()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Combining<sp/>Matchers<sp/>{#CombiningMatchers}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>build<sp/>complex<sp/>matchers<sp/>from<sp/>existing<sp/>ones<sp/>using<sp/>`AllOf()`,</highlight></codeline>
<codeline><highlight class="normal">`AllOfArray()`,<sp/>`AnyOf()`,<sp/>`AnyOfArray()`<sp/>and<sp/>`Not()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::HasSubstr;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ne;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Not;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>&gt;<sp/>5<sp/>and<sp/>!=<sp/>10.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(AllOf(Gt(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ne(10))));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>first<sp/>argument<sp/>must<sp/>not<sp/>contain<sp/>sub-string<sp/>&quot;blah&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(Not(HasSubstr(&quot;blah&quot;)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NULL));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Matchers<sp/>are<sp/>function<sp/>objects,<sp/>and<sp/>parametrized<sp/>matchers<sp/>can<sp/>be<sp/>composed<sp/>just</highlight></codeline>
<codeline><highlight class="normal">like<sp/>any<sp/>other<sp/>function.<sp/>However<sp/>because<sp/>their<sp/>types<sp/>can<sp/>be<sp/>long<sp/>and<sp/>rarely</highlight></codeline>
<codeline><highlight class="normal">provide<sp/>meaningful<sp/>information,<sp/>it<sp/>can<sp/>be<sp/>easier<sp/>to<sp/>express<sp/>them<sp/>with<sp/>C++14</highlight></codeline>
<codeline><highlight class="normal">generic<sp/>lambdas<sp/>to<sp/>avoid<sp/>specifying<sp/>types.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Contains;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Property;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">inline<sp/>constexpr<sp/>auto<sp/>HasFoo<sp/>=<sp/>[](const<sp/>auto&amp;<sp/>f)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Property(&quot;foo&quot;,<sp/>&amp;MyClass::foo,<sp/>Contains(f));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(x,<sp/>HasFoo(&quot;blah&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Casting<sp/>Matchers<sp/>{#SafeMatcherCast}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>matchers<sp/>are<sp/>statically<sp/>typed,<sp/>meaning<sp/>that<sp/>the<sp/>compiler<sp/>can<sp/>catch<sp/>your</highlight></codeline>
<codeline><highlight class="normal">mistake<sp/>if<sp/>you<sp/>use<sp/>a<sp/>matcher<sp/>of<sp/>the<sp/>wrong<sp/>type<sp/>(for<sp/>example,<sp/>if<sp/>you<sp/>use<sp/>`Eq(5)`</highlight></codeline>
<codeline><highlight class="normal">to<sp/>match<sp/>a<sp/>`string`<sp/>argument).<sp/>Good<sp/>for<sp/>you!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes,<sp/>however,<sp/>you<sp/>know<sp/>what<sp/>you&apos;re<sp/>doing<sp/>and<sp/>want<sp/>the<sp/>compiler<sp/>to<sp/>give<sp/>you</highlight></codeline>
<codeline><highlight class="normal">some<sp/>slack.<sp/>One<sp/>example<sp/>is<sp/>that<sp/>you<sp/>have<sp/>a<sp/>matcher<sp/>for<sp/>`long`<sp/>and<sp/>the<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">you<sp/>want<sp/>to<sp/>match<sp/>is<sp/>`int`.<sp/>While<sp/>the<sp/>two<sp/>types<sp/>aren&apos;t<sp/>exactly<sp/>the<sp/>same,<sp/>there</highlight></codeline>
<codeline><highlight class="normal">is<sp/>nothing<sp/>really<sp/>wrong<sp/>with<sp/>using<sp/>a<sp/>`Matcher&lt;long&gt;`<sp/>to<sp/>match<sp/>an<sp/>`int`<sp/>-<sp/>after</highlight></codeline>
<codeline><highlight class="normal">all,<sp/>we<sp/>can<sp/>first<sp/>convert<sp/>the<sp/>`int`<sp/>argument<sp/>to<sp/>a<sp/>`long`<sp/>losslessly<sp/>before</highlight></codeline>
<codeline><highlight class="normal">giving<sp/>it<sp/>to<sp/>the<sp/>matcher.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>support<sp/>this<sp/>need,<sp/>gMock<sp/>gives<sp/>you<sp/>the<sp/>`SafeMatcherCast&lt;T&gt;(m)`<sp/>function.<sp/>It</highlight></codeline>
<codeline><highlight class="normal">casts<sp/>a<sp/>matcher<sp/>`m`<sp/>to<sp/>type<sp/>`Matcher&lt;T&gt;`.<sp/>To<sp/>ensure<sp/>safety,<sp/>gMock<sp/>checks<sp/>that</highlight></codeline>
<codeline><highlight class="normal">(let<sp/>`U`<sp/>be<sp/>the<sp/>type<sp/>`m`<sp/>accepts<sp/>:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/><sp/>Type<sp/>`T`<sp/>can<sp/>be<sp/>*implicitly*<sp/>cast<sp/>to<sp/>type<sp/>`U`;</highlight></codeline>
<codeline><highlight class="normal">2.<sp/><sp/>When<sp/>both<sp/>`T`<sp/>and<sp/>`U`<sp/>are<sp/>built-in<sp/>arithmetic<sp/>types<sp/>(`bool`,<sp/>integers,<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>floating-point<sp/>numbers),<sp/>the<sp/>conversion<sp/>from<sp/>`T`<sp/>to<sp/>`U`<sp/>is<sp/>not<sp/>lossy<sp/>(in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>other<sp/>words,<sp/>any<sp/>value<sp/>representable<sp/>by<sp/>`T`<sp/>can<sp/>also<sp/>be<sp/>represented<sp/>by<sp/>`U`);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>and</highlight></codeline>
<codeline><highlight class="normal">3.<sp/><sp/>When<sp/>`U`<sp/>is<sp/>a<sp/>reference,<sp/>`T`<sp/>must<sp/>also<sp/>be<sp/>a<sp/>reference<sp/>(as<sp/>the<sp/>underlying</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>matcher<sp/>may<sp/>be<sp/>interested<sp/>in<sp/>the<sp/>address<sp/>of<sp/>the<sp/>`U`<sp/>value).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>code<sp/>won&apos;t<sp/>compile<sp/>if<sp/>any<sp/>of<sp/>these<sp/>conditions<sp/>isn&apos;t<sp/>met.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Here&apos;s<sp/>one<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SafeMatcherCast;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>A<sp/>base<sp/>class<sp/>and<sp/>a<sp/>child<sp/>class.</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Base<sp/>{<sp/>...<sp/>};</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Derived<sp/>:<sp/>public<sp/>Base<sp/>{<sp/>...<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>DoThis,<sp/>(Derived*<sp/>derived),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>m<sp/>is<sp/>a<sp/>Matcher&lt;Base*&gt;<sp/>we<sp/>got<sp/>from<sp/>somewhere.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(SafeMatcherCast&lt;Derived*&gt;(m)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>find<sp/>`SafeMatcherCast&lt;T&gt;(m)`<sp/>too<sp/>limiting,<sp/>you<sp/>can<sp/>use<sp/>a<sp/>similar<sp/>function</highlight></codeline>
<codeline><highlight class="normal">`MatcherCast&lt;T&gt;(m)`.<sp/>The<sp/>difference<sp/>is<sp/>that<sp/>`MatcherCast`<sp/>works<sp/>as<sp/>long<sp/>as<sp/>you</highlight></codeline>
<codeline><highlight class="normal">can<sp/>`static_cast`<sp/>type<sp/>`T`<sp/>to<sp/>type<sp/>`U`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`MatcherCast`<sp/>essentially<sp/>lets<sp/>you<sp/>bypass<sp/>C++&apos;s<sp/>type<sp/>system<sp/>(`static_cast`<sp/>isn&apos;t</highlight></codeline>
<codeline><highlight class="normal">always<sp/>safe<sp/>as<sp/>it<sp/>could<sp/>throw<sp/>away<sp/>information,<sp/>for<sp/>example),<sp/>so<sp/>be<sp/>careful<sp/>not</highlight></codeline>
<codeline><highlight class="normal">to<sp/>misuse/abuse<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Selecting<sp/>Between<sp/>Overloaded<sp/>Functions<sp/>{#SelectOverload}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>expect<sp/>an<sp/>overloaded<sp/>function<sp/>to<sp/>be<sp/>called,<sp/>the<sp/>compiler<sp/>may<sp/>need<sp/>some</highlight></codeline>
<codeline><highlight class="normal">help<sp/>on<sp/>which<sp/>overloaded<sp/>version<sp/>it<sp/>is.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>disambiguate<sp/>functions<sp/>overloaded<sp/>on<sp/>the<sp/>const-ness<sp/>of<sp/>this<sp/>object,<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`Const()`<sp/>argument<sp/>wrapper.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ReturnRef;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(const<sp/>Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(const,<sp/>override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>bar1,<sp/>bar2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetBar())<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>non-const<sp/>GetBar().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(Const(foo),<sp/>GetBar())<sp/><sp/>//<sp/>The<sp/>const<sp/>GetBar().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar2));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">(`Const()`<sp/>is<sp/>defined<sp/>by<sp/>gMock<sp/>and<sp/>returns<sp/>a<sp/>`const`<sp/>reference<sp/>to<sp/>its<sp/>argument.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>disambiguate<sp/>overloaded<sp/>functions<sp/>with<sp/>the<sp/>same<sp/>number<sp/>of<sp/>arguments<sp/>but</highlight></codeline>
<codeline><highlight class="normal">different<sp/>argument<sp/>types,<sp/>you<sp/>may<sp/>need<sp/>to<sp/>specify<sp/>the<sp/>exact<sp/>type<sp/>of<sp/>a<sp/>matcher,</highlight></codeline>
<codeline><highlight class="normal">either<sp/>by<sp/>wrapping<sp/>your<sp/>matcher<sp/>in<sp/>`Matcher&lt;type&gt;()`,<sp/>or<sp/>using<sp/>a<sp/>matcher<sp/>whose</highlight></codeline>
<codeline><highlight class="normal">type<sp/>is<sp/>fixed<sp/>(`TypedEq&lt;type&gt;`,<sp/>`An&lt;type&gt;()`,<sp/>etc):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::An;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::TypedEq;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockPrinter<sp/>:<sp/>public<sp/>Printer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Print,<sp/>(int<sp/>n),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Print,<sp/>(char<sp/>c),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(PrinterTest,<sp/>Print)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockPrinter<sp/>printer;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(An&lt;int&gt;()));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>void<sp/>Print(int);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(Matcher&lt;int&gt;(Lt(5))));<sp/><sp/>//<sp/>void<sp/>Print(int);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(printer,<sp/>Print(TypedEq&lt;char&gt;(&apos;a&apos;)));<sp/><sp/><sp/>//<sp/>void<sp/>Print(char);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printer.Print(&apos;a&apos;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Performing<sp/>Different<sp/>Actions<sp/>Based<sp/>on<sp/>the<sp/>Arguments</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>called,<sp/>the<sp/>*last*<sp/>matching<sp/>expectation<sp/>that&apos;s<sp/>still</highlight></codeline>
<codeline><highlight class="normal">active<sp/>will<sp/>be<sp/>selected<sp/>(think<sp/>&quot;newer<sp/>overrides<sp/>older&quot;).<sp/>So,<sp/>you<sp/>can<sp/>make<sp/>a</highlight></codeline>
<codeline><highlight class="normal">method<sp/>do<sp/>different<sp/>things<sp/>depending<sp/>on<sp/>its<sp/>argument<sp/>values<sp/>like<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>default<sp/>case.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&apos;b&apos;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>more<sp/>specific<sp/>case.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(Lt(5)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&apos;a&apos;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now,<sp/>if<sp/>`foo.DoThis()`<sp/>is<sp/>called<sp/>with<sp/>a<sp/>value<sp/>less<sp/>than<sp/>5,<sp/>`&apos;a&apos;`<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">returned;<sp/>otherwise<sp/>`&apos;b&apos;`<sp/>will<sp/>be<sp/>returned.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Matching<sp/>Multiple<sp/>Arguments<sp/>as<sp/>a<sp/>Whole</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>it&apos;s<sp/>not<sp/>enough<sp/>to<sp/>match<sp/>the<sp/>arguments<sp/>individually.<sp/>For<sp/>example,<sp/>we</highlight></codeline>
<codeline><highlight class="normal">may<sp/>want<sp/>to<sp/>say<sp/>that<sp/>the<sp/>first<sp/>argument<sp/>must<sp/>be<sp/>less<sp/>than<sp/>the<sp/>second<sp/>argument.</highlight></codeline>
<codeline><highlight class="normal">The<sp/>`With()`<sp/>clause<sp/>allows<sp/>us<sp/>to<sp/>match<sp/>all<sp/>arguments<sp/>of<sp/>a<sp/>mock<sp/>function<sp/>as<sp/>a</highlight></codeline>
<codeline><highlight class="normal">whole.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ne;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>InRange(Ne(0),<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.With(Lt());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">says<sp/>that<sp/>the<sp/>first<sp/>argument<sp/>of<sp/>`InRange()`<sp/>must<sp/>not<sp/>be<sp/>0,<sp/>and<sp/>must<sp/>be<sp/>less<sp/>than</highlight></codeline>
<codeline><highlight class="normal">the<sp/>second<sp/>argument.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>expression<sp/>inside<sp/>`With()`<sp/>must<sp/>be<sp/>a<sp/>matcher<sp/>of<sp/>type<sp/>`Matcher&lt;std::tuple&lt;A1,</highlight></codeline>
<codeline><highlight class="normal">...,<sp/>An&gt;&gt;`,<sp/>where<sp/>`A1`,<sp/>...,<sp/>`An`<sp/>are<sp/>the<sp/>types<sp/>of<sp/>the<sp/>function<sp/>arguments.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>also<sp/>write<sp/>`AllArgs(m)`<sp/>instead<sp/>of<sp/>`m`<sp/>inside<sp/>`.With()`.<sp/>The<sp/>two<sp/>forms</highlight></codeline>
<codeline><highlight class="normal">are<sp/>equivalent,<sp/>but<sp/>`.With(AllArgs(Lt()))`<sp/>is<sp/>more<sp/>readable<sp/>than<sp/>`.With(Lt())`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>use<sp/>`Args&lt;k1,<sp/>...,<sp/>kn&gt;(m)`<sp/>to<sp/>match<sp/>the<sp/>`n`<sp/>selected<sp/>arguments<sp/>(as<sp/>a</highlight></codeline>
<codeline><highlight class="normal">tuple)<sp/>against<sp/>`m`.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Args;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Blah)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.With(AllOf(Args&lt;0,<sp/>1&gt;(Lt()),<sp/>Args&lt;1,<sp/>2&gt;(Lt())));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">says<sp/>that<sp/>`Blah`<sp/>will<sp/>be<sp/>called<sp/>with<sp/>arguments<sp/>`x`,<sp/>`y`,<sp/>and<sp/>`z`<sp/>where<sp/>`x<sp/>&lt;<sp/>y<sp/>&lt;</highlight></codeline>
<codeline><highlight class="normal">z`.<sp/>Note<sp/>that<sp/>in<sp/>this<sp/>example,<sp/>it<sp/>wasn&apos;t<sp/>necessary<sp/>to<sp/>specify<sp/>the<sp/>positional</highlight></codeline>
<codeline><highlight class="normal">matchers.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>a<sp/>convenience<sp/>and<sp/>example,<sp/>gMock<sp/>provides<sp/>some<sp/>matchers<sp/>for<sp/>2-tuples,</highlight></codeline>
<codeline><highlight class="normal">including<sp/>the<sp/>`Lt()`<sp/>matcher<sp/>above.<sp/>See</highlight></codeline>
<codeline><highlight class="normal">[Multi-argument<sp/>Matchers](reference/matchers.md#MultiArgMatchers)<sp/>for<sp/>the</highlight></codeline>
<codeline><highlight class="normal">complete<sp/>list.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>if<sp/>you<sp/>want<sp/>to<sp/>pass<sp/>the<sp/>arguments<sp/>to<sp/>a<sp/>predicate<sp/>of<sp/>your<sp/>own<sp/>(e.g.</highlight></codeline>
<codeline><highlight class="normal">`.With(Args&lt;0,<sp/>1&gt;(Truly(&amp;MyPredicate)))`),<sp/>that<sp/>predicate<sp/>MUST<sp/>be<sp/>written<sp/>to</highlight></codeline>
<codeline><highlight class="normal">take<sp/>a<sp/>`std::tuple`<sp/>as<sp/>its<sp/>argument;<sp/>gMock<sp/>will<sp/>pass<sp/>the<sp/>`n`<sp/>selected<sp/>arguments</highlight></codeline>
<codeline><highlight class="normal">as<sp/>*one*<sp/>single<sp/>tuple<sp/>to<sp/>the<sp/>predicate.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>Matchers<sp/>as<sp/>Predicates</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Have<sp/>you<sp/>noticed<sp/>that<sp/>a<sp/>matcher<sp/>is<sp/>just<sp/>a<sp/>fancy<sp/>predicate<sp/>that<sp/>also<sp/>knows<sp/>how<sp/>to</highlight></codeline>
<codeline><highlight class="normal">describe<sp/>itself?<sp/>Many<sp/>existing<sp/>algorithms<sp/>take<sp/>predicates<sp/>as<sp/>arguments<sp/>(e.g.</highlight></codeline>
<codeline><highlight class="normal">those<sp/>defined<sp/>in<sp/>STL&apos;s<sp/>`&lt;algorithm&gt;`<sp/>header),<sp/>and<sp/>it<sp/>would<sp/>be<sp/>a<sp/>shame<sp/>if<sp/>gMock</highlight></codeline>
<codeline><highlight class="normal">matchers<sp/>were<sp/>not<sp/>allowed<sp/>to<sp/>participate.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Luckily,<sp/>you<sp/>can<sp/>use<sp/>a<sp/>matcher<sp/>where<sp/>a<sp/>unary<sp/>predicate<sp/>functor<sp/>is<sp/>expected<sp/>by</highlight></codeline>
<codeline><highlight class="normal">wrapping<sp/>it<sp/>inside<sp/>the<sp/>`Matches()`<sp/>function.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;algorithm&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;vector&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matches;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">vector&lt;int&gt;<sp/>v;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">//<sp/>How<sp/>many<sp/>elements<sp/>in<sp/>v<sp/>are<sp/>&gt;=<sp/>10?</highlight></codeline>
<codeline><highlight class="normal">const<sp/>int<sp/>count<sp/>=<sp/>count_if(v.begin(),<sp/>v.end(),<sp/>Matches(Ge(10)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Since<sp/>you<sp/>can<sp/>build<sp/>complex<sp/>matchers<sp/>from<sp/>simpler<sp/>ones<sp/>easily<sp/>using<sp/>gMock,<sp/>this</highlight></codeline>
<codeline><highlight class="normal">gives<sp/>you<sp/>a<sp/>way<sp/>to<sp/>conveniently<sp/>construct<sp/>composite<sp/>predicates<sp/>(doing<sp/>the<sp/>same</highlight></codeline>
<codeline><highlight class="normal">using<sp/>STL&apos;s<sp/>`&lt;functional&gt;`<sp/>header<sp/>is<sp/>just<sp/>painful).<sp/>For<sp/>example,<sp/>here&apos;s<sp/>a</highlight></codeline>
<codeline><highlight class="normal">predicate<sp/>that&apos;s<sp/>satisfied<sp/>by<sp/>any<sp/>number<sp/>that<sp/>is<sp/>&gt;=<sp/>0,<sp/>&lt;=<sp/>100,<sp/>and<sp/>!=<sp/>50:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Le;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matches;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ne;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">Matches(AllOf(Ge(0),<sp/>Le(100),<sp/>Ne(50)))</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>Matchers<sp/>in<sp/>googletest<sp/>Assertions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">See<sp/>[`EXPECT_THAT`](reference/assertions.md#EXPECT_THAT)<sp/>in<sp/>the<sp/>Assertions</highlight></codeline>
<codeline><highlight class="normal">Reference.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>Predicates<sp/>as<sp/>Matchers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>provides<sp/>a<sp/>set<sp/>of<sp/>built-in<sp/>matchers<sp/>for<sp/>matching<sp/>arguments<sp/>with<sp/>expected</highlight></codeline>
<codeline><highlight class="normal">values—see<sp/>the<sp/>[Matchers<sp/>Reference](reference/matchers.md)<sp/>for<sp/>more<sp/>information.</highlight></codeline>
<codeline><highlight class="normal">In<sp/>case<sp/>you<sp/>find<sp/>the<sp/>built-in<sp/>set<sp/>lacking,<sp/>you<sp/>can<sp/>use<sp/>an<sp/>arbitrary<sp/>unary</highlight></codeline>
<codeline><highlight class="normal">predicate<sp/>function<sp/>or<sp/>functor<sp/>as<sp/>a<sp/>matcher<sp/>-<sp/>as<sp/>long<sp/>as<sp/>the<sp/>predicate<sp/>accepts<sp/>a</highlight></codeline>
<codeline><highlight class="normal">value<sp/>of<sp/>the<sp/>type<sp/>you<sp/>want.<sp/>You<sp/>do<sp/>this<sp/>by<sp/>wrapping<sp/>the<sp/>predicate<sp/>inside<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`Truly()`<sp/>function,<sp/>for<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Truly;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>IsEven(int<sp/>n)<sp/>{<sp/>return<sp/>(n<sp/>%<sp/>2)<sp/>==<sp/>0<sp/>?<sp/>1<sp/>:<sp/>0;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Bar()<sp/>must<sp/>be<sp/>called<sp/>with<sp/>an<sp/>even<sp/>number.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Truly(IsEven)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>predicate<sp/>function<sp/>/<sp/>functor<sp/>doesn&apos;t<sp/>have<sp/>to<sp/>return<sp/>`bool`.<sp/>It</highlight></codeline>
<codeline><highlight class="normal">works<sp/>as<sp/>long<sp/>as<sp/>the<sp/>return<sp/>value<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>condition<sp/>in<sp/>the<sp/>statement</highlight></codeline>
<codeline><highlight class="normal">`if<sp/>(condition)<sp/>...`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Matching<sp/>Arguments<sp/>that<sp/>Are<sp/>Not<sp/>Copyable</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>you<sp/>do<sp/>an<sp/>`EXPECT_CALL(mock_obj,<sp/>Foo(bar))`,<sp/>gMock<sp/>saves<sp/>away<sp/>a<sp/>copy<sp/>of</highlight></codeline>
<codeline><highlight class="normal">`bar`.<sp/>When<sp/>`Foo()`<sp/>is<sp/>called<sp/>later,<sp/>gMock<sp/>compares<sp/>the<sp/>argument<sp/>to<sp/>`Foo()`<sp/>with</highlight></codeline>
<codeline><highlight class="normal">the<sp/>saved<sp/>copy<sp/>of<sp/>`bar`.<sp/>This<sp/>way,<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>worry<sp/>about<sp/>`bar`<sp/>being</highlight></codeline>
<codeline><highlight class="normal">modified<sp/>or<sp/>destroyed<sp/>after<sp/>the<sp/>`EXPECT_CALL()`<sp/>is<sp/>executed.<sp/>The<sp/>same<sp/>is<sp/>true</highlight></codeline>
<codeline><highlight class="normal">when<sp/>you<sp/>use<sp/>matchers<sp/>like<sp/>`Eq(bar)`,<sp/>`Le(bar)`,<sp/>and<sp/>so<sp/>on.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">But<sp/>what<sp/>if<sp/>`bar`<sp/>cannot<sp/>be<sp/>copied<sp/>(i.e.<sp/>has<sp/>no<sp/>copy<sp/>constructor)?<sp/>You<sp/>could</highlight></codeline>
<codeline><highlight class="normal">define<sp/>your<sp/>own<sp/>matcher<sp/>function<sp/>or<sp/>callback<sp/>and<sp/>use<sp/>it<sp/>with<sp/>`Truly()`,<sp/>as<sp/>the</highlight></codeline>
<codeline><highlight class="normal">previous<sp/>couple<sp/>of<sp/>recipes<sp/>have<sp/>shown.<sp/>Or,<sp/>you<sp/>may<sp/>be<sp/>able<sp/>to<sp/>get<sp/>away<sp/>from<sp/>it</highlight></codeline>
<codeline><highlight class="normal">if<sp/>you<sp/>can<sp/>guarantee<sp/>that<sp/>`bar`<sp/>won&apos;t<sp/>be<sp/>changed<sp/>after<sp/>the<sp/>`EXPECT_CALL()`<sp/>is</highlight></codeline>
<codeline><highlight class="normal">executed.<sp/>Just<sp/>tell<sp/>gMock<sp/>that<sp/>it<sp/>should<sp/>save<sp/>a<sp/>reference<sp/>to<sp/>`bar`,<sp/>instead<sp/>of<sp/>a</highlight></codeline>
<codeline><highlight class="normal">copy<sp/>of<sp/>it.<sp/>Here&apos;s<sp/>how:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Eq;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Lt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Expects<sp/>that<sp/>Foo()&apos;s<sp/>argument<sp/>==<sp/>bar.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_obj,<sp/>Foo(Eq(std::ref(bar))));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Expects<sp/>that<sp/>Foo()&apos;s<sp/>argument<sp/>&lt;<sp/>bar.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_obj,<sp/>Foo(Lt(std::ref(bar))));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remember:<sp/>if<sp/>you<sp/>do<sp/>this,<sp/>don&apos;t<sp/>change<sp/>`bar`<sp/>after<sp/>the<sp/>`EXPECT_CALL()`,<sp/>or<sp/>the</highlight></codeline>
<codeline><highlight class="normal">result<sp/>is<sp/>undefined.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Validating<sp/>a<sp/>Member<sp/>of<sp/>an<sp/>Object</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Often<sp/>a<sp/>mock<sp/>function<sp/>takes<sp/>a<sp/>reference<sp/>to<sp/>object<sp/>as<sp/>an<sp/>argument.<sp/>When<sp/>matching</highlight></codeline>
<codeline><highlight class="normal">the<sp/>argument,<sp/>you<sp/>may<sp/>not<sp/>want<sp/>to<sp/>compare<sp/>the<sp/>entire<sp/>object<sp/>against<sp/>a<sp/>fixed</highlight></codeline>
<codeline><highlight class="normal">object,<sp/>as<sp/>that<sp/>may<sp/>be<sp/>over-specification.<sp/>Instead,<sp/>you<sp/>may<sp/>need<sp/>to<sp/>validate<sp/>a</highlight></codeline>
<codeline><highlight class="normal">certain<sp/>member<sp/>variable<sp/>or<sp/>the<sp/>result<sp/>of<sp/>a<sp/>certain<sp/>getter<sp/>method<sp/>of<sp/>the<sp/>object.</highlight></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>do<sp/>this<sp/>with<sp/>`Field()`<sp/>and<sp/>`Property()`.<sp/>More<sp/>specifically,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">Field(&amp;Foo::bar,<sp/>m)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">is<sp/>a<sp/>matcher<sp/>that<sp/>matches<sp/>a<sp/>`Foo`<sp/>object<sp/>whose<sp/>`bar`<sp/>member<sp/>variable<sp/>satisfies</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>`m`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">Property(&amp;Foo::baz,<sp/>m)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">is<sp/>a<sp/>matcher<sp/>that<sp/>matches<sp/>a<sp/>`Foo`<sp/>object<sp/>whose<sp/>`baz()`<sp/>method<sp/>returns<sp/>a<sp/>value</highlight></codeline>
<codeline><highlight class="normal">that<sp/>satisfies<sp/>matcher<sp/>`m`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">|<sp/>Expression<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Description<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>:---------------------------<sp/>|<sp/>:---------------------------------------<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`Field(&amp;Foo::number,<sp/>Ge(3))`<sp/>|<sp/>Matches<sp/>`x`<sp/>where<sp/>`x.number<sp/>&gt;=<sp/>3`.<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`Property(&amp;Foo::name,<sp/><sp/>StartsWith(&quot;John<sp/>&quot;))`<sp/>|<sp/>Matches<sp/>`x`<sp/>where<sp/>`x.name()`<sp/>starts<sp/>with<sp/><sp/>`&quot;John<sp/>&quot;`.<sp/>|</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>in<sp/>`Property(&amp;Foo::baz,<sp/>...)`,<sp/>method<sp/>`baz()`<sp/>must<sp/>take<sp/>no<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">and<sp/>be<sp/>declared<sp/>as<sp/>`const`.<sp/>Don&apos;t<sp/>use<sp/>`Property()`<sp/>against<sp/>member<sp/>functions<sp/>that</highlight></codeline>
<codeline><highlight class="normal">you<sp/>do<sp/>not<sp/>own,<sp/>because<sp/>taking<sp/>addresses<sp/>of<sp/>functions<sp/>is<sp/>fragile<sp/>and<sp/>generally</highlight></codeline>
<codeline><highlight class="normal">not<sp/>part<sp/>of<sp/>the<sp/>contract<sp/>of<sp/>the<sp/>function.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`Field()`<sp/>and<sp/>`Property()`<sp/>can<sp/>also<sp/>match<sp/>plain<sp/>pointers<sp/>to<sp/>objects.<sp/>For</highlight></codeline>
<codeline><highlight class="normal">instance,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Field;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">Field(&amp;Foo::number,<sp/>Ge(3))</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">matches<sp/>a<sp/>plain<sp/>pointer<sp/>`p`<sp/>where<sp/>`p-&gt;number<sp/>&gt;=<sp/>3`.<sp/>If<sp/>`p`<sp/>is<sp/>`NULL`,<sp/>the<sp/>match</highlight></codeline>
<codeline><highlight class="normal">will<sp/>always<sp/>fail<sp/>regardless<sp/>of<sp/>the<sp/>inner<sp/>matcher.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>you<sp/>want<sp/>to<sp/>validate<sp/>more<sp/>than<sp/>one<sp/>members<sp/>at<sp/>the<sp/>same<sp/>time?<sp/>Remember</highlight></codeline>
<codeline><highlight class="normal">that<sp/>there<sp/>are<sp/>[`AllOf()`<sp/>and<sp/>`AllOfArray()`](#CombiningMatchers).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Finally<sp/>`Field()`<sp/>and<sp/>`Property()`<sp/>provide<sp/>overloads<sp/>that<sp/>take<sp/>the<sp/>field<sp/>or</highlight></codeline>
<codeline><highlight class="normal">property<sp/>names<sp/>as<sp/>the<sp/>first<sp/>argument<sp/>to<sp/>include<sp/>it<sp/>in<sp/>the<sp/>error<sp/>message.<sp/>This</highlight></codeline>
<codeline><highlight class="normal">can<sp/>be<sp/>useful<sp/>when<sp/>creating<sp/>combined<sp/>matchers.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Field;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SafeMatcherCast;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Matcher&lt;Foo&gt;<sp/>IsFoo(const<sp/>Foo&amp;<sp/>foo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>AllOf(Field(&quot;some_field&quot;,<sp/>&amp;Foo::some_field,<sp/>foo.some_field),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Field(&quot;other_field&quot;,<sp/>&amp;Foo::other_field,<sp/>foo.other_field),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Field(&quot;last_field&quot;,<sp/>&amp;Foo::last_field,<sp/>foo.last_field));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Validating<sp/>the<sp/>Value<sp/>Pointed<sp/>to<sp/>by<sp/>a<sp/>Pointer<sp/>Argument</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">C++<sp/>functions<sp/>often<sp/>take<sp/>pointers<sp/>as<sp/>arguments.<sp/>You<sp/>can<sp/>use<sp/>matchers<sp/>like</highlight></codeline>
<codeline><highlight class="normal">`IsNull()`,<sp/>`NotNull()`,<sp/>and<sp/>other<sp/>comparison<sp/>matchers<sp/>to<sp/>match<sp/>a<sp/>pointer,<sp/>but</highlight></codeline>
<codeline><highlight class="normal">what<sp/>if<sp/>you<sp/>want<sp/>to<sp/>make<sp/>sure<sp/>the<sp/>value<sp/>*pointed<sp/>to*<sp/>by<sp/>the<sp/>pointer,<sp/>instead<sp/>of</highlight></codeline>
<codeline><highlight class="normal">the<sp/>pointer<sp/>itself,<sp/>has<sp/>a<sp/>certain<sp/>property?<sp/>Well,<sp/>you<sp/>can<sp/>use<sp/>the<sp/>`Pointee(m)`</highlight></codeline>
<codeline><highlight class="normal">matcher.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`Pointee(m)`<sp/>matches<sp/>a<sp/>pointer<sp/>if<sp/>and<sp/>only<sp/>if<sp/>`m`<sp/>matches<sp/>the<sp/>value<sp/>the<sp/>pointer</highlight></codeline>
<codeline><highlight class="normal">points<sp/>to.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Ge;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Pointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Pointee(Ge(3))));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">expects<sp/>`foo.Bar()`<sp/>to<sp/>be<sp/>called<sp/>with<sp/>a<sp/>pointer<sp/>that<sp/>points<sp/>to<sp/>a<sp/>value<sp/>greater</highlight></codeline>
<codeline><highlight class="normal">than<sp/>or<sp/>equal<sp/>to<sp/>3.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">One<sp/>nice<sp/>thing<sp/>about<sp/>`Pointee()`<sp/>is<sp/>that<sp/>it<sp/>treats<sp/>a<sp/>`NULL`<sp/>pointer<sp/>as<sp/>a<sp/>match</highlight></codeline>
<codeline><highlight class="normal">failure,<sp/>so<sp/>you<sp/>can<sp/>write<sp/>`Pointee(m)`<sp/>instead<sp/>of</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Pointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AllOf(NotNull(),<sp/>Pointee(m))</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">without<sp/>worrying<sp/>that<sp/>a<sp/>`NULL`<sp/>pointer<sp/>will<sp/>crash<sp/>your<sp/>test.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Also,<sp/>did<sp/>we<sp/>tell<sp/>you<sp/>that<sp/>`Pointee()`<sp/>works<sp/>with<sp/>both<sp/>raw<sp/>pointers<sp/>**and**</highlight></codeline>
<codeline><highlight class="normal">smart<sp/>pointers<sp/>(`std::unique_ptr`,<sp/>`std::shared_ptr`,<sp/>etc)?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>you<sp/>have<sp/>a<sp/>pointer<sp/>to<sp/>pointer?<sp/>You<sp/>guessed<sp/>it<sp/>-<sp/>you<sp/>can<sp/>use<sp/>nested</highlight></codeline>
<codeline><highlight class="normal">`Pointee()`<sp/>to<sp/>probe<sp/>deeper<sp/>inside<sp/>the<sp/>value.<sp/>For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">`Pointee(Pointee(Lt(3)))`<sp/>matches<sp/>a<sp/>pointer<sp/>that<sp/>points<sp/>to<sp/>a<sp/>pointer<sp/>that<sp/>points</highlight></codeline>
<codeline><highlight class="normal">to<sp/>a<sp/>number<sp/>less<sp/>than<sp/>3<sp/>(what<sp/>a<sp/>mouthful...).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Defining<sp/>a<sp/>Custom<sp/>Matcher<sp/>Class<sp/>{#CustomMatcherClass}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Most<sp/>matchers<sp/>can<sp/>be<sp/>simply<sp/>defined<sp/>using<sp/>[the<sp/>MATCHER*<sp/>macros](#NewMatchers),</highlight></codeline>
<codeline><highlight class="normal">which<sp/>are<sp/>terse<sp/>and<sp/>flexible,<sp/>and<sp/>produce<sp/>good<sp/>error<sp/>messages.<sp/>However,<sp/>these</highlight></codeline>
<codeline><highlight class="normal">macros<sp/>are<sp/>not<sp/>very<sp/>explicit<sp/>about<sp/>the<sp/>interfaces<sp/>they<sp/>create<sp/>and<sp/>are<sp/>not<sp/>always</highlight></codeline>
<codeline><highlight class="normal">suitable,<sp/>especially<sp/>for<sp/>matchers<sp/>that<sp/>will<sp/>be<sp/>widely<sp/>reused.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>more<sp/>advanced<sp/>cases,<sp/>you<sp/>may<sp/>need<sp/>to<sp/>define<sp/>your<sp/>own<sp/>matcher<sp/>class.<sp/>A<sp/>custom</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>allows<sp/>you<sp/>to<sp/>test<sp/>a<sp/>specific<sp/>invariant<sp/>property<sp/>of<sp/>that<sp/>object.<sp/>Let&apos;s</highlight></codeline>
<codeline><highlight class="normal">take<sp/>a<sp/>look<sp/>at<sp/>how<sp/>to<sp/>do<sp/>so.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Imagine<sp/>you<sp/>have<sp/>a<sp/>mock<sp/>function<sp/>that<sp/>takes<sp/>an<sp/>object<sp/>of<sp/>type<sp/>`Foo`,<sp/>which<sp/>has</highlight></codeline>
<codeline><highlight class="normal">an<sp/>`int<sp/>bar()`<sp/>method<sp/>and<sp/>an<sp/>`int<sp/>baz()`<sp/>method.<sp/>You<sp/>want<sp/>to<sp/>constrain<sp/>that<sp/>the</highlight></codeline>
<codeline><highlight class="normal">argument&apos;s<sp/>`bar()`<sp/>value<sp/>plus<sp/>its<sp/>`baz()`<sp/>value<sp/>is<sp/>a<sp/>given<sp/>number.<sp/>(This<sp/>is<sp/>an</highlight></codeline>
<codeline><highlight class="normal">invariant.)<sp/>Here&apos;s<sp/>how<sp/>we<sp/>can<sp/>write<sp/>and<sp/>use<sp/>a<sp/>matcher<sp/>class<sp/>to<sp/>do<sp/>so:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>BarPlusBazEqMatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>is_gtest_matcher<sp/>=<sp/>void;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>explicit<sp/>BarPlusBazEqMatcher(int<sp/>expected_sum)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>expected_sum_(expected_sum)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>MatchAndExplain(const<sp/>Foo&amp;<sp/>foo,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ostream*<sp/>/*<sp/>listener<sp/>*/)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(foo.bar()<sp/>+<sp/>foo.baz())<sp/>==<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeTo(std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;bar()<sp/>+<sp/>baz()<sp/>equals<sp/>&quot;<sp/>&lt;&lt;<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeNegationTo(std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;bar()<sp/>+<sp/>baz()<sp/>does<sp/>not<sp/>equal<sp/>&quot;<sp/>&lt;&lt;<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>expected_sum_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">::testing::Matcher&lt;const<sp/>Foo&amp;&gt;<sp/>BarPlusBazEq(int<sp/>expected_sum)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>BarPlusBazEqMatcher(expected_sum);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(foo,<sp/>BarPlusBazEq(5))...;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Matching<sp/>Containers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>an<sp/>STL<sp/>container<sp/>(e.g.<sp/>list,<sp/>vector,<sp/>map,<sp/>...)<sp/>is<sp/>passed<sp/>to<sp/>a<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">function<sp/>and<sp/>you<sp/>may<sp/>want<sp/>to<sp/>validate<sp/>it.<sp/>Since<sp/>most<sp/>STL<sp/>containers<sp/>support<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`==`<sp/>operator,<sp/>you<sp/>can<sp/>write<sp/>`Eq(expected_container)`<sp/>or<sp/>simply</highlight></codeline>
<codeline><highlight class="normal">`expected_container`<sp/>to<sp/>match<sp/>a<sp/>container<sp/>exactly.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes,<sp/>though,<sp/>you<sp/>may<sp/>want<sp/>to<sp/>be<sp/>more<sp/>flexible<sp/>(for<sp/>example,<sp/>the<sp/>first</highlight></codeline>
<codeline><highlight class="normal">element<sp/>must<sp/>be<sp/>an<sp/>exact<sp/>match,<sp/>but<sp/>the<sp/>second<sp/>element<sp/>can<sp/>be<sp/>any<sp/>positive</highlight></codeline>
<codeline><highlight class="normal">number,<sp/>and<sp/>so<sp/>on).<sp/>Also,<sp/>containers<sp/>used<sp/>in<sp/>tests<sp/>often<sp/>have<sp/>a<sp/>small<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal">elements,<sp/>and<sp/>having<sp/>to<sp/>define<sp/>the<sp/>expected<sp/>container<sp/>out-of-line<sp/>is<sp/>a<sp/>bit<sp/>of<sp/>a</highlight></codeline>
<codeline><highlight class="normal">hassle.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>use<sp/>the<sp/>`ElementsAre()`<sp/>or<sp/>`UnorderedElementsAre()`<sp/>matcher<sp/>in<sp/>such</highlight></codeline>
<codeline><highlight class="normal">cases:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ElementsAre;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Foo,<sp/>(const<sp/>vector&lt;int&gt;&amp;<sp/>numbers),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAre(1,<sp/>Gt(0),<sp/>_,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>above<sp/>matcher<sp/>says<sp/>that<sp/>the<sp/>container<sp/>must<sp/>have<sp/>4<sp/>elements,<sp/>which<sp/>must<sp/>be<sp/>1,</highlight></codeline>
<codeline><highlight class="normal">greater<sp/>than<sp/>0,<sp/>anything,<sp/>and<sp/>5<sp/>respectively.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>instead<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::UnorderedElementsAre;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Foo,<sp/>(const<sp/>vector&lt;int&gt;&amp;<sp/>numbers),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(UnorderedElementsAre(1,<sp/>Gt(0),<sp/>_,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It<sp/>means<sp/>that<sp/>the<sp/>container<sp/>must<sp/>have<sp/>4<sp/>elements,<sp/>which<sp/>(under<sp/>some<sp/>permutation)</highlight></codeline>
<codeline><highlight class="normal">must<sp/>be<sp/>1,<sp/>greater<sp/>than<sp/>0,<sp/>anything,<sp/>and<sp/>5<sp/>respectively.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>an<sp/>alternative<sp/>you<sp/>can<sp/>place<sp/>the<sp/>arguments<sp/>in<sp/>a<sp/>C-style<sp/>array<sp/>and<sp/>use</highlight></codeline>
<codeline><highlight class="normal">`ElementsAreArray()`<sp/>or<sp/>`UnorderedElementsAreArray()`<sp/>instead:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ElementsAreArray;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>ElementsAreArray<sp/>accepts<sp/>an<sp/>array<sp/>of<sp/>element<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>expected_vector1[]<sp/>=<sp/>{1,<sp/>5,<sp/>2,<sp/>4,<sp/>...};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector1)));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Or,<sp/>an<sp/>array<sp/>of<sp/>element<sp/>matchers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matcher&lt;int&gt;<sp/>expected_vector2[]<sp/>=<sp/>{1,<sp/>Gt(2),<sp/>_,<sp/>3,<sp/>...};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector2)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>case<sp/>the<sp/>array<sp/>needs<sp/>to<sp/>be<sp/>dynamically<sp/>created<sp/>(and<sp/>therefore<sp/>the<sp/>array<sp/>size</highlight></codeline>
<codeline><highlight class="normal">cannot<sp/>be<sp/>inferred<sp/>by<sp/>the<sp/>compiler),<sp/>you<sp/>can<sp/>give<sp/>`ElementsAreArray()`<sp/>an</highlight></codeline>
<codeline><highlight class="normal">additional<sp/>argument<sp/>to<sp/>specify<sp/>the<sp/>array<sp/>size:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ElementsAreArray;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>const<sp/>expected_vector3<sp/>=<sp/>new<sp/>int[count];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>fill<sp/>expected_vector3<sp/>with<sp/>values<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(ElementsAreArray(expected_vector3,<sp/>count)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Use<sp/>`Pair`<sp/>when<sp/>comparing<sp/>maps<sp/>or<sp/>other<sp/>associative<sp/>containers.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{%<sp/>raw<sp/>%}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::UnorderedElementsAre;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Pair;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>absl::flat_hash_map&lt;string,<sp/>int&gt;<sp/>m<sp/>=<sp/>{{&quot;a&quot;,<sp/>1},<sp/>{&quot;b&quot;,<sp/>2},<sp/>{&quot;c&quot;,<sp/>3}};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(m,<sp/>UnorderedElementsAre(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Pair(&quot;a&quot;,<sp/>1),<sp/>Pair(&quot;b&quot;,<sp/>2),<sp/>Pair(&quot;c&quot;,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{%<sp/>endraw<sp/>%}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Tips:**</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>`ElementsAre*()`<sp/>can<sp/>be<sp/>used<sp/>to<sp/>match<sp/>*any*<sp/>container<sp/>that<sp/>implements<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>STL<sp/>iterator<sp/>pattern<sp/>(i.e.<sp/>it<sp/>has<sp/>a<sp/>`const_iterator`<sp/>type<sp/>and<sp/>supports</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`begin()/end()`),<sp/>not<sp/>just<sp/>the<sp/>ones<sp/>defined<sp/>in<sp/>STL.<sp/>It<sp/>will<sp/>even<sp/>work<sp/>with</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>container<sp/>types<sp/>yet<sp/>to<sp/>be<sp/>written<sp/>-<sp/>as<sp/>long<sp/>as<sp/>they<sp/>follows<sp/>the<sp/>above</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pattern.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>You<sp/>can<sp/>use<sp/>nested<sp/>`ElementsAre*()`<sp/>to<sp/>match<sp/>nested<sp/>(multi-dimensional)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>containers.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>If<sp/>the<sp/>container<sp/>is<sp/>passed<sp/>by<sp/>pointer<sp/>instead<sp/>of<sp/>by<sp/>reference,<sp/>just<sp/>write</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`Pointee(ElementsAre*(...))`.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>The<sp/>order<sp/>of<sp/>elements<sp/>*matters*<sp/>for<sp/>`ElementsAre*()`.<sp/>If<sp/>you<sp/>are<sp/>using<sp/>it</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>with<sp/>containers<sp/>whose<sp/>element<sp/>order<sp/>are<sp/>undefined<sp/>(such<sp/>as<sp/>a</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`std::unordered_map`)<sp/>you<sp/>should<sp/>use<sp/>`UnorderedElementsAre`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Sharing<sp/>Matchers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Under<sp/>the<sp/>hood,<sp/>a<sp/>gMock<sp/>matcher<sp/>object<sp/>consists<sp/>of<sp/>a<sp/>pointer<sp/>to<sp/>a<sp/>ref-counted</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>object.<sp/>Copying<sp/>matchers<sp/>is<sp/>allowed<sp/>and<sp/>very<sp/>efficient,<sp/>as<sp/>only</highlight></codeline>
<codeline><highlight class="normal">the<sp/>pointer<sp/>is<sp/>copied.<sp/>When<sp/>the<sp/>last<sp/>matcher<sp/>that<sp/>references<sp/>the<sp/>implementation</highlight></codeline>
<codeline><highlight class="normal">object<sp/>dies,<sp/>the<sp/>implementation<sp/>object<sp/>will<sp/>be<sp/>deleted.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Therefore,<sp/>if<sp/>you<sp/>have<sp/>some<sp/>complex<sp/>matcher<sp/>that<sp/>you<sp/>want<sp/>to<sp/>use<sp/>again<sp/>and</highlight></codeline>
<codeline><highlight class="normal">again,<sp/>there<sp/>is<sp/>no<sp/>need<sp/>to<sp/>build<sp/>it<sp/>every<sp/>time.<sp/>Just<sp/>assign<sp/>it<sp/>to<sp/>a<sp/>matcher</highlight></codeline>
<codeline><highlight class="normal">variable<sp/>and<sp/>use<sp/>that<sp/>variable<sp/>repeatedly!<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AllOf;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Le;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matcher&lt;int&gt;<sp/>in_range<sp/>=<sp/>AllOf(Gt(5),<sp/>Le(10));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>in_range<sp/>as<sp/>a<sp/>matcher<sp/>in<sp/>multiple<sp/>EXPECT_CALLs<sp/>...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Matchers<sp/>must<sp/>have<sp/>no<sp/>side-effects<sp/>{#PureMatchers}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.warning}</highlight></codeline>
<codeline><highlight class="normal">WARNING:<sp/>gMock<sp/>does<sp/>not<sp/>guarantee<sp/>when<sp/>or<sp/>how<sp/>many<sp/>times<sp/>a<sp/>matcher<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">invoked.<sp/>Therefore,<sp/>all<sp/>matchers<sp/>must<sp/>be<sp/>*purely<sp/>functional*:<sp/>they<sp/>cannot<sp/>have</highlight></codeline>
<codeline><highlight class="normal">any<sp/>side<sp/>effects,<sp/>and<sp/>the<sp/>match<sp/>result<sp/>must<sp/>not<sp/>depend<sp/>on<sp/>anything<sp/>other<sp/>than</highlight></codeline>
<codeline><highlight class="normal">the<sp/>matcher&apos;s<sp/>parameters<sp/>and<sp/>the<sp/>value<sp/>being<sp/>matched.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>requirement<sp/>must<sp/>be<sp/>satisfied<sp/>no<sp/>matter<sp/>how<sp/>a<sp/>matcher<sp/>is<sp/>defined<sp/>(e.g.,<sp/>if</highlight></codeline>
<codeline><highlight class="normal">it<sp/>is<sp/>one<sp/>of<sp/>the<sp/>standard<sp/>matchers,<sp/>or<sp/>a<sp/>custom<sp/>matcher).<sp/>In<sp/>particular,<sp/>a</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>can<sp/>never<sp/>call<sp/>a<sp/>mock<sp/>function,<sp/>as<sp/>that<sp/>will<sp/>affect<sp/>the<sp/>state<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>object<sp/>and<sp/>gMock.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Setting<sp/>Expectations</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Knowing<sp/>When<sp/>to<sp/>Expect<sp/>{#UseOnCall}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**`ON_CALL`**<sp/>is<sp/>likely<sp/>the<sp/>*single<sp/>most<sp/>under-utilized<sp/>construct*<sp/>in<sp/>gMock.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">There<sp/>are<sp/>basically<sp/>two<sp/>constructs<sp/>for<sp/>defining<sp/>the<sp/>behavior<sp/>of<sp/>a<sp/>mock<sp/>object:</highlight></codeline>
<codeline><highlight class="normal">`ON_CALL`<sp/>and<sp/>`EXPECT_CALL`.<sp/>The<sp/>difference?<sp/>`ON_CALL`<sp/>defines<sp/>what<sp/>happens<sp/>when</highlight></codeline>
<codeline><highlight class="normal">a<sp/>mock<sp/>method<sp/>is<sp/>called,<sp/>but<sp/>&lt;em&gt;doesn&apos;t<sp/>imply<sp/>any<sp/>expectation<sp/>on<sp/>the<sp/>method</highlight></codeline>
<codeline><highlight class="normal">being<sp/>called&lt;/em&gt;.<sp/>`EXPECT_CALL`<sp/>not<sp/>only<sp/>defines<sp/>the<sp/>behavior,<sp/>but<sp/>also<sp/>sets<sp/>an</highlight></codeline>
<codeline><highlight class="normal">expectation<sp/>that<sp/>&lt;em&gt;the<sp/>method<sp/>will<sp/>be<sp/>called<sp/>with<sp/>the<sp/>given<sp/>arguments,<sp/>for<sp/>the</highlight></codeline>
<codeline><highlight class="normal">given<sp/>number<sp/>of<sp/>times&lt;/em&gt;<sp/>(and<sp/>*in<sp/>the<sp/>given<sp/>order*<sp/>when<sp/>you<sp/>specify<sp/>the<sp/>order</highlight></codeline>
<codeline><highlight class="normal">too).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Since<sp/>`EXPECT_CALL`<sp/>does<sp/>more,<sp/>isn&apos;t<sp/>it<sp/>better<sp/>than<sp/>`ON_CALL`?<sp/>Not<sp/>really.<sp/>Every</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL`<sp/>adds<sp/>a<sp/>constraint<sp/>on<sp/>the<sp/>behavior<sp/>of<sp/>the<sp/>code<sp/>under<sp/>test.<sp/>Having</highlight></codeline>
<codeline><highlight class="normal">more<sp/>constraints<sp/>than<sp/>necessary<sp/>is<sp/>*baaad*<sp/>-<sp/>even<sp/>worse<sp/>than<sp/>not<sp/>having<sp/>enough</highlight></codeline>
<codeline><highlight class="normal">constraints.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>may<sp/>be<sp/>counter-intuitive.<sp/>How<sp/>could<sp/>tests<sp/>that<sp/>verify<sp/>more<sp/>be<sp/>worse<sp/>than</highlight></codeline>
<codeline><highlight class="normal">tests<sp/>that<sp/>verify<sp/>less?<sp/>Isn&apos;t<sp/>verification<sp/>the<sp/>whole<sp/>point<sp/>of<sp/>tests?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>answer<sp/>lies<sp/>in<sp/>*what*<sp/>a<sp/>test<sp/>should<sp/>verify.<sp/>**A<sp/>good<sp/>test<sp/>verifies<sp/>the</highlight></codeline>
<codeline><highlight class="normal">contract<sp/>of<sp/>the<sp/>code.**<sp/>If<sp/>a<sp/>test<sp/>over-specifies,<sp/>it<sp/>doesn&apos;t<sp/>leave<sp/>enough</highlight></codeline>
<codeline><highlight class="normal">freedom<sp/>to<sp/>the<sp/>implementation.<sp/>As<sp/>a<sp/>result,<sp/>changing<sp/>the<sp/>implementation<sp/>without</highlight></codeline>
<codeline><highlight class="normal">breaking<sp/>the<sp/>contract<sp/>(e.g.<sp/>refactoring<sp/>and<sp/>optimization),<sp/>which<sp/>should<sp/>be</highlight></codeline>
<codeline><highlight class="normal">perfectly<sp/>fine<sp/>to<sp/>do,<sp/>can<sp/>break<sp/>such<sp/>tests.<sp/>Then<sp/>you<sp/>have<sp/>to<sp/>spend<sp/>time<sp/>fixing</highlight></codeline>
<codeline><highlight class="normal">them,<sp/>only<sp/>to<sp/>see<sp/>them<sp/>broken<sp/>again<sp/>the<sp/>next<sp/>time<sp/>the<sp/>implementation<sp/>is<sp/>changed.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Keep<sp/>in<sp/>mind<sp/>that<sp/>one<sp/>doesn&apos;t<sp/>have<sp/>to<sp/>verify<sp/>more<sp/>than<sp/>one<sp/>property<sp/>in<sp/>one<sp/>test.</highlight></codeline>
<codeline><highlight class="normal">In<sp/>fact,<sp/>**it&apos;s<sp/>a<sp/>good<sp/>style<sp/>to<sp/>verify<sp/>only<sp/>one<sp/>thing<sp/>in<sp/>one<sp/>test.**<sp/>If<sp/>you<sp/>do</highlight></codeline>
<codeline><highlight class="normal">that,<sp/>a<sp/>bug<sp/>will<sp/>likely<sp/>break<sp/>only<sp/>one<sp/>or<sp/>two<sp/>tests<sp/>instead<sp/>of<sp/>dozens<sp/>(which</highlight></codeline>
<codeline><highlight class="normal">case<sp/>would<sp/>you<sp/>rather<sp/>debug?).<sp/>If<sp/>you<sp/>are<sp/>also<sp/>in<sp/>the<sp/>habit<sp/>of<sp/>giving<sp/>tests</highlight></codeline>
<codeline><highlight class="normal">descriptive<sp/>names<sp/>that<sp/>tell<sp/>what<sp/>they<sp/>verify,<sp/>you<sp/>can<sp/>often<sp/>easily<sp/>guess<sp/>what&apos;s</highlight></codeline>
<codeline><highlight class="normal">wrong<sp/>just<sp/>from<sp/>the<sp/>test<sp/>log<sp/>itself.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">So<sp/>use<sp/>`ON_CALL`<sp/>by<sp/>default,<sp/>and<sp/>only<sp/>use<sp/>`EXPECT_CALL`<sp/>when<sp/>you<sp/>actually<sp/>intend</highlight></codeline>
<codeline><highlight class="normal">to<sp/>verify<sp/>that<sp/>the<sp/>call<sp/>is<sp/>made.<sp/>For<sp/>example,<sp/>you<sp/>may<sp/>have<sp/>a<sp/>bunch<sp/>of<sp/>`ON_CALL`s</highlight></codeline>
<codeline><highlight class="normal">in<sp/>your<sp/>test<sp/>fixture<sp/>to<sp/>set<sp/>the<sp/>common<sp/>mock<sp/>behavior<sp/>shared<sp/>by<sp/>all<sp/>tests<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">same<sp/>group,<sp/>and<sp/>write<sp/>(scarcely)<sp/>different<sp/>`EXPECT_CALL`s<sp/>in<sp/>different<sp/>`TEST_F`s</highlight></codeline>
<codeline><highlight class="normal">to<sp/>verify<sp/>different<sp/>aspects<sp/>of<sp/>the<sp/>code&apos;s<sp/>behavior.<sp/>Compared<sp/>with<sp/>the<sp/>style</highlight></codeline>
<codeline><highlight class="normal">where<sp/>each<sp/>`TEST`<sp/>has<sp/>many<sp/>`EXPECT_CALL`s,<sp/>this<sp/>leads<sp/>to<sp/>tests<sp/>that<sp/>are<sp/>more</highlight></codeline>
<codeline><highlight class="normal">resilient<sp/>to<sp/>implementational<sp/>changes<sp/>(and<sp/>thus<sp/>less<sp/>likely<sp/>to<sp/>require</highlight></codeline>
<codeline><highlight class="normal">maintenance)<sp/>and<sp/>makes<sp/>the<sp/>intent<sp/>of<sp/>the<sp/>tests<sp/>more<sp/>obvious<sp/>(so<sp/>they<sp/>are<sp/>easier</highlight></codeline>
<codeline><highlight class="normal">to<sp/>maintain<sp/>when<sp/>you<sp/>do<sp/>need<sp/>to<sp/>maintain<sp/>them).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>bothered<sp/>by<sp/>the<sp/>&quot;Uninteresting<sp/>mock<sp/>function<sp/>call&quot;<sp/>message<sp/>printed</highlight></codeline>
<codeline><highlight class="normal">when<sp/>a<sp/>mock<sp/>method<sp/>without<sp/>an<sp/>`EXPECT_CALL`<sp/>is<sp/>called,<sp/>you<sp/>may<sp/>use<sp/>a<sp/>`NiceMock`</highlight></codeline>
<codeline><highlight class="normal">instead<sp/>to<sp/>suppress<sp/>all<sp/>such<sp/>messages<sp/>for<sp/>the<sp/>mock<sp/>object,<sp/>or<sp/>suppress<sp/>the</highlight></codeline>
<codeline><highlight class="normal">message<sp/>for<sp/>specific<sp/>methods<sp/>by<sp/>adding<sp/>`EXPECT_CALL(...).Times(AnyNumber())`.<sp/>DO</highlight></codeline>
<codeline><highlight class="normal">NOT<sp/>suppress<sp/>it<sp/>by<sp/>blindly<sp/>adding<sp/>an<sp/>`EXPECT_CALL(...)`,<sp/>or<sp/>you&apos;ll<sp/>have<sp/>a<sp/>test</highlight></codeline>
<codeline><highlight class="normal">that&apos;s<sp/>a<sp/>pain<sp/>to<sp/>maintain.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Ignoring<sp/>Uninteresting<sp/>Calls</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>not<sp/>interested<sp/>in<sp/>how<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>called,<sp/>just<sp/>don&apos;t<sp/>say</highlight></codeline>
<codeline><highlight class="normal">anything<sp/>about<sp/>it.<sp/>In<sp/>this<sp/>case,<sp/>if<sp/>the<sp/>method<sp/>is<sp/>ever<sp/>called,<sp/>gMock<sp/>will</highlight></codeline>
<codeline><highlight class="normal">perform<sp/>its<sp/>default<sp/>action<sp/>to<sp/>allow<sp/>the<sp/>test<sp/>program<sp/>to<sp/>continue.<sp/>If<sp/>you<sp/>are<sp/>not</highlight></codeline>
<codeline><highlight class="normal">happy<sp/>with<sp/>the<sp/>default<sp/>action<sp/>taken<sp/>by<sp/>gMock,<sp/>you<sp/>can<sp/>override<sp/>it<sp/>using</highlight></codeline>
<codeline><highlight class="normal">`DefaultValue&lt;T&gt;::Set()`<sp/>(described<sp/>[here](#DefaultValue))<sp/>or<sp/>`ON_CALL()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Please<sp/>note<sp/>that<sp/>once<sp/>you<sp/>expressed<sp/>interest<sp/>in<sp/>a<sp/>particular<sp/>mock<sp/>method<sp/>(via</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL()`),<sp/>all<sp/>invocations<sp/>to<sp/>it<sp/>must<sp/>match<sp/>some<sp/>expectation.<sp/>If<sp/>this</highlight></codeline>
<codeline><highlight class="normal">function<sp/>is<sp/>called<sp/>but<sp/>the<sp/>arguments<sp/>don&apos;t<sp/>match<sp/>any<sp/>`EXPECT_CALL()`<sp/>statement,</highlight></codeline>
<codeline><highlight class="normal">it<sp/>will<sp/>be<sp/>an<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Disallowing<sp/>Unexpected<sp/>Calls</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>mock<sp/>method<sp/>shouldn&apos;t<sp/>be<sp/>called<sp/>at<sp/>all,<sp/>explicitly<sp/>say<sp/>so:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(0);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>some<sp/>calls<sp/>to<sp/>the<sp/>method<sp/>are<sp/>allowed,<sp/>but<sp/>the<sp/>rest<sp/>are<sp/>not,<sp/>just<sp/>list<sp/>all<sp/>the</highlight></codeline>
<codeline><highlight class="normal">expected<sp/>calls:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AnyNumber;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(Gt(10)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>call<sp/>to<sp/>`foo.Bar()`<sp/>that<sp/>doesn&apos;t<sp/>match<sp/>any<sp/>of<sp/>the<sp/>`EXPECT_CALL()`<sp/>statements</highlight></codeline>
<codeline><highlight class="normal">will<sp/>be<sp/>an<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Understanding<sp/>Uninteresting<sp/>vs<sp/>Unexpected<sp/>Calls<sp/>{#uninteresting-vs-unexpected}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*Uninteresting*<sp/>calls<sp/>and<sp/>*unexpected*<sp/>calls<sp/>are<sp/>different<sp/>concepts<sp/>in<sp/>gMock.</highlight></codeline>
<codeline><highlight class="normal">*Very*<sp/>different.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>call<sp/>`x.Y(...)`<sp/>is<sp/>**uninteresting**<sp/>if<sp/>there&apos;s<sp/>*not<sp/>even<sp/>a<sp/>single*</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL(x,<sp/>Y(...))`<sp/>set.<sp/>In<sp/>other<sp/>words,<sp/>the<sp/>test<sp/>isn&apos;t<sp/>interested<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`x.Y()`<sp/>method<sp/>at<sp/>all,<sp/>as<sp/>evident<sp/>in<sp/>that<sp/>the<sp/>test<sp/>doesn&apos;t<sp/>care<sp/>to<sp/>say<sp/>anything</highlight></codeline>
<codeline><highlight class="normal">about<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>call<sp/>`x.Y(...)`<sp/>is<sp/>**unexpected**<sp/>if<sp/>there<sp/>are<sp/>*some*<sp/>`EXPECT_CALL(x,</highlight></codeline>
<codeline><highlight class="normal">Y(...))`s<sp/>set,<sp/>but<sp/>none<sp/>of<sp/>them<sp/>matches<sp/>the<sp/>call.<sp/>Put<sp/>another<sp/>way,<sp/>the<sp/>test<sp/>is</highlight></codeline>
<codeline><highlight class="normal">interested<sp/>in<sp/>the<sp/>`x.Y()`<sp/>method<sp/>(therefore<sp/>it<sp/>explicitly<sp/>sets<sp/>some</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL`<sp/>to<sp/>verify<sp/>how<sp/>it&apos;s<sp/>called);<sp/>however,<sp/>the<sp/>verification<sp/>fails<sp/>as<sp/>the</highlight></codeline>
<codeline><highlight class="normal">test<sp/>doesn&apos;t<sp/>expect<sp/>this<sp/>particular<sp/>call<sp/>to<sp/>happen.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**An<sp/>unexpected<sp/>call<sp/>is<sp/>always<sp/>an<sp/>error,**<sp/>as<sp/>the<sp/>code<sp/>under<sp/>test<sp/>doesn&apos;t<sp/>behave</highlight></codeline>
<codeline><highlight class="normal">the<sp/>way<sp/>the<sp/>test<sp/>expects<sp/>it<sp/>to<sp/>behave.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**By<sp/>default,<sp/>an<sp/>uninteresting<sp/>call<sp/>is<sp/>not<sp/>an<sp/>error,**<sp/>as<sp/>it<sp/>violates<sp/>no</highlight></codeline>
<codeline><highlight class="normal">constraint<sp/>specified<sp/>by<sp/>the<sp/>test.<sp/>(gMock&apos;s<sp/>philosophy<sp/>is<sp/>that<sp/>saying<sp/>nothing</highlight></codeline>
<codeline><highlight class="normal">means<sp/>there<sp/>is<sp/>no<sp/>constraint.)<sp/>However,<sp/>it<sp/>leads<sp/>to<sp/>a<sp/>warning,<sp/>as<sp/>it<sp/>*might*</highlight></codeline>
<codeline><highlight class="normal">indicate<sp/>a<sp/>problem<sp/>(e.g.<sp/>the<sp/>test<sp/>author<sp/>might<sp/>have<sp/>forgotten<sp/>to<sp/>specify<sp/>a</highlight></codeline>
<codeline><highlight class="normal">constraint).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>gMock,<sp/>`NiceMock`<sp/>and<sp/>`StrictMock`<sp/>can<sp/>be<sp/>used<sp/>to<sp/>make<sp/>a<sp/>mock<sp/>class<sp/>&quot;nice&quot;<sp/>or</highlight></codeline>
<codeline><highlight class="normal">&quot;strict&quot;.<sp/>How<sp/>does<sp/>this<sp/>affect<sp/>uninteresting<sp/>calls<sp/>and<sp/>unexpected<sp/>calls?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>**nice<sp/>mock**<sp/>suppresses<sp/>uninteresting<sp/>call<sp/>*warnings*.<sp/>It<sp/>is<sp/>less<sp/>chatty<sp/>than</highlight></codeline>
<codeline><highlight class="normal">the<sp/>default<sp/>mock,<sp/>but<sp/>otherwise<sp/>is<sp/>the<sp/>same.<sp/>If<sp/>a<sp/>test<sp/>fails<sp/>with<sp/>a<sp/>default</highlight></codeline>
<codeline><highlight class="normal">mock,<sp/>it<sp/>will<sp/>also<sp/>fail<sp/>using<sp/>a<sp/>nice<sp/>mock<sp/>instead.<sp/>And<sp/>vice<sp/>versa.<sp/>Don&apos;t<sp/>expect</highlight></codeline>
<codeline><highlight class="normal">making<sp/>a<sp/>mock<sp/>nice<sp/>to<sp/>change<sp/>the<sp/>test&apos;s<sp/>result.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>**strict<sp/>mock**<sp/>turns<sp/>uninteresting<sp/>call<sp/>warnings<sp/>into<sp/>errors.<sp/>So<sp/>making<sp/>a</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>strict<sp/>may<sp/>change<sp/>the<sp/>test&apos;s<sp/>result.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Let&apos;s<sp/>look<sp/>at<sp/>an<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">TEST(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NiceMock&lt;MockDomainRegistry&gt;<sp/>mock_registry;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(&quot;google.com&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&quot;Larry<sp/>Page&quot;));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Use<sp/>mock_registry<sp/>in<sp/>code<sp/>under<sp/>test.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>&amp;mock_registry<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>sole<sp/>`EXPECT_CALL`<sp/>here<sp/>says<sp/>that<sp/>all<sp/>calls<sp/>to<sp/>`GetDomainOwner()`<sp/>must<sp/>have</highlight></codeline>
<codeline><highlight class="normal">`&quot;google.com&quot;`<sp/>as<sp/>the<sp/>argument.<sp/>If<sp/>`GetDomainOwner(&quot;yahoo.com&quot;)`<sp/>is<sp/>called,<sp/>it</highlight></codeline>
<codeline><highlight class="normal">will<sp/>be<sp/>an<sp/>unexpected<sp/>call,<sp/>and<sp/>thus<sp/>an<sp/>error.<sp/>*Having<sp/>a<sp/>nice<sp/>mock<sp/>doesn&apos;t</highlight></codeline>
<codeline><highlight class="normal">change<sp/>the<sp/>severity<sp/>of<sp/>an<sp/>unexpected<sp/>call.*</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">So<sp/>how<sp/>do<sp/>we<sp/>tell<sp/>gMock<sp/>that<sp/>`GetDomainOwner()`<sp/>can<sp/>be<sp/>called<sp/>with<sp/>some<sp/>other</highlight></codeline>
<codeline><highlight class="normal">arguments<sp/>as<sp/>well?<sp/>The<sp/>standard<sp/>technique<sp/>is<sp/>to<sp/>add<sp/>a<sp/>&quot;catch<sp/>all&quot;<sp/>`EXPECT_CALL`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());<sp/><sp/>//<sp/>catches<sp/>all<sp/>other<sp/>calls<sp/>to<sp/>this<sp/>method.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_registry,<sp/>GetDomainOwner(&quot;google.com&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(&quot;Larry<sp/>Page&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remember<sp/>that<sp/>`_`<sp/>is<sp/>the<sp/>wildcard<sp/>matcher<sp/>that<sp/>matches<sp/>anything.<sp/>With<sp/>this,<sp/>if</highlight></codeline>
<codeline><highlight class="normal">`GetDomainOwner(&quot;google.com&quot;)`<sp/>is<sp/>called,<sp/>it<sp/>will<sp/>do<sp/>what<sp/>the<sp/>second</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL`<sp/>says;<sp/>if<sp/>it<sp/>is<sp/>called<sp/>with<sp/>a<sp/>different<sp/>argument,<sp/>it<sp/>will<sp/>do<sp/>what</highlight></codeline>
<codeline><highlight class="normal">the<sp/>first<sp/>`EXPECT_CALL`<sp/>says.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>order<sp/>of<sp/>the<sp/>two<sp/>`EXPECT_CALL`s<sp/>is<sp/>important,<sp/>as<sp/>a<sp/>newer</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL`<sp/>takes<sp/>precedence<sp/>over<sp/>an<sp/>older<sp/>one.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>more<sp/>on<sp/>uninteresting<sp/>calls,<sp/>nice<sp/>mocks,<sp/>and<sp/>strict<sp/>mocks,<sp/>read</highlight></codeline>
<codeline><highlight class="normal">[&quot;The<sp/>Nice,<sp/>the<sp/>Strict,<sp/>and<sp/>the<sp/>Naggy&quot;](#NiceStrictNaggy).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Ignoring<sp/>Uninteresting<sp/>Arguments<sp/>{#ParameterlessExpectations}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>your<sp/>test<sp/>doesn&apos;t<sp/>care<sp/>about<sp/>the<sp/>parameters<sp/>(it<sp/>only<sp/>cares<sp/>about<sp/>the<sp/>number</highlight></codeline>
<codeline><highlight class="normal">or<sp/>order<sp/>of<sp/>calls),<sp/>you<sp/>can<sp/>often<sp/>simply<sp/>omit<sp/>the<sp/>parameter<sp/>list:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Expect<sp/>foo.Bar(<sp/>...<sp/>)<sp/>twice<sp/>with<sp/>any<sp/>arguments.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar).Times(2);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Delegate<sp/>to<sp/>the<sp/>given<sp/>method<sp/>whenever<sp/>the<sp/>factory<sp/>is<sp/>invoked.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo_factory,<sp/>MakeFoo)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(&amp;BuildFooForTest);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>functionality<sp/>is<sp/>only<sp/>available<sp/>when<sp/>a<sp/>method<sp/>is<sp/>not<sp/>overloaded;<sp/>to<sp/>prevent</highlight></codeline>
<codeline><highlight class="normal">unexpected<sp/>behavior<sp/>it<sp/>is<sp/>a<sp/>compilation<sp/>error<sp/>to<sp/>try<sp/>to<sp/>set<sp/>an<sp/>expectation<sp/>on<sp/>a</highlight></codeline>
<codeline><highlight class="normal">method<sp/>where<sp/>the<sp/>specific<sp/>overload<sp/>is<sp/>ambiguous.<sp/>You<sp/>can<sp/>work<sp/>around<sp/>this<sp/>by</highlight></codeline>
<codeline><highlight class="normal">supplying<sp/>a<sp/>[simpler<sp/>mock<sp/>interface](#SimplerInterfaces)<sp/>than<sp/>the<sp/>mocked<sp/>class</highlight></codeline>
<codeline><highlight class="normal">provides.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>pattern<sp/>is<sp/>also<sp/>useful<sp/>when<sp/>the<sp/>arguments<sp/>are<sp/>interesting,<sp/>but<sp/>match<sp/>logic</highlight></codeline>
<codeline><highlight class="normal">is<sp/>substantially<sp/>complex.<sp/>You<sp/>can<sp/>leave<sp/>the<sp/>argument<sp/>list<sp/>unspecified<sp/>and<sp/>use</highlight></codeline>
<codeline><highlight class="normal">SaveArg<sp/>actions<sp/>to<sp/>[save<sp/>the<sp/>values<sp/>for<sp/>later<sp/>verification](#SaveArgVerify).<sp/>If</highlight></codeline>
<codeline><highlight class="normal">you<sp/>do<sp/>that,<sp/>you<sp/>can<sp/>easily<sp/>differentiate<sp/>calling<sp/>the<sp/>method<sp/>the<sp/>wrong<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal">times<sp/>from<sp/>calling<sp/>it<sp/>with<sp/>the<sp/>wrong<sp/>arguments.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Expecting<sp/>Ordered<sp/>Calls<sp/>{#OrderedCalls}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Although<sp/>an<sp/>`EXPECT_CALL()`<sp/>statement<sp/>defined<sp/>later<sp/>takes<sp/>precedence<sp/>when<sp/>gMock</highlight></codeline>
<codeline><highlight class="normal">tries<sp/>to<sp/>match<sp/>a<sp/>function<sp/>call<sp/>with<sp/>an<sp/>expectation,<sp/>by<sp/>default<sp/>calls<sp/>don&apos;t<sp/>have</highlight></codeline>
<codeline><highlight class="normal">to<sp/>happen<sp/>in<sp/>the<sp/>order<sp/>`EXPECT_CALL()`<sp/>statements<sp/>are<sp/>written.<sp/>For<sp/>example,<sp/>if</highlight></codeline>
<codeline><highlight class="normal">the<sp/>arguments<sp/>match<sp/>the<sp/>matchers<sp/>in<sp/>the<sp/>second<sp/>`EXPECT_CALL()`,<sp/>but<sp/>not<sp/>those<sp/>in</highlight></codeline>
<codeline><highlight class="normal">the<sp/>first<sp/>and<sp/>third,<sp/>then<sp/>the<sp/>second<sp/>expectation<sp/>will<sp/>be<sp/>used.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>would<sp/>rather<sp/>have<sp/>all<sp/>calls<sp/>occur<sp/>in<sp/>the<sp/>order<sp/>of<sp/>the<sp/>expectations,<sp/>put</highlight></codeline>
<codeline><highlight class="normal">the<sp/>`EXPECT_CALL()`<sp/>statements<sp/>in<sp/>a<sp/>block<sp/>where<sp/>you<sp/>define<sp/>a<sp/>variable<sp/>of<sp/>type</highlight></codeline>
<codeline><highlight class="normal">`InSequence`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InSequence;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(bar,<sp/>DoThat(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.Times(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>this<sp/>example,<sp/>we<sp/>expect<sp/>a<sp/>call<sp/>to<sp/>`foo.DoThis(5)`,<sp/>followed<sp/>by<sp/>two<sp/>calls<sp/>to</highlight></codeline>
<codeline><highlight class="normal">`bar.DoThat()`<sp/>where<sp/>the<sp/>argument<sp/>can<sp/>be<sp/>anything,<sp/>which<sp/>are<sp/>in<sp/>turn<sp/>followed<sp/>by</highlight></codeline>
<codeline><highlight class="normal">a<sp/>call<sp/>to<sp/>`foo.DoThis(6)`.<sp/>If<sp/>a<sp/>call<sp/>occurred<sp/>out-of-order,<sp/>gMock<sp/>will<sp/>report<sp/>an</highlight></codeline>
<codeline><highlight class="normal">error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Expecting<sp/>Partially<sp/>Ordered<sp/>Calls<sp/>{#PartialOrder}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>requiring<sp/>everything<sp/>to<sp/>occur<sp/>in<sp/>a<sp/>predetermined<sp/>order<sp/>can<sp/>lead<sp/>to</highlight></codeline>
<codeline><highlight class="normal">brittle<sp/>tests.<sp/>For<sp/>example,<sp/>we<sp/>may<sp/>care<sp/>about<sp/>`A`<sp/>occurring<sp/>before<sp/>both<sp/>`B`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`C`,<sp/>but<sp/>aren&apos;t<sp/>interested<sp/>in<sp/>the<sp/>relative<sp/>order<sp/>of<sp/>`B`<sp/>and<sp/>`C`.<sp/>In<sp/>this<sp/>case,</highlight></codeline>
<codeline><highlight class="normal">the<sp/>test<sp/>should<sp/>reflect<sp/>our<sp/>real<sp/>intent,<sp/>instead<sp/>of<sp/>being<sp/>overly<sp/>constraining.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>allows<sp/>you<sp/>to<sp/>impose<sp/>an<sp/>arbitrary<sp/>DAG<sp/>(directed<sp/>acyclic<sp/>graph)<sp/>on<sp/>the</highlight></codeline>
<codeline><highlight class="normal">calls.<sp/>One<sp/>way<sp/>to<sp/>express<sp/>the<sp/>DAG<sp/>is<sp/>to<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">[`After`<sp/>clause](reference/mocking.md#EXPECT_CALL.After)<sp/>of<sp/>`EXPECT_CALL`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Another<sp/>way<sp/>is<sp/>via<sp/>the<sp/>`InSequence()`<sp/>clause<sp/>(not<sp/>the<sp/>same<sp/>as<sp/>the<sp/>`InSequence`</highlight></codeline>
<codeline><highlight class="normal">class),<sp/>which<sp/>we<sp/>borrowed<sp/>from<sp/>jMock<sp/>2.<sp/>It&apos;s<sp/>less<sp/>flexible<sp/>than<sp/>`After()`,<sp/>but</highlight></codeline>
<codeline><highlight class="normal">more<sp/>convenient<sp/>when<sp/>you<sp/>have<sp/>long<sp/>chains<sp/>of<sp/>sequential<sp/>calls,<sp/>as<sp/>it<sp/>doesn&apos;t</highlight></codeline>
<codeline><highlight class="normal">require<sp/>you<sp/>to<sp/>come<sp/>up<sp/>with<sp/>different<sp/>names<sp/>for<sp/>the<sp/>expectations<sp/>in<sp/>the<sp/>chains.</highlight></codeline>
<codeline><highlight class="normal">Here&apos;s<sp/>how<sp/>it<sp/>works:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>we<sp/>view<sp/>`EXPECT_CALL()`<sp/>statements<sp/>as<sp/>nodes<sp/>in<sp/>a<sp/>graph,<sp/>and<sp/>add<sp/>an<sp/>edge<sp/>from</highlight></codeline>
<codeline><highlight class="normal">node<sp/>A<sp/>to<sp/>node<sp/>B<sp/>wherever<sp/>A<sp/>must<sp/>occur<sp/>before<sp/>B,<sp/>we<sp/>can<sp/>get<sp/>a<sp/>DAG.<sp/>We<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">term<sp/>&quot;sequence&quot;<sp/>to<sp/>mean<sp/>a<sp/>directed<sp/>path<sp/>in<sp/>this<sp/>DAG.<sp/>Now,<sp/>if<sp/>we<sp/>decompose<sp/>the</highlight></codeline>
<codeline><highlight class="normal">DAG<sp/>into<sp/>sequences,<sp/>we<sp/>just<sp/>need<sp/>to<sp/>know<sp/>which<sp/>sequences<sp/>each<sp/>`EXPECT_CALL()`</highlight></codeline>
<codeline><highlight class="normal">belongs<sp/>to<sp/>in<sp/>order<sp/>to<sp/>be<sp/>able<sp/>to<sp/>reconstruct<sp/>the<sp/>original<sp/>DAG.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">So,<sp/>to<sp/>specify<sp/>the<sp/>partial<sp/>order<sp/>on<sp/>the<sp/>expectations<sp/>we<sp/>need<sp/>to<sp/>do<sp/>two<sp/>things:</highlight></codeline>
<codeline><highlight class="normal">first<sp/>to<sp/>define<sp/>some<sp/>`Sequence`<sp/>objects,<sp/>and<sp/>then<sp/>for<sp/>each<sp/>`EXPECT_CALL()`<sp/>say</highlight></codeline>
<codeline><highlight class="normal">which<sp/>`Sequence`<sp/>objects<sp/>it<sp/>is<sp/>part<sp/>of.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Expectations<sp/>in<sp/>the<sp/>same<sp/>sequence<sp/>must<sp/>occur<sp/>in<sp/>the<sp/>order<sp/>they<sp/>are<sp/>written.<sp/>For</highlight></codeline>
<codeline><highlight class="normal">example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Sequence;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sequence<sp/>s1,<sp/>s2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>A())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(bar,<sp/>B())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(bar,<sp/>C())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>D())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">specifies<sp/>the<sp/>following<sp/>DAG<sp/>(where<sp/>`s1`<sp/>is<sp/>`A<sp/>-&gt;<sp/>B`,<sp/>and<sp/>`s2`<sp/>is<sp/>`A<sp/>-&gt;<sp/>C<sp/>-&gt;<sp/>D`):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```text</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+---&gt;<sp/>B</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>A<sp/>---|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+---&gt;<sp/>C<sp/>---&gt;<sp/>D</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>means<sp/>that<sp/>A<sp/>must<sp/>occur<sp/>before<sp/>B<sp/>and<sp/>C,<sp/>and<sp/>C<sp/>must<sp/>occur<sp/>before<sp/>D.<sp/>There&apos;s</highlight></codeline>
<codeline><highlight class="normal">no<sp/>restriction<sp/>about<sp/>the<sp/>order<sp/>other<sp/>than<sp/>these.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Controlling<sp/>When<sp/>an<sp/>Expectation<sp/>Retires</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>a<sp/>mock<sp/>method<sp/>is<sp/>called,<sp/>gMock<sp/>only<sp/>considers<sp/>expectations<sp/>that<sp/>are<sp/>still</highlight></codeline>
<codeline><highlight class="normal">active.<sp/>An<sp/>expectation<sp/>is<sp/>active<sp/>when<sp/>created,<sp/>and<sp/>becomes<sp/>inactive<sp/>(aka</highlight></codeline>
<codeline><highlight class="normal">*retires*)<sp/>when<sp/>a<sp/>call<sp/>that<sp/>has<sp/>to<sp/>occur<sp/>later<sp/>has<sp/>occurred.<sp/>For<sp/>example,<sp/>in</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Sequence;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sequence<sp/>s1,<sp/>s2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;File<sp/>too<sp/>large.&quot;))<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;Data<sp/>set<sp/>is<sp/>empty.&quot;))<sp/><sp/><sp/>//<sp/>#2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;User<sp/>not<sp/>found.&quot;))<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#3</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.InSequence(s2);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">as<sp/>soon<sp/>as<sp/>either<sp/>#2<sp/>or<sp/>#3<sp/>is<sp/>matched,<sp/>#1<sp/>will<sp/>retire.<sp/>If<sp/>a<sp/>warning<sp/>`&quot;File<sp/>too</highlight></codeline>
<codeline><highlight class="normal">large.&quot;`<sp/>is<sp/>logged<sp/>after<sp/>this,<sp/>it<sp/>will<sp/>be<sp/>an<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>an<sp/>expectation<sp/>doesn&apos;t<sp/>retire<sp/>automatically<sp/>when<sp/>it&apos;s<sp/>saturated.<sp/>For</highlight></codeline>
<codeline><highlight class="normal">example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>_));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;File<sp/>too<sp/>large.&quot;));<sp/><sp/><sp/><sp/><sp/>//<sp/>#2</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">says<sp/>that<sp/>there<sp/>will<sp/>be<sp/>exactly<sp/>one<sp/>warning<sp/>with<sp/>the<sp/>message<sp/>`&quot;File<sp/>too</highlight></codeline>
<codeline><highlight class="normal">large.&quot;`.<sp/>If<sp/>the<sp/>second<sp/>warning<sp/>contains<sp/>this<sp/>message<sp/>too,<sp/>#2<sp/>will<sp/>match<sp/>again</highlight></codeline>
<codeline><highlight class="normal">and<sp/>result<sp/>in<sp/>an<sp/>upper-bound-violated<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>this<sp/>is<sp/>not<sp/>what<sp/>you<sp/>want,<sp/>you<sp/>can<sp/>ask<sp/>an<sp/>expectation<sp/>to<sp/>retire<sp/>as<sp/>soon<sp/>as<sp/>it</highlight></codeline>
<codeline><highlight class="normal">becomes<sp/>saturated:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>_));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(log,<sp/>Log(WARNING,<sp/>_,<sp/>&quot;File<sp/>too<sp/>large.&quot;))<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>#2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.RetiresOnSaturation();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Here<sp/>#2<sp/>can<sp/>be<sp/>used<sp/>only<sp/>once,<sp/>so<sp/>if<sp/>you<sp/>have<sp/>two<sp/>warnings<sp/>with<sp/>the<sp/>message</highlight></codeline>
<codeline><highlight class="normal">`&quot;File<sp/>too<sp/>large.&quot;`,<sp/>the<sp/>first<sp/>will<sp/>match<sp/>#2<sp/>and<sp/>the<sp/>second<sp/>will<sp/>match<sp/>#1<sp/>-</highlight></codeline>
<codeline><highlight class="normal">there<sp/>will<sp/>be<sp/>no<sp/>error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Using<sp/>Actions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Returning<sp/>References<sp/>from<sp/>Mock<sp/>Methods</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>mock<sp/>function&apos;s<sp/>return<sp/>type<sp/>is<sp/>a<sp/>reference,<sp/>you<sp/>need<sp/>to<sp/>use<sp/>`ReturnRef()`</highlight></codeline>
<codeline><highlight class="normal">instead<sp/>of<sp/>`Return()`<sp/>to<sp/>return<sp/>a<sp/>result:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ReturnRef;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Bar&amp;,<sp/>GetBar,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>bar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetBar())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(ReturnRef(bar));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Returning<sp/>Live<sp/>Values<sp/>from<sp/>Mock<sp/>Methods</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>`Return(x)`<sp/>action<sp/>saves<sp/>a<sp/>copy<sp/>of<sp/>`x`<sp/>when<sp/>the<sp/>action<sp/>is<sp/>created,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">always<sp/>returns<sp/>the<sp/>same<sp/>value<sp/>whenever<sp/>it&apos;s<sp/>executed.<sp/>Sometimes<sp/>you<sp/>may<sp/>want<sp/>to</highlight></codeline>
<codeline><highlight class="normal">instead<sp/>return<sp/>the<sp/>*live*<sp/>value<sp/>of<sp/>`x`<sp/>(i.e.<sp/>its<sp/>value<sp/>at<sp/>the<sp/>time<sp/>when<sp/>the</highlight></codeline>
<codeline><highlight class="normal">action<sp/>is<sp/>*executed*.).<sp/>Use<sp/>either<sp/>`ReturnRef()`<sp/>or<sp/>`ReturnPointee()`<sp/>for<sp/>this</highlight></codeline>
<codeline><highlight class="normal">purpose.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>mock<sp/>function&apos;s<sp/>return<sp/>type<sp/>is<sp/>a<sp/>reference,<sp/>you<sp/>can<sp/>do<sp/>it<sp/>using</highlight></codeline>
<codeline><highlight class="normal">`ReturnRef(x)`,<sp/>as<sp/>shown<sp/>in<sp/>the<sp/>previous<sp/>recipe<sp/>(&quot;Returning<sp/>References<sp/>from<sp/>Mock</highlight></codeline>
<codeline><highlight class="normal">Methods&quot;).<sp/>However,<sp/>gMock<sp/>doesn&apos;t<sp/>let<sp/>you<sp/>use<sp/>`ReturnRef()`<sp/>in<sp/>a<sp/>mock<sp/>function</highlight></codeline>
<codeline><highlight class="normal">whose<sp/>return<sp/>type<sp/>is<sp/>not<sp/>a<sp/>reference,<sp/>as<sp/>doing<sp/>that<sp/>usually<sp/>indicates<sp/>a<sp/>user</highlight></codeline>
<codeline><highlight class="normal">error.<sp/>So,<sp/>what<sp/>shall<sp/>you<sp/>do?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Though<sp/>you<sp/>may<sp/>be<sp/>tempted,<sp/>DO<sp/>NOT<sp/>use<sp/>`std::ref()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>GetValue,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>x<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetValue())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(std::ref(x)));<sp/><sp/>//<sp/>Wrong!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>x<sp/>=<sp/>42;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(foo.GetValue(),<sp/>42);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Unfortunately,<sp/>it<sp/>doesn&apos;t<sp/>work<sp/>here.<sp/>The<sp/>above<sp/>code<sp/>will<sp/>fail<sp/>with<sp/>error:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```text</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>of:<sp/>foo.GetValue()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>0</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>42</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>reason<sp/>is<sp/>that<sp/>`Return(*value*)`<sp/>converts<sp/>`value`<sp/>to<sp/>the<sp/>actual<sp/>return<sp/>type</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>mock<sp/>function<sp/>at<sp/>the<sp/>time<sp/>when<sp/>the<sp/>action<sp/>is<sp/>*created*,<sp/>not<sp/>when<sp/>it<sp/>is</highlight></codeline>
<codeline><highlight class="normal">*executed*.<sp/>(This<sp/>behavior<sp/>was<sp/>chosen<sp/>for<sp/>the<sp/>action<sp/>to<sp/>be<sp/>safe<sp/>when<sp/>`value`<sp/>is</highlight></codeline>
<codeline><highlight class="normal">a<sp/>proxy<sp/>object<sp/>that<sp/>references<sp/>some<sp/>temporary<sp/>objects.)<sp/>As<sp/>a<sp/>result,</highlight></codeline>
<codeline><highlight class="normal">`std::ref(x)`<sp/>is<sp/>converted<sp/>to<sp/>an<sp/>`int`<sp/>value<sp/>(instead<sp/>of<sp/>a<sp/>`const<sp/>int&amp;`)<sp/>when</highlight></codeline>
<codeline><highlight class="normal">the<sp/>expectation<sp/>is<sp/>set,<sp/>and<sp/>`Return(std::ref(x))`<sp/>will<sp/>always<sp/>return<sp/>0.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`ReturnPointee(pointer)`<sp/>was<sp/>provided<sp/>to<sp/>solve<sp/>this<sp/>problem<sp/>specifically.<sp/>It</highlight></codeline>
<codeline><highlight class="normal">returns<sp/>the<sp/>value<sp/>pointed<sp/>to<sp/>by<sp/>`pointer`<sp/>at<sp/>the<sp/>time<sp/>the<sp/>action<sp/>is<sp/>*executed*:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ReturnPointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>x<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>GetValue())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(ReturnPointee(&amp;x));<sp/><sp/>//<sp/>Note<sp/>the<sp/>&amp;<sp/>here.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>x<sp/>=<sp/>42;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(foo.GetValue(),<sp/>42);<sp/><sp/>//<sp/>This<sp/>will<sp/>succeed<sp/>now.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Combining<sp/>Actions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Want<sp/>to<sp/>do<sp/>more<sp/>than<sp/>one<sp/>thing<sp/>when<sp/>a<sp/>function<sp/>is<sp/>called?<sp/>That&apos;s<sp/>fine.<sp/>`DoAll()`</highlight></codeline>
<codeline><highlight class="normal">allows<sp/>you<sp/>to<sp/>do<sp/>a<sp/>sequence<sp/>of<sp/>actions<sp/>every<sp/>time.<sp/>Only<sp/>the<sp/>return<sp/>value<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">last<sp/>action<sp/>in<sp/>the<sp/>sequence<sp/>will<sp/>be<sp/>used.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>Bar,<sp/>(int<sp/>n),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(action_1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>action_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>action_n));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Verifying<sp/>Complex<sp/>Arguments<sp/>{#SaveArgVerify}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>want<sp/>to<sp/>verify<sp/>that<sp/>a<sp/>method<sp/>is<sp/>called<sp/>with<sp/>a<sp/>particular<sp/>argument<sp/>but<sp/>the</highlight></codeline>
<codeline><highlight class="normal">match<sp/>criteria<sp/>is<sp/>complex,<sp/>it<sp/>can<sp/>be<sp/>difficult<sp/>to<sp/>distinguish<sp/>between</highlight></codeline>
<codeline><highlight class="normal">cardinality<sp/>failures<sp/>(calling<sp/>the<sp/>method<sp/>the<sp/>wrong<sp/>number<sp/>of<sp/>times)<sp/>and<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">match<sp/>failures.<sp/>Similarly,<sp/>if<sp/>you<sp/>are<sp/>matching<sp/>multiple<sp/>parameters,<sp/>it<sp/>may<sp/>not</highlight></codeline>
<codeline><highlight class="normal">be<sp/>easy<sp/>to<sp/>distinguishing<sp/>which<sp/>argument<sp/>failed<sp/>to<sp/>match.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Not<sp/>ideal:<sp/>this<sp/>could<sp/>fail<sp/>because<sp/>of<sp/>a<sp/>problem<sp/>with<sp/>arg1<sp/>or<sp/>arg2,<sp/>or<sp/>maybe</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>just<sp/>the<sp/>method<sp/>wasn&apos;t<sp/>called.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>SendValues(_,<sp/>ElementsAre(1,<sp/>4,<sp/>4,<sp/>7),<sp/>EqualsProto(<sp/>...<sp/>)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>instead<sp/>save<sp/>the<sp/>arguments<sp/>and<sp/>test<sp/>them<sp/>individually:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>SendValues)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(SaveArg&lt;1&gt;(&amp;actual_array),<sp/>SaveArg&lt;2&gt;(&amp;actual_proto)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>run<sp/>the<sp/>test</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(actual_array,<sp/>ElementsAre(1,<sp/>4,<sp/>4,<sp/>7));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(actual_proto,<sp/>EqualsProto(<sp/>...<sp/>));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mocking<sp/>Side<sp/>Effects<sp/>{#MockingSideEffects}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>a<sp/>method<sp/>exhibits<sp/>its<sp/>effect<sp/>not<sp/>via<sp/>returning<sp/>a<sp/>value<sp/>but<sp/>via<sp/>side</highlight></codeline>
<codeline><highlight class="normal">effects.<sp/>For<sp/>example,<sp/>it<sp/>may<sp/>change<sp/>some<sp/>global<sp/>state<sp/>or<sp/>modify<sp/>an<sp/>output</highlight></codeline>
<codeline><highlight class="normal">argument.<sp/>To<sp/>mock<sp/>side<sp/>effects,<sp/>in<sp/>general<sp/>you<sp/>can<sp/>define<sp/>your<sp/>own<sp/>action<sp/>by</highlight></codeline>
<codeline><highlight class="normal">implementing<sp/>`::testing::ActionInterface`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>all<sp/>you<sp/>need<sp/>to<sp/>do<sp/>is<sp/>to<sp/>change<sp/>an<sp/>output<sp/>argument,<sp/>the<sp/>built-in</highlight></codeline>
<codeline><highlight class="normal">`SetArgPointee()`<sp/>action<sp/>is<sp/>convenient:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArgPointee;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockMutator<sp/>:<sp/>public<sp/>Mutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Mutate,<sp/>(bool<sp/>mutate,<sp/>int*<sp/>value),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>Mutate(true,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArgPointee&lt;1&gt;(5));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>this<sp/>example,<sp/>when<sp/>`mutator.Mutate()`<sp/>is<sp/>called,<sp/>we<sp/>will<sp/>assign<sp/>5<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`int`<sp/>variable<sp/>pointed<sp/>to<sp/>by<sp/>argument<sp/>#1<sp/>(0-based).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`SetArgPointee()`<sp/>conveniently<sp/>makes<sp/>an<sp/>internal<sp/>copy<sp/>of<sp/>the<sp/>value<sp/>you<sp/>pass<sp/>to</highlight></codeline>
<codeline><highlight class="normal">it,<sp/>removing<sp/>the<sp/>need<sp/>to<sp/>keep<sp/>the<sp/>value<sp/>in<sp/>scope<sp/>and<sp/>alive.<sp/>The<sp/>implication</highlight></codeline>
<codeline><highlight class="normal">however<sp/>is<sp/>that<sp/>the<sp/>value<sp/>must<sp/>have<sp/>a<sp/>copy<sp/>constructor<sp/>and<sp/>assignment<sp/>operator.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>mock<sp/>method<sp/>also<sp/>needs<sp/>to<sp/>return<sp/>a<sp/>value<sp/>as<sp/>well,<sp/>you<sp/>can<sp/>chain</highlight></codeline>
<codeline><highlight class="normal">`SetArgPointee()`<sp/>with<sp/>`Return()`<sp/>using<sp/>`DoAll()`,<sp/>remembering<sp/>to<sp/>put<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`Return()`<sp/>statement<sp/>last:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArgPointee;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockMutator<sp/>:<sp/>public<sp/>Mutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>MutateInt,<sp/>(int*<sp/>value),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>MutateInt(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(SetArgPointee&lt;0&gt;(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(true)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note,<sp/>however,<sp/>that<sp/>if<sp/>you<sp/>use<sp/>the<sp/>`ReturnOKWith()`<sp/>method,<sp/>it<sp/>will<sp/>override<sp/>the</highlight></codeline>
<codeline><highlight class="normal">values<sp/>provided<sp/>by<sp/>`SetArgPointee()`<sp/>in<sp/>the<sp/>response<sp/>parameters<sp/>of<sp/>your<sp/>function</highlight></codeline>
<codeline><highlight class="normal">call.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>output<sp/>argument<sp/>is<sp/>an<sp/>array,<sp/>use<sp/>the<sp/>`SetArrayArgument&lt;N&gt;(first,<sp/>last)`</highlight></codeline>
<codeline><highlight class="normal">action<sp/>instead.<sp/>It<sp/>copies<sp/>the<sp/>elements<sp/>in<sp/>source<sp/>range<sp/>`[first,<sp/>last)`<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">array<sp/>pointed<sp/>to<sp/>by<sp/>the<sp/>`N`-th<sp/>(0-based)<sp/>argument:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::NotNull;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArrayArgument;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockArrayMutator<sp/>:<sp/>public<sp/>ArrayMutator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Mutate,<sp/>(int*<sp/>values,<sp/>int<sp/>num_values),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockArrayMutator<sp/>mutator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>values[5]<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mutator,<sp/>Mutate(NotNull(),<sp/>5))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArrayArgument&lt;0&gt;(values,<sp/>values<sp/>+<sp/>5));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>also<sp/>works<sp/>when<sp/>the<sp/>argument<sp/>is<sp/>an<sp/>output<sp/>iterator:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArrayArgument;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockRolodex<sp/>:<sp/>public<sp/>Rolodex<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>GetNames,<sp/>(std::back_insert_iterator&lt;vector&lt;string&gt;&gt;),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockRolodex<sp/>rolodex;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vector&lt;string&gt;<sp/>names<sp/>=<sp/>{&quot;George&quot;,<sp/>&quot;John&quot;,<sp/>&quot;Thomas&quot;};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(rolodex,<sp/>GetNames(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(SetArrayArgument&lt;0&gt;(names.begin(),<sp/>names.end()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Changing<sp/>a<sp/>Mock<sp/>Object&apos;s<sp/>Behavior<sp/>Based<sp/>on<sp/>the<sp/>State</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>expect<sp/>a<sp/>call<sp/>to<sp/>change<sp/>the<sp/>behavior<sp/>of<sp/>a<sp/>mock<sp/>object,<sp/>you<sp/>can<sp/>use</highlight></codeline>
<codeline><highlight class="normal">`::testing::InSequence`<sp/>to<sp/>specify<sp/>different<sp/>behaviors<sp/>before<sp/>and<sp/>after<sp/>the</highlight></codeline>
<codeline><highlight class="normal">call:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InSequence;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>InSequence<sp/>seq;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>IsDirty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(true));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>Flush());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>EXPECT_CALL(my_mock,<sp/>IsDirty())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Return(false));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_mock.FlushIfDirty();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>makes<sp/>`my_mock.IsDirty()`<sp/>return<sp/>`true`<sp/>before<sp/>`my_mock.Flush()`<sp/>is<sp/>called</highlight></codeline>
<codeline><highlight class="normal">and<sp/>return<sp/>`false`<sp/>afterwards.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>behavior<sp/>change<sp/>is<sp/>more<sp/>complex,<sp/>you<sp/>can<sp/>store<sp/>the<sp/>effects<sp/>in<sp/>a<sp/>variable</highlight></codeline>
<codeline><highlight class="normal">and<sp/>make<sp/>a<sp/>mock<sp/>method<sp/>get<sp/>its<sp/>return<sp/>value<sp/>from<sp/>that<sp/>variable:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SaveArg;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">ACTION_P(ReturnPointee,<sp/>p)<sp/>{<sp/>return<sp/>*p;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>previous_value<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(my_mock,<sp/>GetPrevValue)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(ReturnPointee(&amp;previous_value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(my_mock,<sp/>UpdateValue)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(SaveArg&lt;0&gt;(&amp;previous_value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_mock.DoSomethingToUpdateValue();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Here<sp/>`my_mock.GetPrevValue()`<sp/>will<sp/>always<sp/>return<sp/>the<sp/>argument<sp/>of<sp/>the<sp/>last</highlight></codeline>
<codeline><highlight class="normal">`UpdateValue()`<sp/>call.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Setting<sp/>the<sp/>Default<sp/>Value<sp/>for<sp/>a<sp/>Return<sp/>Type<sp/>{#DefaultValue}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>mock<sp/>method&apos;s<sp/>return<sp/>type<sp/>is<sp/>a<sp/>built-in<sp/>C++<sp/>type<sp/>or<sp/>pointer,<sp/>by<sp/>default<sp/>it</highlight></codeline>
<codeline><highlight class="normal">will<sp/>return<sp/>0<sp/>when<sp/>invoked.<sp/>Also,<sp/>in<sp/>C++<sp/>11<sp/>and<sp/>above,<sp/>a<sp/>mock<sp/>method<sp/>whose</highlight></codeline>
<codeline><highlight class="normal">return<sp/>type<sp/>has<sp/>a<sp/>default<sp/>constructor<sp/>will<sp/>return<sp/>a<sp/>default-constructed<sp/>value<sp/>by</highlight></codeline>
<codeline><highlight class="normal">default.<sp/>You<sp/>only<sp/>need<sp/>to<sp/>specify<sp/>an<sp/>action<sp/>if<sp/>this<sp/>default<sp/>value<sp/>doesn&apos;t<sp/>work</highlight></codeline>
<codeline><highlight class="normal">for<sp/>you.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes,<sp/>you<sp/>may<sp/>want<sp/>to<sp/>change<sp/>this<sp/>default<sp/>value,<sp/>or<sp/>you<sp/>may<sp/>want<sp/>to<sp/>specify</highlight></codeline>
<codeline><highlight class="normal">a<sp/>default<sp/>value<sp/>for<sp/>types<sp/>gMock<sp/>doesn&apos;t<sp/>know<sp/>about.<sp/>You<sp/>can<sp/>do<sp/>this<sp/>using<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`::testing::DefaultValue`<sp/>class<sp/>template:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DefaultValue;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(Bar,<sp/>CalculateBar,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Bar<sp/>default_bar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Sets<sp/>the<sp/>default<sp/>return<sp/>value<sp/>for<sp/>type<sp/>Bar.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DefaultValue&lt;Bar&gt;::Set(default_bar);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>need<sp/>to<sp/>specify<sp/>an<sp/>action<sp/>here,<sp/>as<sp/>the<sp/>default</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>return<sp/>value<sp/>works<sp/>for<sp/>us.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>CalculateBar());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.CalculateBar();<sp/><sp/>//<sp/>This<sp/>should<sp/>return<sp/>default_bar.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Unsets<sp/>the<sp/>default<sp/>return<sp/>value.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DefaultValue&lt;Bar&gt;::Clear();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Please<sp/>note<sp/>that<sp/>changing<sp/>the<sp/>default<sp/>value<sp/>for<sp/>a<sp/>type<sp/>can<sp/>make<sp/>your<sp/>tests<sp/>hard</highlight></codeline>
<codeline><highlight class="normal">to<sp/>understand.<sp/>We<sp/>recommend<sp/>you<sp/>to<sp/>use<sp/>this<sp/>feature<sp/>judiciously.<sp/>For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>may<sp/>want<sp/>to<sp/>make<sp/>sure<sp/>the<sp/>`Set()`<sp/>and<sp/>`Clear()`<sp/>calls<sp/>are<sp/>right<sp/>next<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">code<sp/>that<sp/>uses<sp/>your<sp/>mock.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Setting<sp/>the<sp/>Default<sp/>Actions<sp/>for<sp/>a<sp/>Mock<sp/>Method</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You&apos;ve<sp/>learned<sp/>how<sp/>to<sp/>change<sp/>the<sp/>default<sp/>value<sp/>of<sp/>a<sp/>given<sp/>type.<sp/>However,<sp/>this</highlight></codeline>
<codeline><highlight class="normal">may<sp/>be<sp/>too<sp/>coarse<sp/>for<sp/>your<sp/>purpose:<sp/>perhaps<sp/>you<sp/>have<sp/>two<sp/>mock<sp/>methods<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">same<sp/>return<sp/>type<sp/>and<sp/>you<sp/>want<sp/>them<sp/>to<sp/>have<sp/>different<sp/>behaviors.<sp/>The<sp/>`ON_CALL()`</highlight></codeline>
<codeline><highlight class="normal">macro<sp/>allows<sp/>you<sp/>to<sp/>customize<sp/>your<sp/>mock&apos;s<sp/>behavior<sp/>at<sp/>the<sp/>method<sp/>level:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::AnyNumber;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(-1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(0))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ON_CALL(foo,<sp/>Sign(Gt(0)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillByDefault(Return(1));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Sign(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(AnyNumber());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(5);<sp/><sp/><sp/>//<sp/>This<sp/>should<sp/>return<sp/>1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(-9);<sp/><sp/>//<sp/>This<sp/>should<sp/>return<sp/>-1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sign(0);<sp/><sp/><sp/>//<sp/>This<sp/>should<sp/>return<sp/>0.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>you<sp/>may<sp/>have<sp/>guessed,<sp/>when<sp/>there<sp/>are<sp/>more<sp/>than<sp/>one<sp/>`ON_CALL()`<sp/>statements,</highlight></codeline>
<codeline><highlight class="normal">the<sp/>newer<sp/>ones<sp/>in<sp/>the<sp/>order<sp/>take<sp/>precedence<sp/>over<sp/>the<sp/>older<sp/>ones.<sp/>In<sp/>other<sp/>words,</highlight></codeline>
<codeline><highlight class="normal">the<sp/>**last**<sp/>one<sp/>that<sp/>matches<sp/>the<sp/>function<sp/>arguments<sp/>will<sp/>be<sp/>used.<sp/>This<sp/>matching</highlight></codeline>
<codeline><highlight class="normal">order<sp/>allows<sp/>you<sp/>to<sp/>set<sp/>up<sp/>the<sp/>common<sp/>behavior<sp/>in<sp/>a<sp/>mock<sp/>object&apos;s<sp/>constructor<sp/>or</highlight></codeline>
<codeline><highlight class="normal">the<sp/>test<sp/>fixture&apos;s<sp/>set-up<sp/>phase<sp/>and<sp/>specialize<sp/>the<sp/>mock&apos;s<sp/>behavior<sp/>later.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>both<sp/>`ON_CALL`<sp/>and<sp/>`EXPECT_CALL`<sp/>have<sp/>the<sp/>same<sp/>&quot;later<sp/>statements<sp/>take</highlight></codeline>
<codeline><highlight class="normal">precedence&quot;<sp/>rule,<sp/>but<sp/>they<sp/>don&apos;t<sp/>interact.<sp/>That<sp/>is,<sp/>`EXPECT_CALL`s<sp/>have<sp/>their</highlight></codeline>
<codeline><highlight class="normal">own<sp/>precedence<sp/>order<sp/>distinct<sp/>from<sp/>the<sp/>`ON_CALL`<sp/>precedence<sp/>order.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>Functions/Methods/Functors/Lambdas<sp/>as<sp/>Actions<sp/>{#FunctionsAsActions}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>built-in<sp/>actions<sp/>don&apos;t<sp/>suit<sp/>you,<sp/>you<sp/>can<sp/>use<sp/>an<sp/>existing<sp/>callable</highlight></codeline>
<codeline><highlight class="normal">(function,<sp/>`std::function`,<sp/>method,<sp/>functor,<sp/>lambda)<sp/>as<sp/>an<sp/>action.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;<sp/>using<sp/>::testing::Invoke;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>Sum,<sp/>(int<sp/>x,<sp/>int<sp/>y),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>ComplexJob,<sp/>(int<sp/>x),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>CalculateSum(int<sp/>x,<sp/>int<sp/>y)<sp/>{<sp/>return<sp/>x<sp/>+<sp/>y;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">int<sp/>Sum3(int<sp/>x,<sp/>int<sp/>y,<sp/>int<sp/>z)<sp/>{<sp/>return<sp/>x<sp/>+<sp/>y<sp/>+<sp/>z;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>Helper<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>ComplexJob(int<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Helper<sp/>helper;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Sum(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(&amp;CalculateSum)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(Invoke(NewPermanentCallback(Sum3,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>ComplexJob(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(&amp;helper,<sp/>&amp;Helper::ComplexJob))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce([]<sp/>{<sp/>return<sp/>true;<sp/>})</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly([](int<sp/>x)<sp/>{<sp/>return<sp/>x<sp/>&gt;<sp/>0;<sp/>});</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sum(5,<sp/>6);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Invokes<sp/>CalculateSum(5,<sp/>6).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Sum(2,<sp/>3);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Invokes<sp/>Sum3(1,<sp/>2,<sp/>3).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(10);<sp/><sp/><sp/><sp/>//<sp/>Invokes<sp/>helper.ComplexJob(10).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(-1);<sp/><sp/><sp/><sp/>//<sp/>Invokes<sp/>the<sp/>inline<sp/>lambda.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>only<sp/>requirement<sp/>is<sp/>that<sp/>the<sp/>type<sp/>of<sp/>the<sp/>function,<sp/>etc<sp/>must<sp/>be<sp/>*compatible*</highlight></codeline>
<codeline><highlight class="normal">with<sp/>the<sp/>signature<sp/>of<sp/>the<sp/>mock<sp/>function,<sp/>meaning<sp/>that<sp/>the<sp/>latter&apos;s<sp/>arguments<sp/>(if</highlight></codeline>
<codeline><highlight class="normal">it<sp/>takes<sp/>any)<sp/>can<sp/>be<sp/>implicitly<sp/>converted<sp/>to<sp/>the<sp/>corresponding<sp/>arguments<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">former,<sp/>and<sp/>the<sp/>former&apos;s<sp/>return<sp/>type<sp/>can<sp/>be<sp/>implicitly<sp/>converted<sp/>to<sp/>that<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">latter.<sp/>So,<sp/>you<sp/>can<sp/>invoke<sp/>something<sp/>whose<sp/>type<sp/>is<sp/>*not*<sp/>exactly<sp/>the<sp/>same<sp/>as<sp/>the</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>function,<sp/>as<sp/>long<sp/>as<sp/>it&apos;s<sp/>safe<sp/>to<sp/>do<sp/>so<sp/>-<sp/>nice,<sp/>huh?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>The<sp/>action<sp/>takes<sp/>ownership<sp/>of<sp/>the<sp/>callback<sp/>and<sp/>will<sp/>delete<sp/>it<sp/>when<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>action<sp/>itself<sp/>is<sp/>destructed.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>If<sp/>the<sp/>type<sp/>of<sp/>a<sp/>callback<sp/>is<sp/>derived<sp/>from<sp/>a<sp/>base<sp/>callback<sp/>type<sp/>`C`,<sp/>you<sp/>need</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>to<sp/>implicitly<sp/>cast<sp/>it<sp/>to<sp/>`C`<sp/>to<sp/>resolve<sp/>the<sp/>overloading,<sp/>e.g.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ResultCallback&lt;bool&gt;*<sp/>is_ok<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>...<sp/>Invoke(is_ok)<sp/>...;<sp/><sp/>//<sp/>This<sp/>works.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>BlockingClosure*<sp/>done<sp/>=<sp/>new<sp/>BlockingClosure;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>...<sp/>Invoke(implicit_cast&lt;Closure*&gt;(done))<sp/>...;<sp/><sp/>//<sp/>The<sp/>cast<sp/>is<sp/>necessary.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>Functions<sp/>with<sp/>Extra<sp/>Info<sp/>as<sp/>Actions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>function<sp/>or<sp/>functor<sp/>you<sp/>call<sp/>using<sp/>`Invoke()`<sp/>must<sp/>have<sp/>the<sp/>same<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal">arguments<sp/>as<sp/>the<sp/>mock<sp/>function<sp/>you<sp/>use<sp/>it<sp/>for.<sp/>Sometimes<sp/>you<sp/>may<sp/>have<sp/>a<sp/>function</highlight></codeline>
<codeline><highlight class="normal">that<sp/>takes<sp/>more<sp/>arguments,<sp/>and<sp/>you<sp/>are<sp/>willing<sp/>to<sp/>pass<sp/>in<sp/>the<sp/>extra<sp/>arguments</highlight></codeline>
<codeline><highlight class="normal">yourself<sp/>to<sp/>fill<sp/>the<sp/>gap.<sp/>You<sp/>can<sp/>do<sp/>this<sp/>in<sp/>gMock<sp/>using<sp/>callbacks<sp/>with</highlight></codeline>
<codeline><highlight class="normal">pre-bound<sp/>arguments.<sp/>Here&apos;s<sp/>an<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(char,<sp/>DoThis,<sp/>(int<sp/>n),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">char<sp/>SignOfSum(int<sp/>x,<sp/>int<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>sum<sp/>=<sp/>x<sp/>+<sp/>y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>(sum<sp/>&gt;<sp/>0)<sp/>?<sp/>&apos;+&apos;<sp/>:<sp/>(sum<sp/>&lt;<sp/>0)<sp/>?<sp/>&apos;-&apos;<sp/>:<sp/>&apos;0&apos;;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST_F(FooTest,<sp/>Test)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(2))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(NewPermanentCallback(SignOfSum,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_EQ(foo.DoThis(2),<sp/>&apos;+&apos;);<sp/><sp/>//<sp/>Invokes<sp/>SignOfSum(5,<sp/>2).</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Invoking<sp/>a<sp/>Function/Method/Functor/Lambda/Callback<sp/>Without<sp/>Arguments</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`Invoke()`<sp/>passes<sp/>the<sp/>mock<sp/>function&apos;s<sp/>arguments<sp/>to<sp/>the<sp/>function,<sp/>etc<sp/>being</highlight></codeline>
<codeline><highlight class="normal">invoked<sp/>such<sp/>that<sp/>the<sp/>callee<sp/>has<sp/>the<sp/>full<sp/>context<sp/>of<sp/>the<sp/>call<sp/>to<sp/>work<sp/>with.<sp/>If</highlight></codeline>
<codeline><highlight class="normal">the<sp/>invoked<sp/>function<sp/>is<sp/>not<sp/>interested<sp/>in<sp/>some<sp/>or<sp/>all<sp/>of<sp/>the<sp/>arguments,<sp/>it<sp/>can</highlight></codeline>
<codeline><highlight class="normal">simply<sp/>ignore<sp/>them.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Yet,<sp/>a<sp/>common<sp/>pattern<sp/>is<sp/>that<sp/>a<sp/>test<sp/>author<sp/>wants<sp/>to<sp/>invoke<sp/>a<sp/>function<sp/>without</highlight></codeline>
<codeline><highlight class="normal">the<sp/>arguments<sp/>of<sp/>the<sp/>mock<sp/>function.<sp/>She<sp/>could<sp/>do<sp/>that<sp/>using<sp/>a<sp/>wrapper<sp/>function</highlight></codeline>
<codeline><highlight class="normal">that<sp/>throws<sp/>away<sp/>the<sp/>arguments<sp/>before<sp/>invoking<sp/>an<sp/>underlining<sp/>nullary<sp/>function.</highlight></codeline>
<codeline><highlight class="normal">Needless<sp/>to<sp/>say,<sp/>this<sp/>can<sp/>be<sp/>tedious<sp/>and<sp/>obscures<sp/>the<sp/>intent<sp/>of<sp/>the<sp/>test.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">There<sp/>are<sp/>two<sp/>solutions<sp/>to<sp/>this<sp/>problem.<sp/>First,<sp/>you<sp/>can<sp/>pass<sp/>any<sp/>callable<sp/>of</highlight></codeline>
<codeline><highlight class="normal">zero<sp/>args<sp/>as<sp/>an<sp/>action.<sp/>Alternatively,<sp/>use<sp/>`InvokeWithoutArgs()`,<sp/>which<sp/>is<sp/>like</highlight></codeline>
<codeline><highlight class="normal">`Invoke()`<sp/>except<sp/>that<sp/>it<sp/>doesn&apos;t<sp/>pass<sp/>the<sp/>mock<sp/>function&apos;s<sp/>arguments<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">callee.<sp/>Here&apos;s<sp/>an<sp/>example<sp/>of<sp/>each:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeWithoutArgs;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>ComplexJob,<sp/>(int<sp/>n),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">bool<sp/>Job1()<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>Job2(int<sp/>n,<sp/>char<sp/>c)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>ComplexJob(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce([]<sp/>{<sp/>Job1();<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeWithoutArgs(NewPermanentCallback(Job2,<sp/>5,<sp/>&apos;a&apos;)));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(10);<sp/><sp/>//<sp/>Invokes<sp/>Job1().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.ComplexJob(20);<sp/><sp/>//<sp/>Invokes<sp/>Job2(5,<sp/>&apos;a&apos;).</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>The<sp/>action<sp/>takes<sp/>ownership<sp/>of<sp/>the<sp/>callback<sp/>and<sp/>will<sp/>delete<sp/>it<sp/>when<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>action<sp/>itself<sp/>is<sp/>destructed.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>If<sp/>the<sp/>type<sp/>of<sp/>a<sp/>callback<sp/>is<sp/>derived<sp/>from<sp/>a<sp/>base<sp/>callback<sp/>type<sp/>`C`,<sp/>you<sp/>need</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>to<sp/>implicitly<sp/>cast<sp/>it<sp/>to<sp/>`C`<sp/>to<sp/>resolve<sp/>the<sp/>overloading,<sp/>e.g.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>using<sp/>::testing::InvokeWithoutArgs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ResultCallback&lt;bool&gt;*<sp/>is_ok<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>...<sp/>InvokeWithoutArgs(is_ok)<sp/>...;<sp/><sp/>//<sp/>This<sp/>works.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>BlockingClosure*<sp/>done<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>...<sp/>InvokeWithoutArgs(implicit_cast&lt;Closure*&gt;(done))<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>cast<sp/>is<sp/>necessary.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Invoking<sp/>an<sp/>Argument<sp/>of<sp/>the<sp/>Mock<sp/>Function</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>a<sp/>mock<sp/>function<sp/>will<sp/>receive<sp/>a<sp/>function<sp/>pointer,<sp/>a<sp/>functor<sp/>(in<sp/>other</highlight></codeline>
<codeline><highlight class="normal">words,<sp/>a<sp/>&quot;callable&quot;)<sp/>as<sp/>an<sp/>argument,<sp/>e.g.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>DoThis,<sp/>(int<sp/>n,<sp/>(ResultCallback1&lt;bool,<sp/>int&gt;*<sp/>callback)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">and<sp/>you<sp/>may<sp/>want<sp/>to<sp/>invoke<sp/>this<sp/>callable<sp/>argument:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Will<sp/>execute<sp/>callback-&gt;Run(5),<sp/>where<sp/>callback<sp/>is<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>second<sp/>argument<sp/>DoThis()<sp/>receives.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.note}</highlight></codeline>
<codeline><highlight class="normal">NOTE:<sp/>The<sp/>section<sp/>below<sp/>is<sp/>legacy<sp/>documentation<sp/>from<sp/>before<sp/>C++<sp/>had<sp/>lambdas:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Arghh,<sp/>you<sp/>need<sp/>to<sp/>refer<sp/>to<sp/>a<sp/>mock<sp/>function<sp/>argument<sp/>but<sp/>C++<sp/>has<sp/>no<sp/>lambda</highlight></codeline>
<codeline><highlight class="normal">(yet),<sp/>so<sp/>you<sp/>have<sp/>to<sp/>define<sp/>your<sp/>own<sp/>action.<sp/>:-(<sp/>Or<sp/>do<sp/>you<sp/>really?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Well,<sp/>gMock<sp/>has<sp/>an<sp/>action<sp/>to<sp/>solve<sp/>*exactly*<sp/>this<sp/>problem:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">InvokeArgument&lt;N&gt;(arg_1,<sp/>arg_2,<sp/>...,<sp/>arg_m)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">will<sp/>invoke<sp/>the<sp/>`N`-th<sp/>(0-based)<sp/>argument<sp/>the<sp/>mock<sp/>function<sp/>receives,<sp/>with</highlight></codeline>
<codeline><highlight class="normal">`arg_1`,<sp/>`arg_2`,<sp/>...,<sp/>and<sp/>`arg_m`.<sp/>No<sp/>matter<sp/>if<sp/>the<sp/>argument<sp/>is<sp/>a<sp/>function</highlight></codeline>
<codeline><highlight class="normal">pointer,<sp/>a<sp/>functor,<sp/>or<sp/>a<sp/>callback.<sp/>gMock<sp/>handles<sp/>them<sp/>all.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">With<sp/>that,<sp/>you<sp/>could<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis(_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;1&gt;(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Will<sp/>execute<sp/>callback-&gt;Run(5),<sp/>where<sp/>callback<sp/>is<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>second<sp/>argument<sp/>DoThis()<sp/>receives.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>the<sp/>callable<sp/>takes<sp/>an<sp/>argument<sp/>by<sp/>reference?<sp/>No<sp/>problem<sp/>-<sp/>just<sp/>wrap<sp/>it</highlight></codeline>
<codeline><highlight class="normal">inside<sp/>`std::ref()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>Bar,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((ResultCallback2&lt;bool,<sp/>int,<sp/>const<sp/>Helper&amp;&gt;*<sp/>callback)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Helper<sp/>helper;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;0&gt;(5,<sp/>std::ref(helper)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>std::ref(helper)<sp/>guarantees<sp/>that<sp/>a<sp/>reference<sp/>to<sp/>helper,<sp/>not<sp/>a<sp/>copy<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>it,<sp/>will<sp/>be<sp/>passed<sp/>to<sp/>the<sp/>callback.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">What<sp/>if<sp/>the<sp/>callable<sp/>takes<sp/>an<sp/>argument<sp/>by<sp/>reference<sp/>and<sp/>we<sp/>do<sp/>**not**<sp/>wrap<sp/>the</highlight></codeline>
<codeline><highlight class="normal">argument<sp/>in<sp/>`std::ref()`?<sp/>Then<sp/>`InvokeArgument()`<sp/>will<sp/>*make<sp/>a<sp/>copy*<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">argument,<sp/>and<sp/>pass<sp/>a<sp/>*reference<sp/>to<sp/>the<sp/>copy*,<sp/>instead<sp/>of<sp/>a<sp/>reference<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">original<sp/>value,<sp/>to<sp/>the<sp/>callable.<sp/>This<sp/>is<sp/>especially<sp/>handy<sp/>when<sp/>the<sp/>argument<sp/>is<sp/>a</highlight></codeline>
<codeline><highlight class="normal">temporary<sp/>value:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>DoThat,<sp/>(bool<sp/>(*f)(const<sp/>double&amp;<sp/>x,<sp/>const<sp/>string&amp;<sp/>s)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::InvokeArgument;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(InvokeArgument&lt;0&gt;(5.0,<sp/>string(&quot;Hi&quot;)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Will<sp/>execute<sp/>(*f)(5.0,<sp/>string(&quot;Hi&quot;)),<sp/>where<sp/>f<sp/>is<sp/>the<sp/>function<sp/>pointer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>DoThat()<sp/>receives.<sp/><sp/>Note<sp/>that<sp/>the<sp/>values<sp/>5.0<sp/>and<sp/>string(&quot;Hi&quot;)<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>temporary<sp/>and<sp/>dead<sp/>once<sp/>the<sp/>EXPECT_CALL()<sp/>statement<sp/>finishes.<sp/><sp/>Yet</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>it&apos;s<sp/>fine<sp/>to<sp/>perform<sp/>this<sp/>action<sp/>later,<sp/>since<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>values</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>are<sp/>kept<sp/>inside<sp/>the<sp/>InvokeArgument<sp/>action.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Ignoring<sp/>an<sp/>Action&apos;s<sp/>Result</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>have<sp/>an<sp/>action<sp/>that<sp/>returns<sp/>*something*,<sp/>but<sp/>you<sp/>need<sp/>an<sp/>action</highlight></codeline>
<codeline><highlight class="normal">that<sp/>returns<sp/>`void`<sp/>(perhaps<sp/>you<sp/>want<sp/>to<sp/>use<sp/>it<sp/>in<sp/>a<sp/>mock<sp/>function<sp/>that<sp/>returns</highlight></codeline>
<codeline><highlight class="normal">`void`,<sp/>or<sp/>perhaps<sp/>it<sp/>needs<sp/>to<sp/>be<sp/>used<sp/>in<sp/>`DoAll()`<sp/>and<sp/>it&apos;s<sp/>not<sp/>the<sp/>last<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">list).<sp/>`IgnoreResult()`<sp/>lets<sp/>you<sp/>do<sp/>that.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::IgnoreResult;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>Process(const<sp/>MyData&amp;<sp/>data);</highlight></codeline>
<codeline><highlight class="normal">string<sp/>DoSomething();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Abc,<sp/>(const<sp/>MyData&amp;<sp/>data),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>Xyz,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Abc(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>.WillOnce(Invoke(Process));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>The<sp/>above<sp/>line<sp/>won&apos;t<sp/>compile<sp/>as<sp/>Process()<sp/>returns<sp/>int<sp/>but<sp/>Abc()<sp/>needs</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>to<sp/>return<sp/>void.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(IgnoreResult(Process));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Xyz())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(DoAll(IgnoreResult(DoSomething),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Ignores<sp/>the<sp/>string<sp/>DoSomething()<sp/>returns.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(true)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>you<sp/>**cannot**<sp/>use<sp/>`IgnoreResult()`<sp/>on<sp/>an<sp/>action<sp/>that<sp/>already<sp/>returns</highlight></codeline>
<codeline><highlight class="normal">`void`.<sp/>Doing<sp/>so<sp/>will<sp/>lead<sp/>to<sp/>ugly<sp/>compiler<sp/>errors.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Selecting<sp/>an<sp/>Action&apos;s<sp/>Arguments<sp/>{#SelectingArgs}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Say<sp/>you<sp/>have<sp/>a<sp/>mock<sp/>function<sp/>`Foo()`<sp/>that<sp/>takes<sp/>seven<sp/>arguments,<sp/>and<sp/>you<sp/>have<sp/>a</highlight></codeline>
<codeline><highlight class="normal">custom<sp/>action<sp/>that<sp/>you<sp/>want<sp/>to<sp/>invoke<sp/>when<sp/>`Foo()`<sp/>is<sp/>called.<sp/>Trouble<sp/>is,<sp/>the</highlight></codeline>
<codeline><highlight class="normal">custom<sp/>action<sp/>only<sp/>wants<sp/>three<sp/>arguments:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>Foo,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(bool<sp/>visible,<sp/>const<sp/>string&amp;<sp/>name,<sp/>int<sp/>x,<sp/>int<sp/>y,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(const<sp/>map&lt;pair&lt;int,<sp/>int&gt;&gt;),<sp/>double&amp;<sp/>weight,<sp/>double<sp/>min_weight,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>max_wight));</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>IsVisibleInQuadrant1(bool<sp/>visible,<sp/>int<sp/>x,<sp/>int<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>visible<sp/>&amp;&amp;<sp/>x<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>y<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(IsVisibleInQuadrant1));<sp/><sp/>//<sp/>Uh,<sp/>won&apos;t<sp/>compile.<sp/>:-(</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>please<sp/>the<sp/>compiler<sp/>God,<sp/>you<sp/>need<sp/>to<sp/>define<sp/>an<sp/>&quot;adaptor&quot;<sp/>that<sp/>has<sp/>the<sp/>same</highlight></codeline>
<codeline><highlight class="normal">signature<sp/>as<sp/>`Foo()`<sp/>and<sp/>calls<sp/>the<sp/>custom<sp/>action<sp/>with<sp/>the<sp/>right<sp/>arguments:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>MyIsVisibleInQuadrant1(bool<sp/>visible,<sp/>const<sp/>string&amp;<sp/>name,<sp/>int<sp/>x,<sp/>int<sp/>y,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>map&lt;pair&lt;int,<sp/>int&gt;,<sp/>double&gt;&amp;<sp/>weight,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>min_weight,<sp/>double<sp/>max_wight)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>IsVisibleInQuadrant1(visible,<sp/>x,<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(MyIsVisibleInQuadrant1));<sp/><sp/>//<sp/>Now<sp/>it<sp/>works.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">But<sp/>isn&apos;t<sp/>this<sp/>awkward?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>provides<sp/>a<sp/>generic<sp/>*action<sp/>adaptor*,<sp/>so<sp/>you<sp/>can<sp/>spend<sp/>your<sp/>time<sp/>minding</highlight></codeline>
<codeline><highlight class="normal">more<sp/>important<sp/>business<sp/>than<sp/>writing<sp/>your<sp/>own<sp/>adaptors.<sp/>Here&apos;s<sp/>the<sp/>syntax:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">WithArgs&lt;N1,<sp/>N2,<sp/>...,<sp/>Nk&gt;(action)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">creates<sp/>an<sp/>action<sp/>that<sp/>passes<sp/>the<sp/>arguments<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>at<sp/>the<sp/>given</highlight></codeline>
<codeline><highlight class="normal">indices<sp/>(0-based)<sp/>to<sp/>the<sp/>inner<sp/>`action`<sp/>and<sp/>performs<sp/>it.<sp/>Using<sp/>`WithArgs`,<sp/>our</highlight></codeline>
<codeline><highlight class="normal">original<sp/>example<sp/>can<sp/>be<sp/>written<sp/>as:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::WithArgs;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(WithArgs&lt;0,<sp/>2,<sp/>3&gt;(Invoke(IsVisibleInQuadrant1)));<sp/><sp/>//<sp/>No<sp/>need<sp/>to<sp/>define<sp/>your<sp/>own<sp/>adaptor.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>better<sp/>readability,<sp/>gMock<sp/>also<sp/>gives<sp/>you:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>`WithoutArgs(action)`<sp/>when<sp/>the<sp/>inner<sp/>`action`<sp/>takes<sp/>*no*<sp/>argument,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>`WithArg&lt;N&gt;(action)`<sp/>(no<sp/>`s`<sp/>after<sp/>`Arg`)<sp/>when<sp/>the<sp/>inner<sp/>`action`<sp/>takes</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*one*<sp/>argument.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>you<sp/>may<sp/>have<sp/>realized,<sp/>`InvokeWithoutArgs(...)`<sp/>is<sp/>just<sp/>syntactic<sp/>sugar<sp/>for</highlight></codeline>
<codeline><highlight class="normal">`WithoutArgs(Invoke(...))`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Here<sp/>are<sp/>more<sp/>tips:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>The<sp/>inner<sp/>action<sp/>used<sp/>in<sp/>`WithArgs`<sp/>and<sp/>friends<sp/>does<sp/>not<sp/>have<sp/>to<sp/>be</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`Invoke()`<sp/>--<sp/>it<sp/>can<sp/>be<sp/>anything.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>You<sp/>can<sp/>repeat<sp/>an<sp/>argument<sp/>in<sp/>the<sp/>argument<sp/>list<sp/>if<sp/>necessary,<sp/>e.g.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`WithArgs&lt;2,<sp/>3,<sp/>3,<sp/>5&gt;(...)`.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>You<sp/>can<sp/>change<sp/>the<sp/>order<sp/>of<sp/>the<sp/>arguments,<sp/>e.g.<sp/>`WithArgs&lt;3,<sp/>2,<sp/>1&gt;(...)`.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>The<sp/>types<sp/>of<sp/>the<sp/>selected<sp/>arguments<sp/>do<sp/>*not*<sp/>have<sp/>to<sp/>match<sp/>the<sp/>signature<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>the<sp/>inner<sp/>action<sp/>exactly.<sp/>It<sp/>works<sp/>as<sp/>long<sp/>as<sp/>they<sp/>can<sp/>be<sp/>implicitly</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>converted<sp/>to<sp/>the<sp/>corresponding<sp/>arguments<sp/>of<sp/>the<sp/>inner<sp/>action.<sp/>For<sp/>example,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>the<sp/>4-th<sp/>argument<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>is<sp/>an<sp/>`int`<sp/>and<sp/>`my_action`<sp/>takes</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>a<sp/>`double`,<sp/>`WithArg&lt;4&gt;(my_action)`<sp/>will<sp/>work.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Ignoring<sp/>Arguments<sp/>in<sp/>Action<sp/>Functions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>[selecting-an-action&apos;s-arguments](#SelectingArgs)<sp/>recipe<sp/>showed<sp/>us<sp/>one<sp/>way</highlight></codeline>
<codeline><highlight class="normal">to<sp/>make<sp/>a<sp/>mock<sp/>function<sp/>and<sp/>an<sp/>action<sp/>with<sp/>incompatible<sp/>argument<sp/>lists<sp/>fit</highlight></codeline>
<codeline><highlight class="normal">together.<sp/>The<sp/>downside<sp/>is<sp/>that<sp/>wrapping<sp/>the<sp/>action<sp/>in<sp/>`WithArgs&lt;...&gt;()`<sp/>can<sp/>get</highlight></codeline>
<codeline><highlight class="normal">tedious<sp/>for<sp/>people<sp/>writing<sp/>the<sp/>tests.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>defining<sp/>a<sp/>function<sp/>(or<sp/>method,<sp/>functor,<sp/>lambda,<sp/>callback)<sp/>to<sp/>be<sp/>used</highlight></codeline>
<codeline><highlight class="normal">with<sp/>`Invoke*()`,<sp/>and<sp/>you<sp/>are<sp/>not<sp/>interested<sp/>in<sp/>some<sp/>of<sp/>its<sp/>arguments,<sp/>an</highlight></codeline>
<codeline><highlight class="normal">alternative<sp/>to<sp/>`WithArgs`<sp/>is<sp/>to<sp/>declare<sp/>the<sp/>uninteresting<sp/>arguments<sp/>as<sp/>`Unused`.</highlight></codeline>
<codeline><highlight class="normal">This<sp/>makes<sp/>the<sp/>definition<sp/>less<sp/>cluttered<sp/>and<sp/>less<sp/>fragile<sp/>in<sp/>case<sp/>the<sp/>types<sp/>of</highlight></codeline>
<codeline><highlight class="normal">the<sp/>uninteresting<sp/>arguments<sp/>change.<sp/>It<sp/>could<sp/>also<sp/>increase<sp/>the<sp/>chance<sp/>the<sp/>action</highlight></codeline>
<codeline><highlight class="normal">function<sp/>can<sp/>be<sp/>reused.<sp/>For<sp/>example,<sp/>given</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(double,<sp/>Foo,<sp/>double(const<sp/>string&amp;<sp/>label,<sp/>double<sp/>x,<sp/>double<sp/>y),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(double,<sp/>Bar,<sp/>(int<sp/>index,<sp/>double<sp/>x,<sp/>double<sp/>y),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">instead<sp/>of</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">double<sp/>DistanceToOriginWithLabel(const<sp/>string&amp;<sp/>label,<sp/>double<sp/>x,<sp/>double<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">double<sp/>DistanceToOriginWithIndex(int<sp/>index,<sp/>double<sp/>x,<sp/>double<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(&quot;abc&quot;,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOriginWithLabel));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(5,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOriginWithIndex));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">you<sp/>could<sp/>write</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Invoke;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Unused;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">double<sp/>DistanceToOrigin(Unused,<sp/>double<sp/>x,<sp/>double<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sqrt(x*x<sp/>+<sp/>y*y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(&quot;abc&quot;,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOrigin));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(5,<sp/>_,<sp/>_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Invoke(DistanceToOrigin));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Sharing<sp/>Actions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Just<sp/>like<sp/>matchers,<sp/>a<sp/>gMock<sp/>action<sp/>object<sp/>consists<sp/>of<sp/>a<sp/>pointer<sp/>to<sp/>a<sp/>ref-counted</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>object.<sp/>Therefore<sp/>copying<sp/>actions<sp/>is<sp/>also<sp/>allowed<sp/>and<sp/>very</highlight></codeline>
<codeline><highlight class="normal">efficient.<sp/>When<sp/>the<sp/>last<sp/>action<sp/>that<sp/>references<sp/>the<sp/>implementation<sp/>object<sp/>dies,</highlight></codeline>
<codeline><highlight class="normal">the<sp/>implementation<sp/>object<sp/>will<sp/>be<sp/>deleted.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>have<sp/>some<sp/>complex<sp/>action<sp/>that<sp/>you<sp/>want<sp/>to<sp/>use<sp/>again<sp/>and<sp/>again,<sp/>you<sp/>may</highlight></codeline>
<codeline><highlight class="normal">not<sp/>have<sp/>to<sp/>build<sp/>it<sp/>from<sp/>scratch<sp/>every<sp/>time.<sp/>If<sp/>the<sp/>action<sp/>doesn&apos;t<sp/>have<sp/>an</highlight></codeline>
<codeline><highlight class="normal">internal<sp/>state<sp/>(i.e.<sp/>if<sp/>it<sp/>always<sp/>does<sp/>the<sp/>same<sp/>thing<sp/>no<sp/>matter<sp/>how<sp/>many<sp/>times</highlight></codeline>
<codeline><highlight class="normal">it<sp/>has<sp/>been<sp/>called),<sp/>you<sp/>can<sp/>assign<sp/>it<sp/>to<sp/>an<sp/>action<sp/>variable<sp/>and<sp/>use<sp/>that</highlight></codeline>
<codeline><highlight class="normal">variable<sp/>repeatedly.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Action;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::DoAll;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::SetArgPointee;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Action&lt;bool(int*)&gt;<sp/>set_flag<sp/>=<sp/>DoAll(SetArgPointee&lt;0&gt;(5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Return(true));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>set_flag<sp/>in<sp/>.WillOnce()<sp/>and<sp/>.WillRepeatedly()<sp/>...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">However,<sp/>if<sp/>the<sp/>action<sp/>has<sp/>its<sp/>own<sp/>state,<sp/>you<sp/>may<sp/>be<sp/>surprised<sp/>if<sp/>you<sp/>share<sp/>the</highlight></codeline>
<codeline><highlight class="normal">action<sp/>object.<sp/>Suppose<sp/>you<sp/>have<sp/>an<sp/>action<sp/>factory<sp/>`IncrementCounter(init)`<sp/>which</highlight></codeline>
<codeline><highlight class="normal">creates<sp/>an<sp/>action<sp/>that<sp/>increments<sp/>and<sp/>returns<sp/>a<sp/>counter<sp/>whose<sp/>initial<sp/>value<sp/>is</highlight></codeline>
<codeline><highlight class="normal">`init`,<sp/>using<sp/>two<sp/>actions<sp/>created<sp/>from<sp/>the<sp/>same<sp/>expression<sp/>and<sp/>using<sp/>a<sp/>shared</highlight></codeline>
<codeline><highlight class="normal">action<sp/>will<sp/>exhibit<sp/>different<sp/>behaviors.<sp/>Example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(IncrementCounter(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(IncrementCounter(0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/>//<sp/>Returns<sp/>1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/>//<sp/>Returns<sp/>2.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat();<sp/><sp/>//<sp/>Returns<sp/>1<sp/>-<sp/>DoThat()<sp/>uses<sp/>a<sp/>different</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>counter<sp/>than<sp/>DoThis()&apos;s.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">versus</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Action;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Action&lt;int()&gt;<sp/>increment<sp/>=<sp/>IncrementCounter(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(increment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly(increment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/>//<sp/>Returns<sp/>1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis();<sp/><sp/>//<sp/>Returns<sp/>2.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat();<sp/><sp/>//<sp/>Returns<sp/>3<sp/>-<sp/>the<sp/>counter<sp/>is<sp/>shared.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Testing<sp/>Asynchronous<sp/>Behavior</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">One<sp/>oft-encountered<sp/>problem<sp/>with<sp/>gMock<sp/>is<sp/>that<sp/>it<sp/>can<sp/>be<sp/>hard<sp/>to<sp/>test</highlight></codeline>
<codeline><highlight class="normal">asynchronous<sp/>behavior.<sp/>Suppose<sp/>you<sp/>had<sp/>a<sp/>`EventQueue`<sp/>class<sp/>that<sp/>you<sp/>wanted<sp/>to</highlight></codeline>
<codeline><highlight class="normal">test,<sp/>and<sp/>you<sp/>created<sp/>a<sp/>separate<sp/>`EventDispatcher`<sp/>interface<sp/>so<sp/>that<sp/>you<sp/>could</highlight></codeline>
<codeline><highlight class="normal">easily<sp/>mock<sp/>it<sp/>out.<sp/>However,<sp/>the<sp/>implementation<sp/>of<sp/>the<sp/>class<sp/>fired<sp/>all<sp/>the</highlight></codeline>
<codeline><highlight class="normal">events<sp/>on<sp/>a<sp/>background<sp/>thread,<sp/>which<sp/>made<sp/>test<sp/>timings<sp/>difficult.<sp/>You<sp/>could<sp/>just</highlight></codeline>
<codeline><highlight class="normal">insert<sp/>`sleep()`<sp/>statements<sp/>and<sp/>hope<sp/>for<sp/>the<sp/>best,<sp/>but<sp/>that<sp/>makes<sp/>your<sp/>test</highlight></codeline>
<codeline><highlight class="normal">behavior<sp/>nondeterministic.<sp/>A<sp/>better<sp/>way<sp/>is<sp/>to<sp/>use<sp/>gMock<sp/>actions<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`Notification`<sp/>objects<sp/>to<sp/>force<sp/>your<sp/>asynchronous<sp/>test<sp/>to<sp/>behave<sp/>synchronously.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockEventDispatcher<sp/>:<sp/>public<sp/>EventDispatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>DispatchEvent,<sp/>(int32),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(EventQueueTest,<sp/>EnqueueEventTest)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockEventDispatcher<sp/>mock_event_dispatcher;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EventQueue<sp/>event_queue(&amp;mock_event_dispatcher);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int32<sp/>kEventId<sp/>=<sp/>321;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>absl::Notification<sp/>done;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_event_dispatcher,<sp/>DispatchEvent(kEventId))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce([&amp;done]<sp/>{<sp/>done.Notify();<sp/>});</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>event_queue.EnqueueEvent(kEventId);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>done.WaitForNotification();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>the<sp/>example<sp/>above,<sp/>we<sp/>set<sp/>our<sp/>normal<sp/>gMock<sp/>expectations,<sp/>but<sp/>then<sp/>add<sp/>an</highlight></codeline>
<codeline><highlight class="normal">additional<sp/>action<sp/>to<sp/>notify<sp/>the<sp/>`Notification`<sp/>object.<sp/>Now<sp/>we<sp/>can<sp/>just<sp/>call</highlight></codeline>
<codeline><highlight class="normal">`Notification::WaitForNotification()`<sp/>in<sp/>the<sp/>main<sp/>thread<sp/>to<sp/>wait<sp/>for<sp/>the</highlight></codeline>
<codeline><highlight class="normal">asynchronous<sp/>call<sp/>to<sp/>finish.<sp/>After<sp/>that,<sp/>our<sp/>test<sp/>suite<sp/>is<sp/>complete<sp/>and<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal">safely<sp/>exit.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.note}</highlight></codeline>
<codeline><highlight class="normal">Note:<sp/>this<sp/>example<sp/>has<sp/>a<sp/>downside:<sp/>namely,<sp/>if<sp/>the<sp/>expectation<sp/>is<sp/>not<sp/>satisfied,</highlight></codeline>
<codeline><highlight class="normal">our<sp/>test<sp/>will<sp/>run<sp/>forever.<sp/>It<sp/>will<sp/>eventually<sp/>time-out<sp/>and<sp/>fail,<sp/>but<sp/>it<sp/>will</highlight></codeline>
<codeline><highlight class="normal">take<sp/>longer<sp/>and<sp/>be<sp/>slightly<sp/>harder<sp/>to<sp/>debug.<sp/>To<sp/>alleviate<sp/>this<sp/>problem,<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">use<sp/>`WaitForNotificationWithTimeout(ms)`<sp/>instead<sp/>of<sp/>`WaitForNotification()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Misc<sp/>Recipes<sp/>on<sp/>Using<sp/>gMock</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mocking<sp/>Methods<sp/>That<sp/>Use<sp/>Move-Only<sp/>Types</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">C++11<sp/>introduced<sp/>*move-only<sp/>types*.<sp/>A<sp/>move-only-typed<sp/>value<sp/>can<sp/>be<sp/>moved<sp/>from</highlight></codeline>
<codeline><highlight class="normal">one<sp/>object<sp/>to<sp/>another,<sp/>but<sp/>cannot<sp/>be<sp/>copied.<sp/>`std::unique_ptr&lt;T&gt;`<sp/>is<sp/>probably</highlight></codeline>
<codeline><highlight class="normal">the<sp/>most<sp/>commonly<sp/>used<sp/>move-only<sp/>type.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Mocking<sp/>a<sp/>method<sp/>that<sp/>takes<sp/>and/or<sp/>returns<sp/>move-only<sp/>types<sp/>presents<sp/>some</highlight></codeline>
<codeline><highlight class="normal">challenges,<sp/>but<sp/>nothing<sp/>insurmountable.<sp/>This<sp/>recipe<sp/>shows<sp/>you<sp/>how<sp/>you<sp/>can<sp/>do<sp/>it.</highlight></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>support<sp/>for<sp/>move-only<sp/>method<sp/>arguments<sp/>was<sp/>only<sp/>introduced<sp/>to</highlight></codeline>
<codeline><highlight class="normal">gMock<sp/>in<sp/>April<sp/>2017;<sp/>in<sp/>older<sp/>code,<sp/>you<sp/>may<sp/>find<sp/>more<sp/>complex</highlight></codeline>
<codeline><highlight class="normal">[workarounds](#LegacyMoveOnly)<sp/>for<sp/>lack<sp/>of<sp/>this<sp/>feature.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Let’s<sp/>say<sp/>we<sp/>are<sp/>working<sp/>on<sp/>a<sp/>fictional<sp/>project<sp/>that<sp/>lets<sp/>one<sp/>post<sp/>and<sp/>share</highlight></codeline>
<codeline><highlight class="normal">snippets<sp/>called<sp/>“buzzes”.<sp/>Your<sp/>code<sp/>uses<sp/>these<sp/>types:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">enum<sp/>class<sp/>AccessLevel<sp/>{<sp/>kInternal,<sp/>kPublic<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>Buzz<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>explicit<sp/>Buzz(AccessLevel<sp/>access)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~Buzzer()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>std::unique_ptr&lt;Buzz&gt;<sp/>MakeBuzz(StringPiece<sp/>text)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>ShareBuzz(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>int64_t<sp/>timestamp)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>`Buzz`<sp/>object<sp/>represents<sp/>a<sp/>snippet<sp/>being<sp/>posted.<sp/>A<sp/>class<sp/>that<sp/>implements<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`Buzzer`<sp/>interface<sp/>is<sp/>capable<sp/>of<sp/>creating<sp/>and<sp/>sharing<sp/>`Buzz`es.<sp/>Methods<sp/>in</highlight></codeline>
<codeline><highlight class="normal">`Buzzer`<sp/>may<sp/>return<sp/>a<sp/>`unique_ptr&lt;Buzz&gt;`<sp/>or<sp/>take<sp/>a<sp/>`unique_ptr&lt;Buzz&gt;`.<sp/>Now<sp/>we</highlight></codeline>
<codeline><highlight class="normal">need<sp/>to<sp/>mock<sp/>`Buzzer`<sp/>in<sp/>our<sp/>tests.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>mock<sp/>a<sp/>method<sp/>that<sp/>accepts<sp/>or<sp/>returns<sp/>move-only<sp/>types,<sp/>you<sp/>just<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">familiar<sp/>`MOCK_METHOD`<sp/>syntax<sp/>as<sp/>usual:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockBuzzer<sp/>:<sp/>public<sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(std::unique_ptr&lt;Buzz&gt;,<sp/>MakeBuzz,<sp/>(StringPiece<sp/>text),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>ShareBuzz,<sp/>(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>int64_t<sp/>timestamp),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>mock<sp/>class<sp/>defined,<sp/>we<sp/>can<sp/>use<sp/>it<sp/>in<sp/>tests.<sp/>In<sp/>the</highlight></codeline>
<codeline><highlight class="normal">following<sp/>code<sp/>examples,<sp/>we<sp/>assume<sp/>that<sp/>we<sp/>have<sp/>defined<sp/>a<sp/>`MockBuzzer`<sp/>object</highlight></codeline>
<codeline><highlight class="normal">named<sp/>`mock_buzzer_`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockBuzzer<sp/>mock_buzzer_;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">First<sp/>let’s<sp/>see<sp/>how<sp/>we<sp/>can<sp/>set<sp/>expectations<sp/>on<sp/>the<sp/>`MakeBuzz()`<sp/>method,<sp/>which</highlight></codeline>
<codeline><highlight class="normal">returns<sp/>a<sp/>`unique_ptr&lt;Buzz&gt;`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>usual,<sp/>if<sp/>you<sp/>set<sp/>an<sp/>expectation<sp/>without<sp/>an<sp/>action<sp/>(i.e.<sp/>the<sp/>`.WillOnce()`<sp/>or</highlight></codeline>
<codeline><highlight class="normal">`.WillRepeatedly()`<sp/>clause),<sp/>when<sp/>that<sp/>expectation<sp/>fires,<sp/>the<sp/>default<sp/>action<sp/>for</highlight></codeline>
<codeline><highlight class="normal">that<sp/>method<sp/>will<sp/>be<sp/>taken.<sp/>Since<sp/>`unique_ptr&lt;&gt;`<sp/>has<sp/>a<sp/>default<sp/>constructor<sp/>that</highlight></codeline>
<codeline><highlight class="normal">returns<sp/>a<sp/>null<sp/>`unique_ptr`,<sp/>that’s<sp/>what<sp/>you’ll<sp/>get<sp/>if<sp/>you<sp/>don’t<sp/>specify<sp/>an</highlight></codeline>
<codeline><highlight class="normal">action:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::IsNull;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Use<sp/>the<sp/>default<sp/>action.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(&quot;hello&quot;));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Triggers<sp/>the<sp/>previous<sp/>EXPECT_CALL.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(mock_buzzer_.MakeBuzz(&quot;hello&quot;),<sp/>IsNull());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>not<sp/>happy<sp/>with<sp/>the<sp/>default<sp/>action,<sp/>you<sp/>can<sp/>tweak<sp/>it<sp/>as<sp/>usual;<sp/>see</highlight></codeline>
<codeline><highlight class="normal">[Setting<sp/>Default<sp/>Actions](#OnCall).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>just<sp/>need<sp/>to<sp/>return<sp/>a<sp/>move-only<sp/>value,<sp/>you<sp/>can<sp/>use<sp/>it<sp/>in<sp/>combination<sp/>with</highlight></codeline>
<codeline><highlight class="normal">`WillOnce`.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(&quot;hello&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(Return(std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>mock_buzzer_.MakeBuzz(&quot;hello&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Quiz<sp/>time!<sp/>What<sp/>do<sp/>you<sp/>think<sp/>will<sp/>happen<sp/>if<sp/>a<sp/>`Return`<sp/>action<sp/>is<sp/>performed<sp/>more</highlight></codeline>
<codeline><highlight class="normal">than<sp/>once<sp/>(e.g.<sp/>you<sp/>write<sp/>`...<sp/>.WillRepeatedly(Return(std::move(...)));`)?<sp/>Come</highlight></codeline>
<codeline><highlight class="normal">think<sp/>of<sp/>it,<sp/>after<sp/>the<sp/>first<sp/>time<sp/>the<sp/>action<sp/>runs,<sp/>the<sp/>source<sp/>value<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">consumed<sp/>(since<sp/>it’s<sp/>a<sp/>move-only<sp/>value),<sp/>so<sp/>the<sp/>next<sp/>time<sp/>around,<sp/>there’s<sp/>no</highlight></codeline>
<codeline><highlight class="normal">value<sp/>to<sp/>move<sp/>from<sp/>--<sp/>you’ll<sp/>get<sp/>a<sp/>run-time<sp/>error<sp/>that<sp/>`Return(std::move(...))`</highlight></codeline>
<codeline><highlight class="normal">can<sp/>only<sp/>be<sp/>run<sp/>once.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>need<sp/>your<sp/>mock<sp/>method<sp/>to<sp/>do<sp/>more<sp/>than<sp/>just<sp/>moving<sp/>a<sp/>pre-defined<sp/>value,</highlight></codeline>
<codeline><highlight class="normal">remember<sp/>that<sp/>you<sp/>can<sp/>always<sp/>use<sp/>a<sp/>lambda<sp/>or<sp/>a<sp/>callable<sp/>object,<sp/>which<sp/>can<sp/>do</highlight></codeline>
<codeline><highlight class="normal">pretty<sp/>much<sp/>anything<sp/>you<sp/>want:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>MakeBuzz(&quot;x&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillRepeatedly([](StringPiece<sp/>text)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>mock_buzzer_.MakeBuzz(&quot;x&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_NE(nullptr,<sp/>mock_buzzer_.MakeBuzz(&quot;x&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Every<sp/>time<sp/>this<sp/>`EXPECT_CALL`<sp/>fires,<sp/>a<sp/>new<sp/>`unique_ptr&lt;Buzz&gt;`<sp/>will<sp/>be<sp/>created</highlight></codeline>
<codeline><highlight class="normal">and<sp/>returned.<sp/>You<sp/>cannot<sp/>do<sp/>this<sp/>with<sp/>`Return(std::make_unique&lt;...&gt;(...))`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">That<sp/>covers<sp/>returning<sp/>move-only<sp/>values;<sp/>but<sp/>how<sp/>do<sp/>we<sp/>work<sp/>with<sp/>methods</highlight></codeline>
<codeline><highlight class="normal">accepting<sp/>move-only<sp/>arguments?<sp/>The<sp/>answer<sp/>is<sp/>that<sp/>they<sp/>work<sp/>normally,<sp/>although</highlight></codeline>
<codeline><highlight class="normal">some<sp/>actions<sp/>will<sp/>not<sp/>compile<sp/>when<sp/>any<sp/>of<sp/>method&apos;s<sp/>arguments<sp/>are<sp/>move-only.<sp/>You</highlight></codeline>
<codeline><highlight class="normal">can<sp/>always<sp/>use<sp/>`Return`,<sp/>or<sp/>a<sp/>[lambda<sp/>or<sp/>functor](#FunctionsAsActions):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::Unused;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>ShareBuzz(NotNull(),<sp/>_)).WillOnce(Return(true));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_TRUE(mock_buzzer_.ShareBuzz(std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>ShareBuzz(_,<sp/>_)).WillOnce(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>[](std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>Unused)<sp/>{<sp/>return<sp/>buzz<sp/>!=<sp/>nullptr;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_FALSE(mock_buzzer_.ShareBuzz(nullptr,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Many<sp/>built-in<sp/>actions<sp/>(`WithArgs`,<sp/>`WithoutArgs`,`DeleteArg`,<sp/>`SaveArg`,<sp/>...)</highlight></codeline>
<codeline><highlight class="normal">could<sp/>in<sp/>principle<sp/>support<sp/>move-only<sp/>arguments,<sp/>but<sp/>the<sp/>support<sp/>for<sp/>this<sp/>is<sp/>not</highlight></codeline>
<codeline><highlight class="normal">implemented<sp/>yet.<sp/>If<sp/>this<sp/>is<sp/>blocking<sp/>you,<sp/>please<sp/>file<sp/>a<sp/>bug.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>few<sp/>actions<sp/>(e.g.<sp/>`DoAll`)<sp/>copy<sp/>their<sp/>arguments<sp/>internally,<sp/>so<sp/>they<sp/>can<sp/>never</highlight></codeline>
<codeline><highlight class="normal">work<sp/>with<sp/>non-copyable<sp/>objects;<sp/>you&apos;ll<sp/>have<sp/>to<sp/>use<sp/>functors<sp/>instead.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">####<sp/>Legacy<sp/>workarounds<sp/>for<sp/>move-only<sp/>types<sp/>{#LegacyMoveOnly}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Support<sp/>for<sp/>move-only<sp/>function<sp/>arguments<sp/>was<sp/>only<sp/>introduced<sp/>to<sp/>gMock<sp/>in<sp/>April</highlight></codeline>
<codeline><highlight class="normal">of<sp/>2017.<sp/>In<sp/>older<sp/>code,<sp/>you<sp/>may<sp/>encounter<sp/>the<sp/>following<sp/>workaround<sp/>for<sp/>the<sp/>lack</highlight></codeline>
<codeline><highlight class="normal">of<sp/>this<sp/>feature<sp/>(it<sp/>is<sp/>no<sp/>longer<sp/>necessary<sp/>-<sp/>we&apos;re<sp/>including<sp/>it<sp/>just<sp/>for</highlight></codeline>
<codeline><highlight class="normal">reference):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockBuzzer<sp/>:<sp/>public<sp/>Buzzer<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>DoShareBuzz,<sp/>(Buzz*<sp/>buzz,<sp/>Time<sp/>timestamp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>ShareBuzz(std::unique_ptr&lt;Buzz&gt;<sp/>buzz,<sp/>Time<sp/>timestamp)<sp/>override<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>DoShareBuzz(buzz.get(),<sp/>timestamp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>trick<sp/>is<sp/>to<sp/>delegate<sp/>the<sp/>`ShareBuzz()`<sp/>method<sp/>to<sp/>a<sp/>mock<sp/>method<sp/>(let’s<sp/>call</highlight></codeline>
<codeline><highlight class="normal">it<sp/>`DoShareBuzz()`)<sp/>that<sp/>does<sp/>not<sp/>take<sp/>move-only<sp/>parameters.<sp/>Then,<sp/>instead<sp/>of</highlight></codeline>
<codeline><highlight class="normal">setting<sp/>expectations<sp/>on<sp/>`ShareBuzz()`,<sp/>you<sp/>set<sp/>them<sp/>on<sp/>the<sp/>`DoShareBuzz()`<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">method:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockBuzzer<sp/>mock_buzzer_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_buzzer_,<sp/>DoShareBuzz(NotNull(),<sp/>_));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>When<sp/>one<sp/>calls<sp/>ShareBuzz()<sp/>on<sp/>the<sp/>MockBuzzer<sp/>like<sp/>this,<sp/>the<sp/>call<sp/>is</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>forwarded<sp/>to<sp/>DoShareBuzz(),<sp/>which<sp/>is<sp/>mocked.<sp/><sp/>Therefore<sp/>this<sp/>statement</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>will<sp/>trigger<sp/>the<sp/>above<sp/>EXPECT_CALL.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock_buzzer_.ShareBuzz(std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal),<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Making<sp/>the<sp/>Compilation<sp/>Faster</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Believe<sp/>it<sp/>or<sp/>not,<sp/>the<sp/>*vast<sp/>majority*<sp/>of<sp/>the<sp/>time<sp/>spent<sp/>on<sp/>compiling<sp/>a<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">class<sp/>is<sp/>in<sp/>generating<sp/>its<sp/>constructor<sp/>and<sp/>destructor,<sp/>as<sp/>they<sp/>perform</highlight></codeline>
<codeline><highlight class="normal">non-trivial<sp/>tasks<sp/>(e.g.<sp/>verification<sp/>of<sp/>the<sp/>expectations).<sp/>What&apos;s<sp/>more,<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">methods<sp/>with<sp/>different<sp/>signatures<sp/>have<sp/>different<sp/>types<sp/>and<sp/>thus<sp/>their</highlight></codeline>
<codeline><highlight class="normal">constructors/destructors<sp/>need<sp/>to<sp/>be<sp/>generated<sp/>by<sp/>the<sp/>compiler<sp/>separately.<sp/>As<sp/>a</highlight></codeline>
<codeline><highlight class="normal">result,<sp/>if<sp/>you<sp/>mock<sp/>many<sp/>different<sp/>types<sp/>of<sp/>methods,<sp/>compiling<sp/>your<sp/>mock<sp/>class</highlight></codeline>
<codeline><highlight class="normal">can<sp/>get<sp/>really<sp/>slow.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>experiencing<sp/>slow<sp/>compilation,<sp/>you<sp/>can<sp/>move<sp/>the<sp/>definition<sp/>of<sp/>your</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>class&apos;<sp/>constructor<sp/>and<sp/>destructor<sp/>out<sp/>of<sp/>the<sp/>class<sp/>body<sp/>and<sp/>into<sp/>a<sp/>`.cc`</highlight></codeline>
<codeline><highlight class="normal">file.<sp/>This<sp/>way,<sp/>even<sp/>if<sp/>you<sp/>`#include`<sp/>your<sp/>mock<sp/>class<sp/>in<sp/>N<sp/>files,<sp/>the<sp/>compiler</highlight></codeline>
<codeline><highlight class="normal">only<sp/>needs<sp/>to<sp/>generate<sp/>its<sp/>constructor<sp/>and<sp/>destructor<sp/>once,<sp/>resulting<sp/>in<sp/>a<sp/>much</highlight></codeline>
<codeline><highlight class="normal">faster<sp/>compilation.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Let&apos;s<sp/>illustrate<sp/>the<sp/>idea<sp/>using<sp/>an<sp/>example.<sp/>Here&apos;s<sp/>the<sp/>definition<sp/>of<sp/>a<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">class<sp/>before<sp/>applying<sp/>this<sp/>recipe:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>File<sp/>mock_foo.h.</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Since<sp/>we<sp/>don&apos;t<sp/>declare<sp/>the<sp/>constructor<sp/>or<sp/>the<sp/>destructor,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>the<sp/>compiler<sp/>will<sp/>generate<sp/>them<sp/>in<sp/>every<sp/>translation<sp/>unit</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>where<sp/>this<sp/>mock<sp/>class<sp/>is<sp/>used.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>DoThis,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>DoThat,<sp/>(const<sp/>char*<sp/>str),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>more<sp/>mock<sp/>methods<sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">After<sp/>the<sp/>change,<sp/>it<sp/>would<sp/>look<sp/>like:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>File<sp/>mock_foo.h.</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>constructor<sp/>and<sp/>destructor<sp/>are<sp/>declared,<sp/>but<sp/>not<sp/>defined,<sp/>here.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~MockFoo();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>DoThis,<sp/>(),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(bool,<sp/>DoThat,<sp/>(const<sp/>char*<sp/>str),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>more<sp/>mock<sp/>methods<sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">and</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>File<sp/>mock_foo.cc.</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;path/to/mock_foo.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>definitions<sp/>may<sp/>appear<sp/>trivial,<sp/>but<sp/>the<sp/>functions<sp/>actually<sp/>do<sp/>a</highlight></codeline>
<codeline><highlight class="normal">//<sp/>lot<sp/>of<sp/>things<sp/>through<sp/>the<sp/>constructors/destructors<sp/>of<sp/>the<sp/>member</highlight></codeline>
<codeline><highlight class="normal">//<sp/>variables<sp/>used<sp/>to<sp/>implement<sp/>the<sp/>mock<sp/>methods.</highlight></codeline>
<codeline><highlight class="normal">MockFoo::MockFoo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">MockFoo::~MockFoo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Forcing<sp/>a<sp/>Verification</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>it&apos;s<sp/>being<sp/>destroyed,<sp/>your<sp/>friendly<sp/>mock<sp/>object<sp/>will<sp/>automatically<sp/>verify</highlight></codeline>
<codeline><highlight class="normal">that<sp/>all<sp/>expectations<sp/>on<sp/>it<sp/>have<sp/>been<sp/>satisfied,<sp/>and<sp/>will<sp/>generate<sp/>googletest</highlight></codeline>
<codeline><highlight class="normal">failures<sp/>if<sp/>not.<sp/>This<sp/>is<sp/>convenient<sp/>as<sp/>it<sp/>leaves<sp/>you<sp/>with<sp/>one<sp/>less<sp/>thing<sp/>to</highlight></codeline>
<codeline><highlight class="normal">worry<sp/>about.<sp/>That<sp/>is,<sp/>unless<sp/>you<sp/>are<sp/>not<sp/>sure<sp/>if<sp/>your<sp/>mock<sp/>object<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">destroyed.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">How<sp/>could<sp/>it<sp/>be<sp/>that<sp/>your<sp/>mock<sp/>object<sp/>won&apos;t<sp/>eventually<sp/>be<sp/>destroyed?<sp/>Well,<sp/>it</highlight></codeline>
<codeline><highlight class="normal">might<sp/>be<sp/>created<sp/>on<sp/>the<sp/>heap<sp/>and<sp/>owned<sp/>by<sp/>the<sp/>code<sp/>you<sp/>are<sp/>testing.<sp/>Suppose</highlight></codeline>
<codeline><highlight class="normal">there&apos;s<sp/>a<sp/>bug<sp/>in<sp/>that<sp/>code<sp/>and<sp/>it<sp/>doesn&apos;t<sp/>delete<sp/>the<sp/>mock<sp/>object<sp/>properly<sp/>-<sp/>you</highlight></codeline>
<codeline><highlight class="normal">could<sp/>end<sp/>up<sp/>with<sp/>a<sp/>passing<sp/>test<sp/>when<sp/>there&apos;s<sp/>actually<sp/>a<sp/>bug.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Using<sp/>a<sp/>heap<sp/>checker<sp/>is<sp/>a<sp/>good<sp/>idea<sp/>and<sp/>can<sp/>alleviate<sp/>the<sp/>concern,<sp/>but<sp/>its</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>is<sp/>not<sp/>100%<sp/>reliable.<sp/>So,<sp/>sometimes<sp/>you<sp/>do<sp/>want<sp/>to<sp/>*force*<sp/>gMock</highlight></codeline>
<codeline><highlight class="normal">to<sp/>verify<sp/>a<sp/>mock<sp/>object<sp/>before<sp/>it<sp/>is<sp/>(hopefully)<sp/>destructed.<sp/>You<sp/>can<sp/>do<sp/>this</highlight></codeline>
<codeline><highlight class="normal">with<sp/>`Mock::VerifyAndClearExpectations(&amp;mock_object)`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">TEST(MyServerTest,<sp/>ProcessesRequest)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::Mock;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo*<sp/>const<sp/>foo<sp/>=<sp/>new<sp/>MockFoo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(*foo,<sp/>...)...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...<sp/>other<sp/>expectations<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>server<sp/>now<sp/>owns<sp/>foo.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyServer<sp/>server(foo);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>server.ProcessRequest(...);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>In<sp/>case<sp/>that<sp/>server&apos;s<sp/>destructor<sp/>will<sp/>forget<sp/>to<sp/>delete<sp/>foo,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>this<sp/>will<sp/>verify<sp/>the<sp/>expectations<sp/>anyway.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mock::VerifyAndClearExpectations(foo);</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/>//<sp/>server<sp/>is<sp/>destroyed<sp/>when<sp/>it<sp/>goes<sp/>out<sp/>of<sp/>scope<sp/>here.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.tip}</highlight></codeline>
<codeline><highlight class="normal">**Tip:**<sp/>The<sp/>`Mock::VerifyAndClearExpectations()`<sp/>function<sp/>returns<sp/>a<sp/>`bool`<sp/>to</highlight></codeline>
<codeline><highlight class="normal">indicate<sp/>whether<sp/>the<sp/>verification<sp/>was<sp/>successful<sp/>(`true`<sp/>for<sp/>yes),<sp/>so<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">wrap<sp/>that<sp/>function<sp/>call<sp/>inside<sp/>a<sp/>`ASSERT_TRUE()`<sp/>if<sp/>there<sp/>is<sp/>no<sp/>point<sp/>going</highlight></codeline>
<codeline><highlight class="normal">further<sp/>when<sp/>the<sp/>verification<sp/>has<sp/>failed.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Do<sp/>not<sp/>set<sp/>new<sp/>expectations<sp/>after<sp/>verifying<sp/>and<sp/>clearing<sp/>a<sp/>mock<sp/>after<sp/>its<sp/>use.</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>expectations<sp/>after<sp/>code<sp/>that<sp/>exercises<sp/>the<sp/>mock<sp/>has<sp/>undefined<sp/>behavior.</highlight></codeline>
<codeline><highlight class="normal">See<sp/>[Using<sp/>Mocks<sp/>in<sp/>Tests](gmock_for_dummies.md#using-mocks-in-tests)<sp/>for<sp/>more</highlight></codeline>
<codeline><highlight class="normal">information.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>Checkpoints<sp/>{#UsingCheckPoints}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>might<sp/>want<sp/>to<sp/>test<sp/>a<sp/>mock<sp/>object&apos;s<sp/>behavior<sp/>in<sp/>phases<sp/>whose<sp/>sizes</highlight></codeline>
<codeline><highlight class="normal">are<sp/>each<sp/>manageable,<sp/>or<sp/>you<sp/>might<sp/>want<sp/>to<sp/>set<sp/>more<sp/>detailed<sp/>expectations<sp/>about</highlight></codeline>
<codeline><highlight class="normal">which<sp/>API<sp/>calls<sp/>invoke<sp/>which<sp/>mock<sp/>functions.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>technique<sp/>you<sp/>can<sp/>use<sp/>is<sp/>to<sp/>put<sp/>the<sp/>expectations<sp/>in<sp/>a<sp/>sequence<sp/>and<sp/>insert</highlight></codeline>
<codeline><highlight class="normal">calls<sp/>to<sp/>a<sp/>dummy<sp/>&quot;checkpoint&quot;<sp/>function<sp/>at<sp/>specific<sp/>places.<sp/>Then<sp/>you<sp/>can<sp/>verify</highlight></codeline>
<codeline><highlight class="normal">that<sp/>the<sp/>mock<sp/>function<sp/>calls<sp/>do<sp/>happen<sp/>at<sp/>the<sp/>right<sp/>time.<sp/>For<sp/>example,<sp/>if<sp/>you</highlight></codeline>
<codeline><highlight class="normal">are<sp/>exercising<sp/>the<sp/>code:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(3);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">and<sp/>want<sp/>to<sp/>verify<sp/>that<sp/>`Foo(1)`<sp/>and<sp/>`Foo(3)`<sp/>both<sp/>invoke<sp/>`mock.Bar(&quot;a&quot;)`,<sp/>but</highlight></codeline>
<codeline><highlight class="normal">`Foo(2)`<sp/>doesn&apos;t<sp/>invoke<sp/>anything,<sp/>you<sp/>can<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MockFunction;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(FooTest,<sp/>InvokesBarCorrectly)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyMock<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Class<sp/>MockFunction&lt;F&gt;<sp/>has<sp/>exactly<sp/>one<sp/>mock<sp/>method.<sp/><sp/>It<sp/>is<sp/>named</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Call()<sp/>and<sp/>has<sp/>type<sp/>F.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFunction&lt;void(string<sp/>check_point_name)&gt;<sp/>check;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(&quot;a&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(check,<sp/>Call(&quot;1&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(check,<sp/>Call(&quot;2&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(mock,<sp/>Bar(&quot;a&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>check.Call(&quot;1&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>check.Call(&quot;2&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(3);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>expectation<sp/>spec<sp/>says<sp/>that<sp/>the<sp/>first<sp/>`Bar(&quot;a&quot;)`<sp/>call<sp/>must<sp/>happen<sp/>before</highlight></codeline>
<codeline><highlight class="normal">checkpoint<sp/>&quot;1&quot;,<sp/>the<sp/>second<sp/>`Bar(&quot;a&quot;)`<sp/>call<sp/>must<sp/>happen<sp/>after<sp/>checkpoint<sp/>&quot;2&quot;,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">nothing<sp/>should<sp/>happen<sp/>between<sp/>the<sp/>two<sp/>checkpoints.<sp/>The<sp/>explicit<sp/>checkpoints<sp/>make</highlight></codeline>
<codeline><highlight class="normal">it<sp/>clear<sp/>which<sp/>`Bar(&quot;a&quot;)`<sp/>is<sp/>called<sp/>by<sp/>which<sp/>call<sp/>to<sp/>`Foo()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mocking<sp/>Destructors</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>want<sp/>to<sp/>make<sp/>sure<sp/>a<sp/>mock<sp/>object<sp/>is<sp/>destructed<sp/>at<sp/>the<sp/>right<sp/>time,</highlight></codeline>
<codeline><highlight class="normal">e.g.<sp/>after<sp/>`bar-&gt;A()`<sp/>is<sp/>called<sp/>but<sp/>before<sp/>`bar-&gt;B()`<sp/>is<sp/>called.<sp/>We<sp/>already<sp/>know</highlight></codeline>
<codeline><highlight class="normal">that<sp/>you<sp/>can<sp/>specify<sp/>constraints<sp/>on<sp/>the<sp/>[order](#OrderedCalls)<sp/>of<sp/>mock<sp/>function</highlight></codeline>
<codeline><highlight class="normal">calls,<sp/>so<sp/>all<sp/>we<sp/>need<sp/>to<sp/>do<sp/>is<sp/>to<sp/>mock<sp/>the<sp/>destructor<sp/>of<sp/>the<sp/>mock<sp/>function.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>sounds<sp/>simple,<sp/>except<sp/>for<sp/>one<sp/>problem:<sp/>a<sp/>destructor<sp/>is<sp/>a<sp/>special<sp/>function</highlight></codeline>
<codeline><highlight class="normal">with<sp/>special<sp/>syntax<sp/>and<sp/>special<sp/>semantics,<sp/>and<sp/>the<sp/>`MOCK_METHOD`<sp/>macro<sp/>doesn&apos;t</highlight></codeline>
<codeline><highlight class="normal">work<sp/>for<sp/>it:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MOCK_METHOD(void,<sp/>~MockFoo,<sp/>());<sp/><sp/>//<sp/>Won&apos;t<sp/>compile!</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>good<sp/>news<sp/>is<sp/>that<sp/>you<sp/>can<sp/>use<sp/>a<sp/>simple<sp/>pattern<sp/>to<sp/>achieve<sp/>the<sp/>same<sp/>effect.</highlight></codeline>
<codeline><highlight class="normal">First,<sp/>add<sp/>a<sp/>mock<sp/>function<sp/>`Die()`<sp/>to<sp/>your<sp/>mock<sp/>class<sp/>and<sp/>call<sp/>it<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">destructor,<sp/>like<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Add<sp/>the<sp/>following<sp/>two<sp/>lines<sp/>to<sp/>the<sp/>mock<sp/>class.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>Die,<sp/>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>~MockFoo()<sp/>override<sp/>{<sp/>Die();<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">(If<sp/>the<sp/>name<sp/>`Die()`<sp/>clashes<sp/>with<sp/>an<sp/>existing<sp/>symbol,<sp/>choose<sp/>another<sp/>name.)<sp/>Now,</highlight></codeline>
<codeline><highlight class="normal">we<sp/>have<sp/>translated<sp/>the<sp/>problem<sp/>of<sp/>testing<sp/>when<sp/>a<sp/>`MockFoo`<sp/>object<sp/>dies<sp/>to</highlight></codeline>
<codeline><highlight class="normal">testing<sp/>when<sp/>its<sp/>`Die()`<sp/>method<sp/>is<sp/>called:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo*<sp/>foo<sp/>=<sp/>new<sp/>MockFoo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockBar*<sp/>bar<sp/>=<sp/>new<sp/>MockBar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InSequence<sp/>s;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Expects<sp/>*foo<sp/>to<sp/>die<sp/>after<sp/>bar-&gt;A()<sp/>and<sp/>before<sp/>bar-&gt;B().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(*bar,<sp/>A());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(*foo,<sp/>Die());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EXPECT_CALL(*bar,<sp/>B());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">And<sp/>that&apos;s<sp/>that.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>gMock<sp/>and<sp/>Threads<sp/>{#UsingThreads}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>a<sp/>**unit**<sp/>test,<sp/>it&apos;s<sp/>best<sp/>if<sp/>you<sp/>could<sp/>isolate<sp/>and<sp/>test<sp/>a<sp/>piece<sp/>of<sp/>code<sp/>in<sp/>a</highlight></codeline>
<codeline><highlight class="normal">single-threaded<sp/>context.<sp/>That<sp/>avoids<sp/>race<sp/>conditions<sp/>and<sp/>dead<sp/>locks,<sp/>and<sp/>makes</highlight></codeline>
<codeline><highlight class="normal">debugging<sp/>your<sp/>test<sp/>much<sp/>easier.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Yet<sp/>most<sp/>programs<sp/>are<sp/>multi-threaded,<sp/>and<sp/>sometimes<sp/>to<sp/>test<sp/>something<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal">pound<sp/>on<sp/>it<sp/>from<sp/>more<sp/>than<sp/>one<sp/>thread.<sp/>gMock<sp/>works<sp/>for<sp/>this<sp/>purpose<sp/>too.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remember<sp/>the<sp/>steps<sp/>for<sp/>using<sp/>a<sp/>mock:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/><sp/>Create<sp/>a<sp/>mock<sp/>object<sp/>`foo`.</highlight></codeline>
<codeline><highlight class="normal">2.<sp/><sp/>Set<sp/>its<sp/>default<sp/>actions<sp/>and<sp/>expectations<sp/>using<sp/>`ON_CALL()`<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`EXPECT_CALL()`.</highlight></codeline>
<codeline><highlight class="normal">3.<sp/><sp/>The<sp/>code<sp/>under<sp/>test<sp/>calls<sp/>methods<sp/>of<sp/>`foo`.</highlight></codeline>
<codeline><highlight class="normal">4.<sp/><sp/>Optionally,<sp/>verify<sp/>and<sp/>reset<sp/>the<sp/>mock.</highlight></codeline>
<codeline><highlight class="normal">5.<sp/><sp/>Destroy<sp/>the<sp/>mock<sp/>yourself,<sp/>or<sp/>let<sp/>the<sp/>code<sp/>under<sp/>test<sp/>destroy<sp/>it.<sp/>The</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>destructor<sp/>will<sp/>automatically<sp/>verify<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>follow<sp/>the<sp/>following<sp/>simple<sp/>rules,<sp/>your<sp/>mocks<sp/>and<sp/>threads<sp/>can<sp/>live</highlight></codeline>
<codeline><highlight class="normal">happily<sp/>together:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>Execute<sp/>your<sp/>*test<sp/>code*<sp/>(as<sp/>opposed<sp/>to<sp/>the<sp/>code<sp/>being<sp/>tested)<sp/>in<sp/>*one*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>thread.<sp/>This<sp/>makes<sp/>your<sp/>test<sp/>easy<sp/>to<sp/>follow.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>Obviously,<sp/>you<sp/>can<sp/>do<sp/>step<sp/>#1<sp/>without<sp/>locking.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>When<sp/>doing<sp/>step<sp/>#2<sp/>and<sp/>#5,<sp/>make<sp/>sure<sp/>no<sp/>other<sp/>thread<sp/>is<sp/>accessing<sp/>`foo`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Obvious<sp/>too,<sp/>huh?</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>#3<sp/>and<sp/>#4<sp/>can<sp/>be<sp/>done<sp/>either<sp/>in<sp/>one<sp/>thread<sp/>or<sp/>in<sp/>multiple<sp/>threads<sp/>-<sp/>anyway</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>you<sp/>want.<sp/>gMock<sp/>takes<sp/>care<sp/>of<sp/>the<sp/>locking,<sp/>so<sp/>you<sp/>don&apos;t<sp/>have<sp/>to<sp/>do<sp/>any<sp/>-</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unless<sp/>required<sp/>by<sp/>your<sp/>test<sp/>logic.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>violate<sp/>the<sp/>rules<sp/>(for<sp/>example,<sp/>if<sp/>you<sp/>set<sp/>expectations<sp/>on<sp/>a<sp/>mock<sp/>while</highlight></codeline>
<codeline><highlight class="normal">another<sp/>thread<sp/>is<sp/>calling<sp/>its<sp/>methods),<sp/>you<sp/>get<sp/>undefined<sp/>behavior.<sp/>That&apos;s<sp/>not</highlight></codeline>
<codeline><highlight class="normal">fun,<sp/>so<sp/>don&apos;t<sp/>do<sp/>it.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>guarantees<sp/>that<sp/>the<sp/>action<sp/>for<sp/>a<sp/>mock<sp/>function<sp/>is<sp/>done<sp/>in<sp/>the<sp/>same<sp/>thread</highlight></codeline>
<codeline><highlight class="normal">that<sp/>called<sp/>the<sp/>mock<sp/>function.<sp/>For<sp/>example,<sp/>in</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(action1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo(2))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(action2);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>`Foo(1)`<sp/>is<sp/>called<sp/>in<sp/>thread<sp/>1<sp/>and<sp/>`Foo(2)`<sp/>is<sp/>called<sp/>in<sp/>thread<sp/>2,<sp/>gMock<sp/>will</highlight></codeline>
<codeline><highlight class="normal">execute<sp/>`action1`<sp/>in<sp/>thread<sp/>1<sp/>and<sp/>`action2`<sp/>in<sp/>thread<sp/>2.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>does<sp/>*not*<sp/>impose<sp/>a<sp/>sequence<sp/>on<sp/>actions<sp/>performed<sp/>in<sp/>different<sp/>threads</highlight></codeline>
<codeline><highlight class="normal">(doing<sp/>so<sp/>may<sp/>create<sp/>deadlocks<sp/>as<sp/>the<sp/>actions<sp/>may<sp/>need<sp/>to<sp/>cooperate).<sp/>This<sp/>means</highlight></codeline>
<codeline><highlight class="normal">that<sp/>the<sp/>execution<sp/>of<sp/>`action1`<sp/>and<sp/>`action2`<sp/>in<sp/>the<sp/>above<sp/>example<sp/>*may*</highlight></codeline>
<codeline><highlight class="normal">interleave.<sp/>If<sp/>this<sp/>is<sp/>a<sp/>problem,<sp/>you<sp/>should<sp/>add<sp/>proper<sp/>synchronization<sp/>logic<sp/>to</highlight></codeline>
<codeline><highlight class="normal">`action1`<sp/>and<sp/>`action2`<sp/>to<sp/>make<sp/>the<sp/>test<sp/>thread-safe.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Also,<sp/>remember<sp/>that<sp/>`DefaultValue&lt;T&gt;`<sp/>is<sp/>a<sp/>global<sp/>resource<sp/>that<sp/>potentially</highlight></codeline>
<codeline><highlight class="normal">affects<sp/>*all*<sp/>living<sp/>mock<sp/>objects<sp/>in<sp/>your<sp/>program.<sp/>Naturally,<sp/>you<sp/>won&apos;t<sp/>want<sp/>to</highlight></codeline>
<codeline><highlight class="normal">mess<sp/>with<sp/>it<sp/>from<sp/>multiple<sp/>threads<sp/>or<sp/>when<sp/>there<sp/>still<sp/>are<sp/>mocks<sp/>in<sp/>action.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Controlling<sp/>How<sp/>Much<sp/>Information<sp/>gMock<sp/>Prints</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>gMock<sp/>sees<sp/>something<sp/>that<sp/>has<sp/>the<sp/>potential<sp/>of<sp/>being<sp/>an<sp/>error<sp/>(e.g.<sp/>a<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">function<sp/>with<sp/>no<sp/>expectation<sp/>is<sp/>called,<sp/>a.k.a.<sp/>an<sp/>uninteresting<sp/>call,<sp/>which<sp/>is</highlight></codeline>
<codeline><highlight class="normal">allowed<sp/>but<sp/>perhaps<sp/>you<sp/>forgot<sp/>to<sp/>explicitly<sp/>ban<sp/>the<sp/>call),<sp/>it<sp/>prints<sp/>some</highlight></codeline>
<codeline><highlight class="normal">warning<sp/>messages,<sp/>including<sp/>the<sp/>arguments<sp/>of<sp/>the<sp/>function,<sp/>the<sp/>return<sp/>value,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">the<sp/>stack<sp/>trace.<sp/>Hopefully<sp/>this<sp/>will<sp/>remind<sp/>you<sp/>to<sp/>take<sp/>a<sp/>look<sp/>and<sp/>see<sp/>if<sp/>there</highlight></codeline>
<codeline><highlight class="normal">is<sp/>indeed<sp/>a<sp/>problem.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>are<sp/>confident<sp/>that<sp/>your<sp/>tests<sp/>are<sp/>correct<sp/>and<sp/>may<sp/>not<sp/>appreciate</highlight></codeline>
<codeline><highlight class="normal">such<sp/>friendly<sp/>messages.<sp/>Some<sp/>other<sp/>times,<sp/>you<sp/>are<sp/>debugging<sp/>your<sp/>tests<sp/>or</highlight></codeline>
<codeline><highlight class="normal">learning<sp/>about<sp/>the<sp/>behavior<sp/>of<sp/>the<sp/>code<sp/>you<sp/>are<sp/>testing,<sp/>and<sp/>wish<sp/>you<sp/>could</highlight></codeline>
<codeline><highlight class="normal">observe<sp/>every<sp/>mock<sp/>call<sp/>that<sp/>happens<sp/>(including<sp/>argument<sp/>values,<sp/>the<sp/>return</highlight></codeline>
<codeline><highlight class="normal">value,<sp/>and<sp/>the<sp/>stack<sp/>trace).<sp/>Clearly,<sp/>one<sp/>size<sp/>doesn&apos;t<sp/>fit<sp/>all.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>control<sp/>how<sp/>much<sp/>gMock<sp/>tells<sp/>you<sp/>using<sp/>the<sp/>`--gmock_verbose=LEVEL`</highlight></codeline>
<codeline><highlight class="normal">command-line<sp/>flag,<sp/>where<sp/>`LEVEL`<sp/>is<sp/>a<sp/>string<sp/>with<sp/>three<sp/>possible<sp/>values:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>`info`:<sp/>gMock<sp/>will<sp/>print<sp/>all<sp/>informational<sp/>messages,<sp/>warnings,<sp/>and<sp/>errors</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(most<sp/>verbose).<sp/>At<sp/>this<sp/>setting,<sp/>gMock<sp/>will<sp/>also<sp/>log<sp/>any<sp/>calls<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>`ON_CALL/EXPECT_CALL`<sp/>macros.<sp/>It<sp/>will<sp/>include<sp/>a<sp/>stack<sp/>trace<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;uninteresting<sp/>call&quot;<sp/>warnings.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>`warning`:<sp/>gMock<sp/>will<sp/>print<sp/>both<sp/>warnings<sp/>and<sp/>errors<sp/>(less<sp/>verbose);<sp/>it<sp/>will</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>omit<sp/>the<sp/>stack<sp/>traces<sp/>in<sp/>&quot;uninteresting<sp/>call&quot;<sp/>warnings.<sp/>This<sp/>is<sp/>the<sp/>default.</highlight></codeline>
<codeline><highlight class="normal">*<sp/><sp/><sp/>`error`:<sp/>gMock<sp/>will<sp/>print<sp/>errors<sp/>only<sp/>(least<sp/>verbose).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Alternatively,<sp/>you<sp/>can<sp/>adjust<sp/>the<sp/>value<sp/>of<sp/>that<sp/>flag<sp/>from<sp/>within<sp/>your<sp/>tests<sp/>like</highlight></codeline>
<codeline><highlight class="normal">so:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>::testing::FLAGS_gmock_verbose<sp/>=<sp/>&quot;error&quot;;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>find<sp/>gMock<sp/>printing<sp/>too<sp/>many<sp/>stack<sp/>frames<sp/>with<sp/>its<sp/>informational<sp/>or</highlight></codeline>
<codeline><highlight class="normal">warning<sp/>messages,<sp/>remember<sp/>that<sp/>you<sp/>can<sp/>control<sp/>their<sp/>amount<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`--gtest_stack_trace_depth=max_depth`<sp/>flag.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now,<sp/>judiciously<sp/>use<sp/>the<sp/>right<sp/>flag<sp/>to<sp/>enable<sp/>gMock<sp/>serve<sp/>you<sp/>better!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Gaining<sp/>Super<sp/>Vision<sp/>into<sp/>Mock<sp/>Calls</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>have<sp/>a<sp/>test<sp/>using<sp/>gMock.<sp/>It<sp/>fails:<sp/>gMock<sp/>tells<sp/>you<sp/>some<sp/>expectations<sp/>aren&apos;t</highlight></codeline>
<codeline><highlight class="normal">satisfied.<sp/>However,<sp/>you<sp/>aren&apos;t<sp/>sure<sp/>why:<sp/>Is<sp/>there<sp/>a<sp/>typo<sp/>somewhere<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">matchers?<sp/>Did<sp/>you<sp/>mess<sp/>up<sp/>the<sp/>order<sp/>of<sp/>the<sp/>`EXPECT_CALL`s?<sp/>Or<sp/>is<sp/>the<sp/>code<sp/>under</highlight></codeline>
<codeline><highlight class="normal">test<sp/>doing<sp/>something<sp/>wrong?<sp/>How<sp/>can<sp/>you<sp/>find<sp/>out<sp/>the<sp/>cause?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Won&apos;t<sp/>it<sp/>be<sp/>nice<sp/>if<sp/>you<sp/>have<sp/>X-ray<sp/>vision<sp/>and<sp/>can<sp/>actually<sp/>see<sp/>the<sp/>trace<sp/>of<sp/>all</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_CALL`s<sp/>and<sp/>mock<sp/>method<sp/>calls<sp/>as<sp/>they<sp/>are<sp/>made?<sp/>For<sp/>each<sp/>call,<sp/>would<sp/>you</highlight></codeline>
<codeline><highlight class="normal">like<sp/>to<sp/>see<sp/>its<sp/>actual<sp/>argument<sp/>values<sp/>and<sp/>which<sp/>`EXPECT_CALL`<sp/>gMock<sp/>thinks<sp/>it</highlight></codeline>
<codeline><highlight class="normal">matches?<sp/>If<sp/>you<sp/>still<sp/>need<sp/>some<sp/>help<sp/>to<sp/>figure<sp/>out<sp/>who<sp/>made<sp/>these<sp/>calls,<sp/>how</highlight></codeline>
<codeline><highlight class="normal">about<sp/>being<sp/>able<sp/>to<sp/>see<sp/>the<sp/>complete<sp/>stack<sp/>trace<sp/>at<sp/>each<sp/>mock<sp/>call?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>unlock<sp/>this<sp/>power<sp/>by<sp/>running<sp/>your<sp/>test<sp/>with<sp/>the<sp/>`--gmock_verbose=info`</highlight></codeline>
<codeline><highlight class="normal">flag.<sp/>For<sp/>example,<sp/>given<sp/>the<sp/>test<sp/>program:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;gmock/gmock.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::HasSubstr;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(void,<sp/>F,<sp/>(const<sp/>string&amp;<sp/>x,<sp/>const<sp/>string&amp;<sp/>y));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TEST(Foo,<sp/>Bar)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_)).WillRepeatedly(Return());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(&quot;a&quot;,<sp/>&quot;b&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>F(&quot;c&quot;,<sp/>HasSubstr(&quot;d&quot;)));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock.F(&quot;a&quot;,<sp/>&quot;good&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mock.F(&quot;a&quot;,<sp/>&quot;b&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>you<sp/>run<sp/>it<sp/>with<sp/>`--gmock_verbose=info`,<sp/>you<sp/>will<sp/>see<sp/>this<sp/>output:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```shell</highlight></codeline>
<codeline><highlight class="normal">[<sp/>RUN<sp/><sp/><sp/><sp/><sp/><sp/><sp/>]<sp/>Foo.Bar</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:14:<sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:15:<sp/>EXPECT_CALL(mock,<sp/>F(&quot;a&quot;,<sp/>&quot;b&quot;))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:16:<sp/>EXPECT_CALL(mock,<sp/>F(&quot;c&quot;,<sp/>HasSubstr(&quot;d&quot;)))<sp/>invoked</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:14:<sp/>Mock<sp/>function<sp/>call<sp/>matches<sp/>EXPECT_CALL(mock,<sp/>F(_,<sp/>_))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Function<sp/>call:<sp/>F(@0x7fff7c8dad40&quot;a&quot;,@0x7fff7c8dad10&quot;good&quot;)</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:15:<sp/>Mock<sp/>function<sp/>call<sp/>matches<sp/>EXPECT_CALL(mock,<sp/>F(&quot;a&quot;,<sp/>&quot;b&quot;))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Function<sp/>call:<sp/>F(@0x7fff7c8dada0&quot;a&quot;,@0x7fff7c8dad70&quot;b&quot;)</highlight></codeline>
<codeline><highlight class="normal">Stack<sp/>trace:<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">foo_test.cc:16:<sp/>Failure</highlight></codeline>
<codeline><highlight class="normal">Actual<sp/>function<sp/>call<sp/>count<sp/>doesn&apos;t<sp/>match<sp/>EXPECT_CALL(mock,<sp/>F(&quot;c&quot;,<sp/>HasSubstr(&quot;d&quot;)))...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Expected:<sp/>to<sp/>be<sp/>called<sp/>once</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Actual:<sp/>never<sp/>called<sp/>-<sp/>unsatisfied<sp/>and<sp/>active</highlight></codeline>
<codeline><highlight class="normal">[<sp/><sp/>FAILED<sp/><sp/>]<sp/>Foo.Bar</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Suppose<sp/>the<sp/>bug<sp/>is<sp/>that<sp/>the<sp/>`&quot;c&quot;`<sp/>in<sp/>the<sp/>third<sp/>`EXPECT_CALL`<sp/>is<sp/>a<sp/>typo<sp/>and</highlight></codeline>
<codeline><highlight class="normal">should<sp/>actually<sp/>be<sp/>`&quot;a&quot;`.<sp/>With<sp/>the<sp/>above<sp/>message,<sp/>you<sp/>should<sp/>see<sp/>that<sp/>the<sp/>actual</highlight></codeline>
<codeline><highlight class="normal">`F(&quot;a&quot;,<sp/>&quot;good&quot;)`<sp/>call<sp/>is<sp/>matched<sp/>by<sp/>the<sp/>first<sp/>`EXPECT_CALL`,<sp/>not<sp/>the<sp/>third<sp/>as</highlight></codeline>
<codeline><highlight class="normal">you<sp/>thought.<sp/>From<sp/>that<sp/>it<sp/>should<sp/>be<sp/>obvious<sp/>that<sp/>the<sp/>third<sp/>`EXPECT_CALL`<sp/>is</highlight></codeline>
<codeline><highlight class="normal">written<sp/>wrong.<sp/>Case<sp/>solved.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>interested<sp/>in<sp/>the<sp/>mock<sp/>call<sp/>trace<sp/>but<sp/>not<sp/>the<sp/>stack<sp/>traces,<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">combine<sp/>`--gmock_verbose=info`<sp/>with<sp/>`--gtest_stack_trace_depth=0`<sp/>on<sp/>the<sp/>test</highlight></codeline>
<codeline><highlight class="normal">command<sp/>line.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Running<sp/>Tests<sp/>in<sp/>Emacs</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>build<sp/>and<sp/>run<sp/>your<sp/>tests<sp/>in<sp/>Emacs<sp/>using<sp/>the<sp/>`M-x<sp/>google-compile`<sp/>command</highlight></codeline>
<codeline><highlight class="normal">(as<sp/>many<sp/>googletest<sp/>users<sp/>do),<sp/>the<sp/>source<sp/>file<sp/>locations<sp/>of<sp/>gMock<sp/>and<sp/>googletest</highlight></codeline>
<codeline><highlight class="normal">errors<sp/>will<sp/>be<sp/>highlighted.<sp/>Just<sp/>press<sp/>`&lt;Enter&gt;`<sp/>on<sp/>one<sp/>of<sp/>them<sp/>and<sp/>you&apos;ll<sp/>be</highlight></codeline>
<codeline><highlight class="normal">taken<sp/>to<sp/>the<sp/>offending<sp/>line.<sp/>Or,<sp/>you<sp/>can<sp/>just<sp/>type<sp/>`C-x``<sp/>to<sp/>jump<sp/>to<sp/>the<sp/>next</highlight></codeline>
<codeline><highlight class="normal">error.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>make<sp/>it<sp/>even<sp/>easier,<sp/>you<sp/>can<sp/>add<sp/>the<sp/>following<sp/>lines<sp/>to<sp/>your<sp/>`~/.emacs`<sp/>file:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```text</highlight></codeline>
<codeline><highlight class="normal">(global-set-key<sp/>&quot;\M-m&quot;<sp/><sp/>&apos;google-compile)<sp/><sp/>;<sp/>m<sp/>is<sp/>for<sp/>make</highlight></codeline>
<codeline><highlight class="normal">(global-set-key<sp/>[M-down]<sp/>&apos;next-error)</highlight></codeline>
<codeline><highlight class="normal">(global-set-key<sp/>[M-up]<sp/><sp/>&apos;(lambda<sp/>()<sp/>(interactive)<sp/>(next-error<sp/>-1)))</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Then<sp/>you<sp/>can<sp/>type<sp/>`M-m`<sp/>to<sp/>start<sp/>a<sp/>build<sp/>(if<sp/>you<sp/>want<sp/>to<sp/>run<sp/>the<sp/>test<sp/>as<sp/>well,</highlight></codeline>
<codeline><highlight class="normal">just<sp/>make<sp/>sure<sp/>`foo_test.run`<sp/>or<sp/>`runtests`<sp/>is<sp/>in<sp/>the<sp/>build<sp/>command<sp/>you<sp/>supply</highlight></codeline>
<codeline><highlight class="normal">after<sp/>typing<sp/>`M-m`),<sp/>or<sp/>`M-up`/`M-down`<sp/>to<sp/>move<sp/>back<sp/>and<sp/>forth<sp/>between<sp/>errors.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Extending<sp/>gMock</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Matchers<sp/>Quickly<sp/>{#NewMatchers}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.warning}</highlight></codeline>
<codeline><highlight class="normal">WARNING:<sp/>gMock<sp/>does<sp/>not<sp/>guarantee<sp/>when<sp/>or<sp/>how<sp/>many<sp/>times<sp/>a<sp/>matcher<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal">invoked.<sp/>Therefore,<sp/>all<sp/>matchers<sp/>must<sp/>be<sp/>functionally<sp/>pure.<sp/>See</highlight></codeline>
<codeline><highlight class="normal">[this<sp/>section](#PureMatchers)<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>`MATCHER*`<sp/>family<sp/>of<sp/>macros<sp/>can<sp/>be<sp/>used<sp/>to<sp/>define<sp/>custom<sp/>matchers<sp/>easily.</highlight></codeline>
<codeline><highlight class="normal">The<sp/>syntax:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER(name,<sp/>description_string_expression)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">will<sp/>define<sp/>a<sp/>matcher<sp/>with<sp/>the<sp/>given<sp/>name<sp/>that<sp/>executes<sp/>the<sp/>statements,<sp/>which</highlight></codeline>
<codeline><highlight class="normal">must<sp/>return<sp/>a<sp/>`bool`<sp/>to<sp/>indicate<sp/>if<sp/>the<sp/>match<sp/>succeeds.<sp/>Inside<sp/>the<sp/>statements,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>can<sp/>refer<sp/>to<sp/>the<sp/>value<sp/>being<sp/>matched<sp/>by<sp/>`arg`,<sp/>and<sp/>refer<sp/>to<sp/>its<sp/>type<sp/>by</highlight></codeline>
<codeline><highlight class="normal">`arg_type`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>*description<sp/>string*<sp/>is<sp/>a<sp/>`string`-typed<sp/>expression<sp/>that<sp/>documents<sp/>what<sp/>the</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>does,<sp/>and<sp/>is<sp/>used<sp/>to<sp/>generate<sp/>the<sp/>failure<sp/>message<sp/>when<sp/>the<sp/>match<sp/>fails.</highlight></codeline>
<codeline><highlight class="normal">It<sp/>can<sp/>(and<sp/>should)<sp/>reference<sp/>the<sp/>special<sp/>`bool`<sp/>variable<sp/>`negation`,<sp/>and<sp/>should</highlight></codeline>
<codeline><highlight class="normal">evaluate<sp/>to<sp/>the<sp/>description<sp/>of<sp/>the<sp/>matcher<sp/>when<sp/>`negation`<sp/>is<sp/>`false`,<sp/>or<sp/>that</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>matcher&apos;s<sp/>negation<sp/>when<sp/>`negation`<sp/>is<sp/>`true`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>convenience,<sp/>we<sp/>allow<sp/>the<sp/>description<sp/>string<sp/>to<sp/>be<sp/>empty<sp/>(`&quot;&quot;`),<sp/>in<sp/>which</highlight></codeline>
<codeline><highlight class="normal">case<sp/>gMock<sp/>will<sp/>use<sp/>the<sp/>sequence<sp/>of<sp/>words<sp/>in<sp/>the<sp/>matcher<sp/>name<sp/>as<sp/>the</highlight></codeline>
<codeline><highlight class="normal">description.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER(IsDivisibleBy7,<sp/>&quot;&quot;)<sp/>{<sp/>return<sp/>(arg<sp/>%<sp/>7)<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">allows<sp/>you<sp/>to<sp/>write</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Expects<sp/>mock_foo.Bar(n)<sp/>to<sp/>be<sp/>called<sp/>where<sp/>n<sp/>is<sp/>divisible<sp/>by<sp/>7.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_foo,<sp/>Bar(IsDivisibleBy7()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">or,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>::testing::Not;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Verifies<sp/>that<sp/>a<sp/>value<sp/>is<sp/>divisible<sp/>by<sp/>7<sp/>and<sp/>the<sp/>other<sp/>is<sp/>not.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(some_expression,<sp/>IsDivisibleBy7());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(some_other_expression,<sp/>Not(IsDivisibleBy7()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>above<sp/>assertions<sp/>fail,<sp/>they<sp/>will<sp/>print<sp/>something<sp/>like:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```shell</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Value<sp/>of:<sp/>some_expression</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Actual:<sp/>27</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Value<sp/>of:<sp/>some_other_expression</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>not<sp/>(is<sp/>divisible<sp/>by<sp/>7)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Actual:<sp/>21</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">where<sp/>the<sp/>descriptions<sp/>`&quot;is<sp/>divisible<sp/>by<sp/>7&quot;`<sp/>and<sp/>`&quot;not<sp/>(is<sp/>divisible<sp/>by<sp/>7)&quot;`<sp/>are</highlight></codeline>
<codeline><highlight class="normal">automatically<sp/>calculated<sp/>from<sp/>the<sp/>matcher<sp/>name<sp/>`IsDivisibleBy7`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>you<sp/>may<sp/>have<sp/>noticed,<sp/>the<sp/>auto-generated<sp/>descriptions<sp/>(especially<sp/>those<sp/>for</highlight></codeline>
<codeline><highlight class="normal">the<sp/>negation)<sp/>may<sp/>not<sp/>be<sp/>so<sp/>great.<sp/>You<sp/>can<sp/>always<sp/>override<sp/>them<sp/>with<sp/>a<sp/>`string`</highlight></codeline>
<codeline><highlight class="normal">expression<sp/>of<sp/>your<sp/>own:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER(IsDivisibleBy7,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>absl::StrCat(negation<sp/>?<sp/>&quot;isn&apos;t&quot;<sp/>:<sp/>&quot;is&quot;,<sp/>&quot;<sp/>divisible<sp/>by<sp/>7&quot;))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>(arg<sp/>%<sp/>7)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Optionally,<sp/>you<sp/>can<sp/>stream<sp/>additional<sp/>information<sp/>to<sp/>a<sp/>hidden<sp/>argument<sp/>named</highlight></codeline>
<codeline><highlight class="normal">`result_listener`<sp/>to<sp/>explain<sp/>the<sp/>match<sp/>result.<sp/>For<sp/>example,<sp/>a<sp/>better<sp/>definition</highlight></codeline>
<codeline><highlight class="normal">of<sp/>`IsDivisibleBy7`<sp/>is:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER(IsDivisibleBy7,<sp/>&quot;&quot;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>((arg<sp/>%<sp/>7)<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result_listener<sp/>&lt;&lt;<sp/>&quot;the<sp/>remainder<sp/>is<sp/>&quot;<sp/>&lt;&lt;<sp/>(arg<sp/>%<sp/>7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">With<sp/>this<sp/>definition,<sp/>the<sp/>above<sp/>assertion<sp/>will<sp/>give<sp/>a<sp/>better<sp/>message:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```shell</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Value<sp/>of:<sp/>some_expression</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Actual:<sp/>27<sp/>(the<sp/>remainder<sp/>is<sp/>6)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>should<sp/>let<sp/>`MatchAndExplain()`<sp/>print<sp/>*any<sp/>additional<sp/>information*<sp/>that<sp/>can</highlight></codeline>
<codeline><highlight class="normal">help<sp/>a<sp/>user<sp/>understand<sp/>the<sp/>match<sp/>result.<sp/>Note<sp/>that<sp/>it<sp/>should<sp/>explain<sp/>why<sp/>the</highlight></codeline>
<codeline><highlight class="normal">match<sp/>succeeds<sp/>in<sp/>case<sp/>of<sp/>a<sp/>success<sp/>(unless<sp/>it&apos;s<sp/>obvious)<sp/>-<sp/>this<sp/>is<sp/>useful<sp/>when</highlight></codeline>
<codeline><highlight class="normal">the<sp/>matcher<sp/>is<sp/>used<sp/>inside<sp/>`Not()`.<sp/>There<sp/>is<sp/>no<sp/>need<sp/>to<sp/>print<sp/>the<sp/>argument<sp/>value</highlight></codeline>
<codeline><highlight class="normal">itself,<sp/>as<sp/>gMock<sp/>already<sp/>prints<sp/>it<sp/>for<sp/>you.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.note}</highlight></codeline>
<codeline><highlight class="normal">NOTE:<sp/>The<sp/>type<sp/>of<sp/>the<sp/>value<sp/>being<sp/>matched<sp/>(`arg_type`)<sp/>is<sp/>determined<sp/>by<sp/>the</highlight></codeline>
<codeline><highlight class="normal">context<sp/>in<sp/>which<sp/>you<sp/>use<sp/>the<sp/>matcher<sp/>and<sp/>is<sp/>supplied<sp/>to<sp/>you<sp/>by<sp/>the<sp/>compiler,<sp/>so</highlight></codeline>
<codeline><highlight class="normal">you<sp/>don&apos;t<sp/>need<sp/>to<sp/>worry<sp/>about<sp/>declaring<sp/>it<sp/>(nor<sp/>can<sp/>you).<sp/>This<sp/>allows<sp/>the</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>to<sp/>be<sp/>polymorphic.<sp/>For<sp/>example,<sp/>`IsDivisibleBy7()`<sp/>can<sp/>be<sp/>used<sp/>to<sp/>match</highlight></codeline>
<codeline><highlight class="normal">any<sp/>type<sp/>where<sp/>the<sp/>value<sp/>of<sp/>`(arg<sp/>%<sp/>7)<sp/>==<sp/>0`<sp/>can<sp/>be<sp/>implicitly<sp/>converted<sp/>to<sp/>a</highlight></codeline>
<codeline><highlight class="normal">`bool`.<sp/>In<sp/>the<sp/>`Bar(IsDivisibleBy7())`<sp/>example<sp/>above,<sp/>if<sp/>method<sp/>`Bar()`<sp/>takes<sp/>an</highlight></codeline>
<codeline><highlight class="normal">`int`,<sp/>`arg_type`<sp/>will<sp/>be<sp/>`int`;<sp/>if<sp/>it<sp/>takes<sp/>an<sp/>`unsigned<sp/>long`,<sp/>`arg_type`<sp/>will</highlight></codeline>
<codeline><highlight class="normal">be<sp/>`unsigned<sp/>long`;<sp/>and<sp/>so<sp/>on.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Parameterized<sp/>Matchers<sp/>Quickly</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you&apos;ll<sp/>want<sp/>to<sp/>define<sp/>a<sp/>matcher<sp/>that<sp/>has<sp/>parameters.<sp/>For<sp/>that<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">use<sp/>the<sp/>macro:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P(name,<sp/>param_name,<sp/>description_string)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">where<sp/>the<sp/>description<sp/>string<sp/>can<sp/>be<sp/>either<sp/>`&quot;&quot;`<sp/>or<sp/>a<sp/>`string`<sp/>expression<sp/>that</highlight></codeline>
<codeline><highlight class="normal">references<sp/>`negation`<sp/>and<sp/>`param_name`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P(HasAbsoluteValue,<sp/>value,<sp/>&quot;&quot;)<sp/>{<sp/>return<sp/>abs(arg)<sp/>==<sp/>value;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">will<sp/>allow<sp/>you<sp/>to<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(Blah(&quot;a&quot;),<sp/>HasAbsoluteValue(n));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">which<sp/>may<sp/>lead<sp/>to<sp/>this<sp/>message<sp/>(assuming<sp/>`n`<sp/>is<sp/>10):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```shell</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Value<sp/>of:<sp/>Blah(&quot;a&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>has<sp/>absolute<sp/>value<sp/>10</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Actual:<sp/>-9</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>both<sp/>the<sp/>matcher<sp/>description<sp/>and<sp/>its<sp/>parameter<sp/>are<sp/>printed,<sp/>making<sp/>the</highlight></codeline>
<codeline><highlight class="normal">message<sp/>human-friendly.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>the<sp/>matcher<sp/>definition<sp/>body,<sp/>you<sp/>can<sp/>write<sp/>`foo_type`<sp/>to<sp/>reference<sp/>the<sp/>type</highlight></codeline>
<codeline><highlight class="normal">of<sp/>a<sp/>parameter<sp/>named<sp/>`foo`.<sp/>For<sp/>example,<sp/>in<sp/>the<sp/>body<sp/>of</highlight></codeline>
<codeline><highlight class="normal">`MATCHER_P(HasAbsoluteValue,<sp/>value)`<sp/>above,<sp/>you<sp/>can<sp/>write<sp/>`value_type`<sp/>to<sp/>refer</highlight></codeline>
<codeline><highlight class="normal">to<sp/>the<sp/>type<sp/>of<sp/>`value`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>also<sp/>provides<sp/>`MATCHER_P2`,<sp/>`MATCHER_P3`,<sp/>...,<sp/>up<sp/>to<sp/>`MATCHER_P10`<sp/>to</highlight></codeline>
<codeline><highlight class="normal">support<sp/>multi-parameter<sp/>matchers:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER_Pk(name,<sp/>param_1,<sp/>...,<sp/>param_k,<sp/>description_string)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Please<sp/>note<sp/>that<sp/>the<sp/>custom<sp/>description<sp/>string<sp/>is<sp/>for<sp/>a<sp/>particular<sp/>*instance*<sp/>of</highlight></codeline>
<codeline><highlight class="normal">the<sp/>matcher,<sp/>where<sp/>the<sp/>parameters<sp/>have<sp/>been<sp/>bound<sp/>to<sp/>actual<sp/>values.<sp/>Therefore</highlight></codeline>
<codeline><highlight class="normal">usually<sp/>you&apos;ll<sp/>want<sp/>the<sp/>parameter<sp/>values<sp/>to<sp/>be<sp/>part<sp/>of<sp/>the<sp/>description.<sp/>gMock</highlight></codeline>
<codeline><highlight class="normal">lets<sp/>you<sp/>do<sp/>that<sp/>by<sp/>referencing<sp/>the<sp/>matcher<sp/>parameters<sp/>in<sp/>the<sp/>description<sp/>string</highlight></codeline>
<codeline><highlight class="normal">expression.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::PrintToString;</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P2(InClosedRange,<sp/>low,<sp/>hi,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>absl::StrFormat(&quot;%s<sp/>in<sp/>range<sp/>[%s,<sp/>%s]&quot;,<sp/>negation<sp/>?<sp/>&quot;isn&apos;t&quot;<sp/>:<sp/>&quot;is&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintToString(low),<sp/>PrintToString(hi)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>low<sp/>&lt;=<sp/>arg<sp/>&amp;&amp;<sp/>arg<sp/>&lt;=<sp/>hi;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(3,<sp/>InClosedRange(4,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">would<sp/>generate<sp/>a<sp/>failure<sp/>that<sp/>contains<sp/>the<sp/>message:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```shell</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>is<sp/>in<sp/>range<sp/>[4,<sp/>6]</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>specify<sp/>`&quot;&quot;`<sp/>as<sp/>the<sp/>description,<sp/>the<sp/>failure<sp/>message<sp/>will<sp/>contain<sp/>the</highlight></codeline>
<codeline><highlight class="normal">sequence<sp/>of<sp/>words<sp/>in<sp/>the<sp/>matcher<sp/>name<sp/>followed<sp/>by<sp/>the<sp/>parameter<sp/>values<sp/>printed</highlight></codeline>
<codeline><highlight class="normal">as<sp/>a<sp/>tuple.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATCHER_P2(InClosedRange,<sp/>low,<sp/>hi,<sp/>&quot;&quot;)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_THAT(3,<sp/>InClosedRange(4,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">would<sp/>generate<sp/>a<sp/>failure<sp/>that<sp/>contains<sp/>the<sp/>text:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```shell</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Expected:<sp/>in<sp/>closed<sp/>range<sp/>(4,<sp/>6)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>the<sp/>purpose<sp/>of<sp/>typing,<sp/>you<sp/>can<sp/>view</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER_Pk(Foo,<sp/>p1,<sp/>...,<sp/>pk,<sp/>description_string)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">as<sp/>shorthand<sp/>for</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>p1_type,<sp/>...,<sp/>typename<sp/>pk_type&gt;</highlight></codeline>
<codeline><highlight class="normal">FooMatcherPk&lt;p1_type,<sp/>...,<sp/>pk_type&gt;</highlight></codeline>
<codeline><highlight class="normal">Foo(p1_type<sp/>p1,<sp/>...,<sp/>pk_type<sp/>pk)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>you<sp/>write<sp/>`Foo(v1,<sp/>...,<sp/>vk)`,<sp/>the<sp/>compiler<sp/>infers<sp/>the<sp/>types<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">parameters<sp/>`v1`,<sp/>...,<sp/>and<sp/>`vk`<sp/>for<sp/>you.<sp/>If<sp/>you<sp/>are<sp/>not<sp/>happy<sp/>with<sp/>the<sp/>result<sp/>of</highlight></codeline>
<codeline><highlight class="normal">the<sp/>type<sp/>inference,<sp/>you<sp/>can<sp/>specify<sp/>the<sp/>types<sp/>by<sp/>explicitly<sp/>instantiating<sp/>the</highlight></codeline>
<codeline><highlight class="normal">template,<sp/>as<sp/>in<sp/>`Foo&lt;long,<sp/>bool&gt;(5,<sp/>false)`.<sp/>As<sp/>said<sp/>earlier,<sp/>you<sp/>don&apos;t<sp/>get<sp/>to</highlight></codeline>
<codeline><highlight class="normal">(or<sp/>need<sp/>to)<sp/>specify<sp/>`arg_type`<sp/>as<sp/>that&apos;s<sp/>determined<sp/>by<sp/>the<sp/>context<sp/>in<sp/>which<sp/>the</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>is<sp/>used.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>assign<sp/>the<sp/>result<sp/>of<sp/>expression<sp/>`Foo(p1,<sp/>...,<sp/>pk)`<sp/>to<sp/>a<sp/>variable<sp/>of<sp/>type</highlight></codeline>
<codeline><highlight class="normal">`FooMatcherPk&lt;p1_type,<sp/>...,<sp/>pk_type&gt;`.<sp/>This<sp/>can<sp/>be<sp/>useful<sp/>when<sp/>composing</highlight></codeline>
<codeline><highlight class="normal">matchers.<sp/>Matchers<sp/>that<sp/>don&apos;t<sp/>have<sp/>a<sp/>parameter<sp/>or<sp/>have<sp/>only<sp/>one<sp/>parameter<sp/>have</highlight></codeline>
<codeline><highlight class="normal">special<sp/>types:<sp/>you<sp/>can<sp/>assign<sp/>`Foo()`<sp/>to<sp/>a<sp/>`FooMatcher`-typed<sp/>variable,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">assign<sp/>`Foo(p)`<sp/>to<sp/>a<sp/>`FooMatcherP&lt;p_type&gt;`-typed<sp/>variable.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">While<sp/>you<sp/>can<sp/>instantiate<sp/>a<sp/>matcher<sp/>template<sp/>with<sp/>reference<sp/>types,<sp/>passing<sp/>the</highlight></codeline>
<codeline><highlight class="normal">parameters<sp/>by<sp/>pointer<sp/>usually<sp/>makes<sp/>your<sp/>code<sp/>more<sp/>readable.<sp/>If,<sp/>however,<sp/>you</highlight></codeline>
<codeline><highlight class="normal">still<sp/>want<sp/>to<sp/>pass<sp/>a<sp/>parameter<sp/>by<sp/>reference,<sp/>be<sp/>aware<sp/>that<sp/>in<sp/>the<sp/>failure</highlight></codeline>
<codeline><highlight class="normal">message<sp/>generated<sp/>by<sp/>the<sp/>matcher<sp/>you<sp/>will<sp/>see<sp/>the<sp/>value<sp/>of<sp/>the<sp/>referenced<sp/>object</highlight></codeline>
<codeline><highlight class="normal">but<sp/>not<sp/>its<sp/>address.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>overload<sp/>matchers<sp/>with<sp/>different<sp/>numbers<sp/>of<sp/>parameters:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P(Blah,<sp/>a,<sp/>description_string_1)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">MATCHER_P2(Blah,<sp/>a,<sp/>b,<sp/>description_string_2)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">While<sp/>it&apos;s<sp/>tempting<sp/>to<sp/>always<sp/>use<sp/>the<sp/>`MATCHER*`<sp/>macros<sp/>when<sp/>defining<sp/>a<sp/>new</highlight></codeline>
<codeline><highlight class="normal">matcher,<sp/>you<sp/>should<sp/>also<sp/>consider<sp/>implementing<sp/>the<sp/>matcher<sp/>interface<sp/>directly</highlight></codeline>
<codeline><highlight class="normal">instead<sp/>(see<sp/>the<sp/>recipes<sp/>that<sp/>follow),<sp/>especially<sp/>if<sp/>you<sp/>need<sp/>to<sp/>use<sp/>the<sp/>matcher</highlight></codeline>
<codeline><highlight class="normal">a<sp/>lot.<sp/>While<sp/>these<sp/>approaches<sp/>require<sp/>more<sp/>work,<sp/>they<sp/>give<sp/>you<sp/>more<sp/>control<sp/>on</highlight></codeline>
<codeline><highlight class="normal">the<sp/>types<sp/>of<sp/>the<sp/>value<sp/>being<sp/>matched<sp/>and<sp/>the<sp/>matcher<sp/>parameters,<sp/>which<sp/>in</highlight></codeline>
<codeline><highlight class="normal">general<sp/>leads<sp/>to<sp/>better<sp/>compiler<sp/>error<sp/>messages<sp/>that<sp/>pay<sp/>off<sp/>in<sp/>the<sp/>long<sp/>run.</highlight></codeline>
<codeline><highlight class="normal">They<sp/>also<sp/>allow<sp/>overloading<sp/>matchers<sp/>based<sp/>on<sp/>parameter<sp/>types<sp/>(as<sp/>opposed<sp/>to</highlight></codeline>
<codeline><highlight class="normal">just<sp/>based<sp/>on<sp/>the<sp/>number<sp/>of<sp/>parameters).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Monomorphic<sp/>Matchers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>matcher<sp/>of<sp/>argument<sp/>type<sp/>`T`<sp/>implements<sp/>the<sp/>matcher<sp/>interface<sp/>for<sp/>`T`<sp/>and<sp/>does</highlight></codeline>
<codeline><highlight class="normal">two<sp/>things:<sp/>it<sp/>tests<sp/>whether<sp/>a<sp/>value<sp/>of<sp/>type<sp/>`T`<sp/>matches<sp/>the<sp/>matcher,<sp/>and<sp/>can</highlight></codeline>
<codeline><highlight class="normal">describe<sp/>what<sp/>kind<sp/>of<sp/>values<sp/>it<sp/>matches.<sp/>The<sp/>latter<sp/>ability<sp/>is<sp/>used<sp/>for</highlight></codeline>
<codeline><highlight class="normal">generating<sp/>readable<sp/>error<sp/>messages<sp/>when<sp/>expectations<sp/>are<sp/>violated.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>matcher<sp/>of<sp/>`T`<sp/>must<sp/>declare<sp/>a<sp/>typedef<sp/>like:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>is_gtest_matcher<sp/>=<sp/>void;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">and<sp/>supports<sp/>the<sp/>following<sp/>operations:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Match<sp/>a<sp/>value<sp/>and<sp/>optionally<sp/>explain<sp/>into<sp/>an<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>matched<sp/>=<sp/>matcher.MatchAndExplain(value,<sp/>maybe_os);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>where<sp/>`value`<sp/>is<sp/>of<sp/>type<sp/>`T`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">//<sp/>`maybe_os`<sp/>is<sp/>of<sp/>type<sp/>`std::ostream*`,<sp/>where<sp/>it<sp/>can<sp/>be<sp/>null<sp/>if<sp/>the<sp/>caller</highlight></codeline>
<codeline><highlight class="normal">//<sp/>is<sp/>not<sp/>interested<sp/>in<sp/>there<sp/>textual<sp/>explanation.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">matcher.DescribeTo(os);</highlight></codeline>
<codeline><highlight class="normal">matcher.DescribeNegationTo(os);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>where<sp/>`os`<sp/>is<sp/>of<sp/>type<sp/>`std::ostream*`.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>need<sp/>a<sp/>custom<sp/>matcher<sp/>but<sp/>`Truly()`<sp/>is<sp/>not<sp/>a<sp/>good<sp/>option<sp/>(for<sp/>example,</highlight></codeline>
<codeline><highlight class="normal">you<sp/>may<sp/>not<sp/>be<sp/>happy<sp/>with<sp/>the<sp/>way<sp/>`Truly(predicate)`<sp/>describes<sp/>itself,<sp/>or<sp/>you</highlight></codeline>
<codeline><highlight class="normal">may<sp/>want<sp/>your<sp/>matcher<sp/>to<sp/>be<sp/>polymorphic<sp/>as<sp/>`Eq(value)`<sp/>is),<sp/>you<sp/>can<sp/>define<sp/>a</highlight></codeline>
<codeline><highlight class="normal">matcher<sp/>to<sp/>do<sp/>whatever<sp/>you<sp/>want<sp/>in<sp/>two<sp/>steps:<sp/>first<sp/>implement<sp/>the<sp/>matcher</highlight></codeline>
<codeline><highlight class="normal">interface,<sp/>and<sp/>then<sp/>define<sp/>a<sp/>factory<sp/>function<sp/>to<sp/>create<sp/>a<sp/>matcher<sp/>instance.<sp/>The</highlight></codeline>
<codeline><highlight class="normal">second<sp/>step<sp/>is<sp/>not<sp/>strictly<sp/>needed<sp/>but<sp/>it<sp/>makes<sp/>the<sp/>syntax<sp/>of<sp/>using<sp/>the<sp/>matcher</highlight></codeline>
<codeline><highlight class="normal">nicer.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>you<sp/>can<sp/>define<sp/>a<sp/>matcher<sp/>to<sp/>test<sp/>whether<sp/>an<sp/>`int`<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal">and<sp/>then<sp/>use<sp/>it<sp/>like<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Matcher;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>DivisibleBy7Matcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>is_gtest_matcher<sp/>=<sp/>void;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>MatchAndExplain(int<sp/>n,<sp/>std::ostream*)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(n<sp/>%<sp/>7)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeTo(std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>divisible<sp/>by<sp/>7&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeNegationTo(std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>not<sp/>divisible<sp/>by<sp/>7&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Matcher&lt;int&gt;<sp/>DivisibleBy7()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>DivisibleBy7Matcher();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(DivisibleBy7()));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>may<sp/>improve<sp/>the<sp/>matcher<sp/>message<sp/>by<sp/>streaming<sp/>additional<sp/>information<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`os`<sp/>argument<sp/>in<sp/>`MatchAndExplain()`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>DivisibleBy7Matcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>MatchAndExplain(int<sp/>n,<sp/>std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>remainder<sp/>=<sp/>n<sp/>%<sp/>7;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(remainder<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>os<sp/>!=<sp/>nullptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;the<sp/>remainder<sp/>is<sp/>&quot;<sp/>&lt;&lt;<sp/>remainder;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>remainder<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Then,<sp/>`EXPECT_THAT(x,<sp/>DivisibleBy7());`<sp/>may<sp/>generate<sp/>a<sp/>message<sp/>like<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```shell</highlight></codeline>
<codeline><highlight class="normal">Value<sp/>of:<sp/>x</highlight></codeline>
<codeline><highlight class="normal">Expected:<sp/>is<sp/>divisible<sp/>by<sp/>7</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Actual:<sp/>23<sp/>(the<sp/>remainder<sp/>is<sp/>2)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.tip}</highlight></codeline>
<codeline><highlight class="normal">Tip:<sp/>for<sp/>convenience,<sp/>`MatchAndExplain()`<sp/>can<sp/>take<sp/>a<sp/>`MatchResultListener*`</highlight></codeline>
<codeline><highlight class="normal">instead<sp/>of<sp/>`std::ostream*`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Polymorphic<sp/>Matchers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Expanding<sp/>what<sp/>we<sp/>learned<sp/>above<sp/>to<sp/>*polymorphic*<sp/>matchers<sp/>is<sp/>now<sp/>just<sp/>as<sp/>simple</highlight></codeline>
<codeline><highlight class="normal">as<sp/>adding<sp/>templates<sp/>in<sp/>the<sp/>right<sp/>place.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>NotNullMatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>is_gtest_matcher<sp/>=<sp/>void;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>To<sp/>implement<sp/>a<sp/>polymorphic<sp/>matcher,<sp/>we<sp/>just<sp/>need<sp/>to<sp/>make<sp/>MatchAndExplain<sp/>a</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>template<sp/>on<sp/>its<sp/>first<sp/>argument.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>In<sp/>this<sp/>example,<sp/>we<sp/>want<sp/>to<sp/>use<sp/>NotNull()<sp/>with<sp/>any<sp/>pointer,<sp/>so</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>MatchAndExplain()<sp/>accepts<sp/>a<sp/>pointer<sp/>of<sp/>any<sp/>type<sp/>as<sp/>its<sp/>first<sp/>argument.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>In<sp/>general,<sp/>you<sp/>can<sp/>define<sp/>MatchAndExplain()<sp/>as<sp/>an<sp/>ordinary<sp/>method<sp/>or</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>a<sp/>method<sp/>template,<sp/>or<sp/>even<sp/>overload<sp/>it.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>MatchAndExplain(T*<sp/>p,<sp/>std::ostream*)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>p<sp/>!=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>matching<sp/>this<sp/>matcher.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeTo(std::ostream*<sp/>os)<sp/>const<sp/>{<sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>not<sp/>NULL&quot;;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>NOT<sp/>matching<sp/>this<sp/>matcher.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeNegationTo(std::ostream*<sp/>os)<sp/>const<sp/>{<sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>NULL&quot;;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">NotNullMatcher<sp/>NotNull()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>NotNullMatcher();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(NotNull()));<sp/><sp/>//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>a<sp/>non-NULL<sp/>pointer.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Legacy<sp/>Matcher<sp/>Implementation</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Defining<sp/>matchers<sp/>used<sp/>to<sp/>be<sp/>somewhat<sp/>more<sp/>complicated,<sp/>in<sp/>which<sp/>it<sp/>required</highlight></codeline>
<codeline><highlight class="normal">several<sp/>supporting<sp/>classes<sp/>and<sp/>virtual<sp/>functions.<sp/>To<sp/>implement<sp/>a<sp/>matcher<sp/>for</highlight></codeline>
<codeline><highlight class="normal">type<sp/>`T`<sp/>using<sp/>the<sp/>legacy<sp/>API<sp/>you<sp/>have<sp/>to<sp/>derive<sp/>from<sp/>`MatcherInterface&lt;T&gt;`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">call<sp/>`MakeMatcher`<sp/>to<sp/>construct<sp/>the<sp/>object.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>interface<sp/>looks<sp/>like<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MatchResultListener<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Streams<sp/>x<sp/>to<sp/>the<sp/>underlying<sp/>ostream;<sp/>does<sp/>nothing<sp/>if<sp/>the<sp/>ostream</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>is<sp/>NULL.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatchResultListener&amp;<sp/>operator&lt;&lt;(const<sp/>T&amp;<sp/>x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Returns<sp/>the<sp/>underlying<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ostream*<sp/>stream();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MatcherInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~MatcherInterface();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Returns<sp/>true<sp/>if<sp/>and<sp/>only<sp/>if<sp/>the<sp/>matcher<sp/>matches<sp/>x;<sp/>also<sp/>explains<sp/>the<sp/>match</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>result<sp/>to<sp/>&apos;listener&apos;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>MatchAndExplain(T<sp/>x,<sp/>MatchResultListener*<sp/>listener)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>this<sp/>matcher<sp/>to<sp/>an<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeTo(std::ostream*<sp/>os)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>the<sp/>negation<sp/>of<sp/>this<sp/>matcher<sp/>to<sp/>an<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeNegationTo(std::ostream*<sp/>os)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Fortunately,<sp/>most<sp/>of<sp/>the<sp/>time<sp/>you<sp/>can<sp/>define<sp/>a<sp/>polymorphic<sp/>matcher<sp/>easily<sp/>with</highlight></codeline>
<codeline><highlight class="normal">the<sp/>help<sp/>of<sp/>`MakePolymorphicMatcher()`.<sp/>Here&apos;s<sp/>how<sp/>you<sp/>can<sp/>define<sp/>`NotNull()`<sp/>as</highlight></codeline>
<codeline><highlight class="normal">an<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakePolymorphicMatcher;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MatchResultListener;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::PolymorphicMatcher;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>NotNullMatcher<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>To<sp/>implement<sp/>a<sp/>polymorphic<sp/>matcher,<sp/>first<sp/>define<sp/>a<sp/>COPYABLE<sp/>class</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>that<sp/>has<sp/>three<sp/>members<sp/>MatchAndExplain(),<sp/>DescribeTo(),<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>DescribeNegationTo(),<sp/>like<sp/>the<sp/>following.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>In<sp/>this<sp/>example,<sp/>we<sp/>want<sp/>to<sp/>use<sp/>NotNull()<sp/>with<sp/>any<sp/>pointer,<sp/>so</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>MatchAndExplain()<sp/>accepts<sp/>a<sp/>pointer<sp/>of<sp/>any<sp/>type<sp/>as<sp/>its<sp/>first<sp/>argument.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>In<sp/>general,<sp/>you<sp/>can<sp/>define<sp/>MatchAndExplain()<sp/>as<sp/>an<sp/>ordinary<sp/>method<sp/>or</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>a<sp/>method<sp/>template,<sp/>or<sp/>even<sp/>overload<sp/>it.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>MatchAndExplain(T*<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MatchResultListener*<sp/>/*<sp/>listener<sp/>*/)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>p<sp/>!=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>matching<sp/>this<sp/>matcher.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeTo(std::ostream*<sp/>os)<sp/>const<sp/>{<sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>not<sp/>NULL&quot;;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>the<sp/>property<sp/>of<sp/>a<sp/>value<sp/>NOT<sp/>matching<sp/>this<sp/>matcher.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeNegationTo(std::ostream*<sp/>os)<sp/>const<sp/>{<sp/>*os<sp/>&lt;&lt;<sp/>&quot;is<sp/>NULL&quot;;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>To<sp/>construct<sp/>a<sp/>polymorphic<sp/>matcher,<sp/>pass<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>class</highlight></codeline>
<codeline><highlight class="normal">//<sp/>to<sp/>MakePolymorphicMatcher().<sp/><sp/>Note<sp/>the<sp/>return<sp/>type.</highlight></codeline>
<codeline><highlight class="normal">PolymorphicMatcher&lt;NotNullMatcher&gt;<sp/>NotNull()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakePolymorphicMatcher(NotNullMatcher());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(NotNull()));<sp/><sp/>//<sp/>The<sp/>argument<sp/>must<sp/>be<sp/>a<sp/>non-NULL<sp/>pointer.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{:<sp/>.callout<sp/>.note}</highlight></codeline>
<codeline><highlight class="normal">**Note:**<sp/>Your<sp/>polymorphic<sp/>matcher<sp/>class<sp/>does<sp/>**not**<sp/>need<sp/>to<sp/>inherit<sp/>from</highlight></codeline>
<codeline><highlight class="normal">`MatcherInterface`<sp/>or<sp/>any<sp/>other<sp/>class,<sp/>and<sp/>its<sp/>methods<sp/>do<sp/>**not**<sp/>need<sp/>to<sp/>be</highlight></codeline>
<codeline><highlight class="normal">virtual.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Like<sp/>in<sp/>a<sp/>monomorphic<sp/>matcher,<sp/>you<sp/>may<sp/>explain<sp/>the<sp/>match<sp/>result<sp/>by<sp/>streaming</highlight></codeline>
<codeline><highlight class="normal">additional<sp/>information<sp/>to<sp/>the<sp/>`listener`<sp/>argument<sp/>in<sp/>`MatchAndExplain()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Cardinalities</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>cardinality<sp/>is<sp/>used<sp/>in<sp/>`Times()`<sp/>to<sp/>tell<sp/>gMock<sp/>how<sp/>many<sp/>times<sp/>you<sp/>expect<sp/>a</highlight></codeline>
<codeline><highlight class="normal">call<sp/>to<sp/>occur.<sp/>It<sp/>doesn&apos;t<sp/>have<sp/>to<sp/>be<sp/>exact.<sp/>For<sp/>example,<sp/>you<sp/>can<sp/>say</highlight></codeline>
<codeline><highlight class="normal">`AtLeast(5)`<sp/>or<sp/>`Between(2,<sp/>4)`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>[built-in<sp/>set](gmock_cheat_sheet.md#CardinalityList)<sp/>of<sp/>cardinalities</highlight></codeline>
<codeline><highlight class="normal">doesn&apos;t<sp/>suit<sp/>you,<sp/>you<sp/>are<sp/>free<sp/>to<sp/>define<sp/>your<sp/>own<sp/>by<sp/>implementing<sp/>the<sp/>following</highlight></codeline>
<codeline><highlight class="normal">interface<sp/>(in<sp/>namespace<sp/>`testing`):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>CardinalityInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~CardinalityInterface();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Returns<sp/>true<sp/>if<sp/>and<sp/>only<sp/>if<sp/>call_count<sp/>calls<sp/>will<sp/>satisfy<sp/>this<sp/>cardinality.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>IsSatisfiedByCallCount(int<sp/>call_count)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Returns<sp/>true<sp/>if<sp/>and<sp/>only<sp/>if<sp/>call_count<sp/>calls<sp/>will<sp/>saturate<sp/>this</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>cardinality.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>bool<sp/>IsSaturatedByCallCount(int<sp/>call_count)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Describes<sp/>self<sp/>to<sp/>an<sp/>ostream.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>DescribeTo(std::ostream*<sp/>os)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>to<sp/>specify<sp/>that<sp/>a<sp/>call<sp/>must<sp/>occur<sp/>even<sp/>number<sp/>of<sp/>times,<sp/>you<sp/>can</highlight></codeline>
<codeline><highlight class="normal">write</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Cardinality;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::CardinalityInterface;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakeCardinality;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>EvenNumberCardinality<sp/>:<sp/>public<sp/>CardinalityInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>IsSatisfiedByCallCount(int<sp/>call_count)<sp/>const<sp/>override<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(call_count<sp/>%<sp/>2)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>IsSaturatedByCallCount(int<sp/>call_count)<sp/>const<sp/>override<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DescribeTo(std::ostream*<sp/>os)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*os<sp/>&lt;&lt;<sp/>&quot;called<sp/>even<sp/>number<sp/>of<sp/>times&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Cardinality<sp/>EvenNumber()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakeCardinality(new<sp/>EvenNumberCardinality);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Bar(3))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.Times(EvenNumber());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Actions<sp/>{#QuickNewActions}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>the<sp/>built-in<sp/>actions<sp/>don&apos;t<sp/>work<sp/>for<sp/>you,<sp/>you<sp/>can<sp/>easily<sp/>define<sp/>your<sp/>own<sp/>one.</highlight></codeline>
<codeline><highlight class="normal">All<sp/>you<sp/>need<sp/>is<sp/>a<sp/>call<sp/>operator<sp/>with<sp/>a<sp/>signature<sp/>compatible<sp/>with<sp/>the<sp/>mocked</highlight></codeline>
<codeline><highlight class="normal">function.<sp/>So<sp/>you<sp/>can<sp/>use<sp/>a<sp/>lambda:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MockFunction&lt;int(int)&gt;<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Call).WillOnce([](const<sp/>int<sp/>input)<sp/>{<sp/>return<sp/>input<sp/>*<sp/>7;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(mock.AsStdFunction()(2),<sp/>14);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Or<sp/>a<sp/>struct<sp/>with<sp/>a<sp/>call<sp/>operator<sp/>(even<sp/>a<sp/>templated<sp/>one):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>MultiplyBy<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>T<sp/>operator()(T<sp/>arg)<sp/>{<sp/>return<sp/>arg<sp/>*<sp/>multiplier;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>multiplier;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Then<sp/>use:</highlight></codeline>
<codeline><highlight class="normal">//<sp/>EXPECT_CALL(...).WillOnce(MultiplyBy{7});</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It&apos;s<sp/>also<sp/>fine<sp/>for<sp/>the<sp/>callable<sp/>to<sp/>take<sp/>no<sp/>arguments,<sp/>ignoring<sp/>the<sp/>arguments</highlight></codeline>
<codeline><highlight class="normal">supplied<sp/>to<sp/>the<sp/>mock<sp/>function:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">MockFunction&lt;int(int)&gt;<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Call).WillOnce([]<sp/>{<sp/>return<sp/>17;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(mock.AsStdFunction()(0),<sp/>17);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>used<sp/>with<sp/>`WillOnce`,<sp/>the<sp/>callable<sp/>can<sp/>assume<sp/>it<sp/>will<sp/>be<sp/>called<sp/>at<sp/>most</highlight></codeline>
<codeline><highlight class="normal">once<sp/>and<sp/>is<sp/>allowed<sp/>to<sp/>be<sp/>a<sp/>move-only<sp/>type:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>An<sp/>action<sp/>that<sp/>contains<sp/>move-only<sp/>types<sp/>and<sp/>has<sp/>an<sp/>&amp;&amp;-qualified<sp/>operator,</highlight></codeline>
<codeline><highlight class="normal">//<sp/>demanding<sp/>in<sp/>the<sp/>type<sp/>system<sp/>that<sp/>it<sp/>be<sp/>called<sp/>at<sp/>most<sp/>once.<sp/>This<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal">//<sp/>used<sp/>with<sp/>WillOnce,<sp/>but<sp/>the<sp/>compiler<sp/>will<sp/>reject<sp/>it<sp/>if<sp/>handed<sp/>to</highlight></codeline>
<codeline><highlight class="normal">//<sp/>WillRepeatedly.</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>MoveOnlyAction<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::unique_ptr&lt;int&gt;<sp/>move_only_state;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::unique_ptr&lt;int&gt;<sp/>operator()()<sp/>&amp;&amp;<sp/>{<sp/>return<sp/>std::move(move_only_state);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">MockFunction&lt;std::unique_ptr&lt;int&gt;()&gt;<sp/>mock;</highlight></codeline>
<codeline><highlight class="normal">EXPECT_CALL(mock,<sp/>Call).WillOnce(MoveOnlyAction{std::make_unique&lt;int&gt;(17)});</highlight></codeline>
<codeline><highlight class="normal">EXPECT_THAT(mock.AsStdFunction()(),<sp/>Pointee(Eq(17)));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">More<sp/>generally,<sp/>to<sp/>use<sp/>with<sp/>a<sp/>mock<sp/>function<sp/>whose<sp/>signature<sp/>is<sp/>`R(Args...)`<sp/>the</highlight></codeline>
<codeline><highlight class="normal">object<sp/>can<sp/>be<sp/>anything<sp/>convertible<sp/>to<sp/>`OnceAction&lt;R(Args...)&gt;`<sp/>or</highlight></codeline>
<codeline><highlight class="normal">`Action&lt;R(Args...)`&gt;.<sp/>The<sp/>difference<sp/>between<sp/>the<sp/>two<sp/>is<sp/>that<sp/>`OnceAction`<sp/>has</highlight></codeline>
<codeline><highlight class="normal">weaker<sp/>requirements<sp/>(`Action`<sp/>requires<sp/>a<sp/>copy-constructible<sp/>input<sp/>that<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal">called<sp/>repeatedly<sp/>whereas<sp/>`OnceAction`<sp/>requires<sp/>only<sp/>move-constructible<sp/>and</highlight></codeline>
<codeline><highlight class="normal">supports<sp/>`&amp;&amp;`-qualified<sp/>call<sp/>operators),<sp/>but<sp/>can<sp/>be<sp/>used<sp/>only<sp/>with<sp/>`WillOnce`.</highlight></codeline>
<codeline><highlight class="normal">`OnceAction`<sp/>is<sp/>typically<sp/>relevant<sp/>only<sp/>when<sp/>supporting<sp/>move-only<sp/>types<sp/>or</highlight></codeline>
<codeline><highlight class="normal">actions<sp/>that<sp/>want<sp/>a<sp/>type-system<sp/>guarantee<sp/>that<sp/>they<sp/>will<sp/>be<sp/>called<sp/>at<sp/>most<sp/>once.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Typically<sp/>the<sp/>`OnceAction`<sp/>and<sp/>`Action`<sp/>templates<sp/>need<sp/>not<sp/>be<sp/>referenced</highlight></codeline>
<codeline><highlight class="normal">directly<sp/>in<sp/>your<sp/>actions:<sp/>a<sp/>struct<sp/>or<sp/>class<sp/>with<sp/>a<sp/>call<sp/>operator<sp/>is<sp/>sufficient,</highlight></codeline>
<codeline><highlight class="normal">as<sp/>in<sp/>the<sp/>examples<sp/>above.<sp/>But<sp/>fancier<sp/>polymorphic<sp/>actions<sp/>that<sp/>need<sp/>to<sp/>know<sp/>the</highlight></codeline>
<codeline><highlight class="normal">specific<sp/>return<sp/>type<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>can<sp/>define<sp/>templated<sp/>conversion</highlight></codeline>
<codeline><highlight class="normal">operators<sp/>to<sp/>make<sp/>that<sp/>possible.<sp/>See<sp/>`gmock-actions.h`<sp/>for<sp/>examples.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">####<sp/>Legacy<sp/>macro-based<sp/>Actions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Before<sp/>C++11,<sp/>the<sp/>functor-based<sp/>actions<sp/>were<sp/>not<sp/>supported;<sp/>the<sp/>old<sp/>way<sp/>of</highlight></codeline>
<codeline><highlight class="normal">writing<sp/>actions<sp/>was<sp/>through<sp/>a<sp/>set<sp/>of<sp/>`ACTION*`<sp/>macros.<sp/>We<sp/>suggest<sp/>to<sp/>avoid<sp/>them</highlight></codeline>
<codeline><highlight class="normal">in<sp/>new<sp/>code;<sp/>they<sp/>hide<sp/>a<sp/>lot<sp/>of<sp/>logic<sp/>behind<sp/>the<sp/>macro,<sp/>potentially<sp/>leading<sp/>to</highlight></codeline>
<codeline><highlight class="normal">harder-to-understand<sp/>compiler<sp/>errors.<sp/>Nevertheless,<sp/>we<sp/>cover<sp/>them<sp/>here<sp/>for</highlight></codeline>
<codeline><highlight class="normal">completeness.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">By<sp/>writing</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION(name)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">in<sp/>a<sp/>namespace<sp/>scope<sp/>(i.e.<sp/>not<sp/>inside<sp/>a<sp/>class<sp/>or<sp/>function),<sp/>you<sp/>will<sp/>define<sp/>an</highlight></codeline>
<codeline><highlight class="normal">action<sp/>with<sp/>the<sp/>given<sp/>name<sp/>that<sp/>executes<sp/>the<sp/>statements.<sp/>The<sp/>value<sp/>returned<sp/>by</highlight></codeline>
<codeline><highlight class="normal">`statements`<sp/>will<sp/>be<sp/>used<sp/>as<sp/>the<sp/>return<sp/>value<sp/>of<sp/>the<sp/>action.<sp/>Inside<sp/>the</highlight></codeline>
<codeline><highlight class="normal">statements,<sp/>you<sp/>can<sp/>refer<sp/>to<sp/>the<sp/>K-th<sp/>(0-based)<sp/>argument<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>as</highlight></codeline>
<codeline><highlight class="normal">`argK`.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION(IncrementArg1)<sp/>{<sp/>return<sp/>++(*arg1);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">allows<sp/>you<sp/>to<sp/>write</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">...<sp/>WillOnce(IncrementArg1());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>specify<sp/>the<sp/>types<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>arguments.</highlight></codeline>
<codeline><highlight class="normal">Rest<sp/>assured<sp/>that<sp/>your<sp/>code<sp/>is<sp/>type-safe<sp/>though:<sp/>you&apos;ll<sp/>get<sp/>a<sp/>compiler<sp/>error<sp/>if</highlight></codeline>
<codeline><highlight class="normal">`*arg1`<sp/>doesn&apos;t<sp/>support<sp/>the<sp/>`++`<sp/>operator,<sp/>or<sp/>if<sp/>the<sp/>type<sp/>of<sp/>`++(*arg1)`<sp/>isn&apos;t</highlight></codeline>
<codeline><highlight class="normal">compatible<sp/>with<sp/>the<sp/>mock<sp/>function&apos;s<sp/>return<sp/>type.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Another<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION(Foo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(*arg2)(5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Blah();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*arg1<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>arg0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">defines<sp/>an<sp/>action<sp/>`Foo()`<sp/>that<sp/>invokes<sp/>argument<sp/>#2<sp/>(a<sp/>function<sp/>pointer)<sp/>with<sp/>5,</highlight></codeline>
<codeline><highlight class="normal">calls<sp/>function<sp/>`Blah()`,<sp/>sets<sp/>the<sp/>value<sp/>pointed<sp/>to<sp/>by<sp/>argument<sp/>#1<sp/>to<sp/>0,<sp/>and</highlight></codeline>
<codeline><highlight class="normal">returns<sp/>argument<sp/>#0.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>more<sp/>convenience<sp/>and<sp/>flexibility,<sp/>you<sp/>can<sp/>also<sp/>use<sp/>the<sp/>following<sp/>pre-defined</highlight></codeline>
<codeline><highlight class="normal">symbols<sp/>in<sp/>the<sp/>body<sp/>of<sp/>`ACTION`:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`argK_type`<sp/><sp/><sp/><sp/><sp/>|<sp/>The<sp/>type<sp/>of<sp/>the<sp/>K-th<sp/>(0-based)<sp/>argument<sp/>of<sp/>the<sp/>mock<sp/>function</highlight></codeline>
<codeline><highlight class="normal">:--------------<sp/>|<sp/>:-----------------------------------------------------------</highlight></codeline>
<codeline><highlight class="normal">`args`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>All<sp/>arguments<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>as<sp/>a<sp/>tuple</highlight></codeline>
<codeline><highlight class="normal">`args_type`<sp/><sp/><sp/><sp/><sp/>|<sp/>The<sp/>type<sp/>of<sp/>all<sp/>arguments<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>as<sp/>a<sp/>tuple</highlight></codeline>
<codeline><highlight class="normal">`return_type`<sp/><sp/><sp/>|<sp/>The<sp/>return<sp/>type<sp/>of<sp/>the<sp/>mock<sp/>function</highlight></codeline>
<codeline><highlight class="normal">`function_type`<sp/>|<sp/>The<sp/>type<sp/>of<sp/>the<sp/>mock<sp/>function</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>when<sp/>using<sp/>an<sp/>`ACTION`<sp/>as<sp/>a<sp/>stub<sp/>action<sp/>for<sp/>mock<sp/>function:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">int<sp/>DoSomething(bool<sp/>flag,<sp/>int*<sp/>ptr);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">we<sp/>have:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Pre-defined<sp/>Symbol<sp/>|<sp/>Is<sp/>Bound<sp/>To</highlight></codeline>
<codeline><highlight class="normal">------------------<sp/>|<sp/>---------------------------------</highlight></codeline>
<codeline><highlight class="normal">`arg0`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>value<sp/>of<sp/>`flag`</highlight></codeline>
<codeline><highlight class="normal">`arg0_type`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`bool`</highlight></codeline>
<codeline><highlight class="normal">`arg1`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>value<sp/>of<sp/>`ptr`</highlight></codeline>
<codeline><highlight class="normal">`arg1_type`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`int*`</highlight></codeline>
<codeline><highlight class="normal">`args`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>tuple<sp/>`(flag,<sp/>ptr)`</highlight></codeline>
<codeline><highlight class="normal">`args_type`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`std::tuple&lt;bool,<sp/>int*&gt;`</highlight></codeline>
<codeline><highlight class="normal">`return_type`<sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`int`</highlight></codeline>
<codeline><highlight class="normal">`function_type`<sp/><sp/><sp/><sp/>|<sp/>the<sp/>type<sp/>`int(bool,<sp/>int*)`</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">####<sp/>Legacy<sp/>macro-based<sp/>parameterized<sp/>Actions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you&apos;ll<sp/>want<sp/>to<sp/>parameterize<sp/>an<sp/>action<sp/>you<sp/>define.<sp/>For<sp/>that<sp/>we<sp/>have</highlight></codeline>
<codeline><highlight class="normal">another<sp/>macro</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION_P(name,<sp/>param)<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION_P(Add,<sp/>n)<sp/>{<sp/>return<sp/>arg0<sp/>+<sp/>n;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">will<sp/>allow<sp/>you<sp/>to<sp/>write</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Returns<sp/>argument<sp/>#0<sp/>+<sp/>5.</highlight></codeline>
<codeline><highlight class="normal">...<sp/>WillOnce(Add(5));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>convenience,<sp/>we<sp/>use<sp/>the<sp/>term<sp/>*arguments*<sp/>for<sp/>the<sp/>values<sp/>used<sp/>to<sp/>invoke<sp/>the</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>function,<sp/>and<sp/>the<sp/>term<sp/>*parameters*<sp/>for<sp/>the<sp/>values<sp/>used<sp/>to<sp/>instantiate<sp/>an</highlight></codeline>
<codeline><highlight class="normal">action.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>you<sp/>don&apos;t<sp/>need<sp/>to<sp/>provide<sp/>the<sp/>type<sp/>of<sp/>the<sp/>parameter<sp/>either.<sp/>Suppose</highlight></codeline>
<codeline><highlight class="normal">the<sp/>parameter<sp/>is<sp/>named<sp/>`param`,<sp/>you<sp/>can<sp/>also<sp/>use<sp/>the<sp/>gMock-defined<sp/>symbol</highlight></codeline>
<codeline><highlight class="normal">`param_type`<sp/>to<sp/>refer<sp/>to<sp/>the<sp/>type<sp/>of<sp/>the<sp/>parameter<sp/>as<sp/>inferred<sp/>by<sp/>the<sp/>compiler.</highlight></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>in<sp/>the<sp/>body<sp/>of<sp/>`ACTION_P(Add,<sp/>n)`<sp/>above,<sp/>you<sp/>can<sp/>write<sp/>`n_type`<sp/>for</highlight></codeline>
<codeline><highlight class="normal">the<sp/>type<sp/>of<sp/>`n`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">gMock<sp/>also<sp/>provides<sp/>`ACTION_P2`,<sp/>`ACTION_P3`,<sp/>and<sp/>etc<sp/>to<sp/>support<sp/>multi-parameter</highlight></codeline>
<codeline><highlight class="normal">actions.<sp/>For<sp/>example,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION_P2(ReturnDistanceTo,<sp/>x,<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>dx<sp/>=<sp/>arg0<sp/>-<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>dy<sp/>=<sp/>arg1<sp/>-<sp/>y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>sqrt(dx*dx<sp/>+<sp/>dy*dy);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">lets<sp/>you<sp/>write</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">...<sp/>WillOnce(ReturnDistanceTo(5.0,<sp/>26.5));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>view<sp/>`ACTION`<sp/>as<sp/>a<sp/>degenerated<sp/>parameterized<sp/>action<sp/>where<sp/>the<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal">parameters<sp/>is<sp/>0.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>also<sp/>easily<sp/>define<sp/>actions<sp/>overloaded<sp/>on<sp/>the<sp/>number<sp/>of<sp/>parameters:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION_P(Plus,<sp/>a)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">ACTION_P2(Plus,<sp/>a,<sp/>b)<sp/>{<sp/>...<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Restricting<sp/>the<sp/>Type<sp/>of<sp/>an<sp/>Argument<sp/>or<sp/>Parameter<sp/>in<sp/>an<sp/>ACTION</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>maximum<sp/>brevity<sp/>and<sp/>reusability,<sp/>the<sp/>`ACTION*`<sp/>macros<sp/>don&apos;t<sp/>ask<sp/>you<sp/>to</highlight></codeline>
<codeline><highlight class="normal">provide<sp/>the<sp/>types<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>arguments<sp/>and<sp/>the<sp/>action<sp/>parameters.</highlight></codeline>
<codeline><highlight class="normal">Instead,<sp/>we<sp/>let<sp/>the<sp/>compiler<sp/>infer<sp/>the<sp/>types<sp/>for<sp/>us.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes,<sp/>however,<sp/>we<sp/>may<sp/>want<sp/>to<sp/>be<sp/>more<sp/>explicit<sp/>about<sp/>the<sp/>types.<sp/>There<sp/>are</highlight></codeline>
<codeline><highlight class="normal">several<sp/>tricks<sp/>to<sp/>do<sp/>that.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION(Foo)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Makes<sp/>sure<sp/>arg0<sp/>can<sp/>be<sp/>converted<sp/>to<sp/>int.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>n<sp/>=<sp/>arg0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>use<sp/>n<sp/>instead<sp/>of<sp/>arg0<sp/>here<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">ACTION_P(Bar,<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Makes<sp/>sure<sp/>the<sp/>type<sp/>of<sp/>arg1<sp/>is<sp/>const<sp/>char*.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>::testing::StaticAssertTypeEq&lt;const<sp/>char*,<sp/>arg1_type&gt;();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Makes<sp/>sure<sp/>param<sp/>can<sp/>be<sp/>converted<sp/>to<sp/>bool.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>flag<sp/>=<sp/>param;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">where<sp/>`StaticAssertTypeEq`<sp/>is<sp/>a<sp/>compile-time<sp/>assertion<sp/>in<sp/>googletest<sp/>that</highlight></codeline>
<codeline><highlight class="normal">verifies<sp/>two<sp/>types<sp/>are<sp/>the<sp/>same.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Action<sp/>Templates<sp/>Quickly</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Sometimes<sp/>you<sp/>want<sp/>to<sp/>give<sp/>an<sp/>action<sp/>explicit<sp/>template<sp/>parameters<sp/>that<sp/>cannot<sp/>be</highlight></codeline>
<codeline><highlight class="normal">inferred<sp/>from<sp/>its<sp/>value<sp/>parameters.<sp/>`ACTION_TEMPLATE()`<sp/>supports<sp/>that<sp/>and<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal">viewed<sp/>as<sp/>an<sp/>extension<sp/>to<sp/>`ACTION()`<sp/>and<sp/>`ACTION_P*()`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>syntax:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ACTION_TEMPLATE(ActionName,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HAS_m_TEMPLATE_PARAMS(kind1,<sp/>name1,<sp/>...,<sp/>kind_m,<sp/>name_m),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AND_n_VALUE_PARAMS(p1,<sp/>...,<sp/>p_n))<sp/>{<sp/>statements;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">defines<sp/>an<sp/>action<sp/>template<sp/>that<sp/>takes<sp/>*m*<sp/>explicit<sp/>template<sp/>parameters<sp/>and<sp/>*n*</highlight></codeline>
<codeline><highlight class="normal">value<sp/>parameters,<sp/>where<sp/>*m*<sp/>is<sp/>in<sp/>[1,<sp/>10]<sp/>and<sp/>*n*<sp/>is<sp/>in<sp/>[0,<sp/>10].<sp/>`name_i`<sp/>is<sp/>the</highlight></codeline>
<codeline><highlight class="normal">name<sp/>of<sp/>the<sp/>*i*-th<sp/>template<sp/>parameter,<sp/>and<sp/>`kind_i`<sp/>specifies<sp/>whether<sp/>it&apos;s<sp/>a</highlight></codeline>
<codeline><highlight class="normal">`typename`,<sp/>an<sp/>integral<sp/>constant,<sp/>or<sp/>a<sp/>template.<sp/>`p_i`<sp/>is<sp/>the<sp/>name<sp/>of<sp/>the<sp/>*i*-th</highlight></codeline>
<codeline><highlight class="normal">value<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>DuplicateArg&lt;k,<sp/>T&gt;(output)<sp/>converts<sp/>the<sp/>k-th<sp/>argument<sp/>of<sp/>the<sp/>mock</highlight></codeline>
<codeline><highlight class="normal">//<sp/>function<sp/>to<sp/>type<sp/>T<sp/>and<sp/>copies<sp/>it<sp/>to<sp/>*output.</highlight></codeline>
<codeline><highlight class="normal">ACTION_TEMPLATE(DuplicateArg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Note<sp/>the<sp/>comma<sp/>between<sp/>int<sp/>and<sp/>k:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HAS_2_TEMPLATE_PARAMS(int,<sp/>k,<sp/>typename,<sp/>T),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AND_1_VALUE_PARAMS(output))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*output<sp/>=<sp/>T(std::get&lt;k&gt;(args));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>create<sp/>an<sp/>instance<sp/>of<sp/>an<sp/>action<sp/>template,<sp/>write:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ActionName&lt;t1,<sp/>...,<sp/>t_m&gt;(v1,<sp/>...,<sp/>v_n)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">where<sp/>the<sp/>`t`s<sp/>are<sp/>the<sp/>template<sp/>arguments<sp/>and<sp/>the<sp/>`v`s<sp/>are<sp/>the<sp/>value<sp/>arguments.</highlight></codeline>
<codeline><highlight class="normal">The<sp/>value<sp/>argument<sp/>types<sp/>are<sp/>inferred<sp/>by<sp/>the<sp/>compiler.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock,<sp/>Foo).WillOnce(DuplicateArg&lt;1,<sp/>unsigned<sp/>char&gt;(&amp;n));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>want<sp/>to<sp/>explicitly<sp/>specify<sp/>the<sp/>value<sp/>argument<sp/>types,<sp/>you<sp/>can<sp/>provide</highlight></codeline>
<codeline><highlight class="normal">additional<sp/>template<sp/>arguments:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">ActionName&lt;t1,<sp/>...,<sp/>t_m,<sp/>u1,<sp/>...,<sp/>u_k&gt;(v1,<sp/>...,<sp/>v_n)</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">where<sp/>`u_i`<sp/>is<sp/>the<sp/>desired<sp/>type<sp/>of<sp/>`v_i`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`ACTION_TEMPLATE`<sp/>and<sp/>`ACTION`/`ACTION_P*`<sp/>can<sp/>be<sp/>overloaded<sp/>on<sp/>the<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal">value<sp/>parameters,<sp/>but<sp/>not<sp/>on<sp/>the<sp/>number<sp/>of<sp/>template<sp/>parameters.<sp/>Without<sp/>the</highlight></codeline>
<codeline><highlight class="normal">restriction,<sp/>the<sp/>meaning<sp/>of<sp/>the<sp/>following<sp/>is<sp/>unclear:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OverloadedAction&lt;int,<sp/>bool&gt;(x);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Are<sp/>we<sp/>using<sp/>a<sp/>single-template-parameter<sp/>action<sp/>where<sp/>`bool`<sp/>refers<sp/>to<sp/>the<sp/>type</highlight></codeline>
<codeline><highlight class="normal">of<sp/>`x`,<sp/>or<sp/>a<sp/>two-template-parameter<sp/>action<sp/>where<sp/>the<sp/>compiler<sp/>is<sp/>asked<sp/>to<sp/>infer</highlight></codeline>
<codeline><highlight class="normal">the<sp/>type<sp/>of<sp/>`x`?</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Using<sp/>the<sp/>ACTION<sp/>Object&apos;s<sp/>Type</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>writing<sp/>a<sp/>function<sp/>that<sp/>returns<sp/>an<sp/>`ACTION`<sp/>object,<sp/>you&apos;ll<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal">know<sp/>its<sp/>type.<sp/>The<sp/>type<sp/>depends<sp/>on<sp/>the<sp/>macro<sp/>used<sp/>to<sp/>define<sp/>the<sp/>action<sp/>and<sp/>the</highlight></codeline>
<codeline><highlight class="normal">parameter<sp/>types.<sp/>The<sp/>rule<sp/>is<sp/>relatively<sp/>simple:</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">|<sp/>Given<sp/>Definition<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Expression<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Has<sp/>Type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>-----------------------------<sp/>|<sp/>-------------------<sp/>|<sp/>---------------------<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION(Foo)`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>`Foo()`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>`FooAction`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_TEMPLATE(Foo,<sp/>HAS_m_TEMPLATE_PARAMS(...),<sp/>AND_0_VALUE_PARAMS())`<sp/>|<sp/>`Foo&lt;t1,<sp/>...,<sp/>t_m&gt;()`<sp/>|<sp/>`FooAction&lt;t1,<sp/>...,<sp/>t_m&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_P(Bar,<sp/>param)`<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>`Bar(int_value)`<sp/><sp/><sp/><sp/>|<sp/>`BarActionP&lt;int&gt;`<sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_TEMPLATE(Bar,<sp/>HAS_m_TEMPLATE_PARAMS(...),<sp/>AND_1_VALUE_PARAMS(p1))`<sp/>|<sp/>`Bar&lt;t1,<sp/>...,<sp/>t_m&gt;(int_value)`<sp/>|<sp/>`BarActionP&lt;t1,<sp/>...,<sp/>t_m,<sp/>int&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_P2(Baz,<sp/>p1,<sp/>p2)`<sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>`Baz(bool_value,<sp/>int_value)`<sp/>|<sp/>`BazActionP2&lt;bool,<sp/>int&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>`ACTION_TEMPLATE(Baz,<sp/>HAS_m_TEMPLATE_PARAMS(...),<sp/>AND_2_VALUE_PARAMS(p1,<sp/>p2))`<sp/>|<sp/>`Baz&lt;t1,<sp/>...,<sp/>t_m&gt;(bool_value,<sp/>int_value)`<sp/>|<sp/>`BazActionP2&lt;t1,<sp/>...,<sp/>t_m,<sp/>bool,<sp/>int&gt;`<sp/>|</highlight></codeline>
<codeline><highlight class="normal">|<sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>we<sp/>have<sp/>to<sp/>pick<sp/>different<sp/>suffixes<sp/>(`Action`,<sp/>`ActionP`,<sp/>`ActionP2`,</highlight></codeline>
<codeline><highlight class="normal">and<sp/>etc)<sp/>for<sp/>actions<sp/>with<sp/>different<sp/>numbers<sp/>of<sp/>value<sp/>parameters,<sp/>or<sp/>the<sp/>action</highlight></codeline>
<codeline><highlight class="normal">definitions<sp/>cannot<sp/>be<sp/>overloaded<sp/>on<sp/>the<sp/>number<sp/>of<sp/>them.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Monomorphic<sp/>Actions<sp/>{#NewMonoActions}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">While<sp/>the<sp/>`ACTION*`<sp/>macros<sp/>are<sp/>very<sp/>convenient,<sp/>sometimes<sp/>they<sp/>are</highlight></codeline>
<codeline><highlight class="normal">inappropriate.<sp/>For<sp/>example,<sp/>despite<sp/>the<sp/>tricks<sp/>shown<sp/>in<sp/>the<sp/>previous<sp/>recipes,</highlight></codeline>
<codeline><highlight class="normal">they<sp/>don&apos;t<sp/>let<sp/>you<sp/>directly<sp/>specify<sp/>the<sp/>types<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>arguments<sp/>and</highlight></codeline>
<codeline><highlight class="normal">the<sp/>action<sp/>parameters,<sp/>which<sp/>in<sp/>general<sp/>leads<sp/>to<sp/>unoptimized<sp/>compiler<sp/>error</highlight></codeline>
<codeline><highlight class="normal">messages<sp/>that<sp/>can<sp/>baffle<sp/>unfamiliar<sp/>users.<sp/>They<sp/>also<sp/>don&apos;t<sp/>allow<sp/>overloading</highlight></codeline>
<codeline><highlight class="normal">actions<sp/>based<sp/>on<sp/>parameter<sp/>types<sp/>without<sp/>jumping<sp/>through<sp/>some<sp/>hoops.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">An<sp/>alternative<sp/>to<sp/>the<sp/>`ACTION*`<sp/>macros<sp/>is<sp/>to<sp/>implement</highlight></codeline>
<codeline><highlight class="normal">`::testing::ActionInterface&lt;F&gt;`,<sp/>where<sp/>`F`<sp/>is<sp/>the<sp/>type<sp/>of<sp/>the<sp/>mock<sp/>function<sp/>in</highlight></codeline>
<codeline><highlight class="normal">which<sp/>the<sp/>action<sp/>will<sp/>be<sp/>used.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>F&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ActionInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>~ActionInterface();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Performs<sp/>the<sp/>action.<sp/><sp/>Result<sp/>is<sp/>the<sp/>return<sp/>type<sp/>of<sp/>function<sp/>type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>F,<sp/>and<sp/>ArgumentTuple<sp/>is<sp/>the<sp/>tuple<sp/>of<sp/>arguments<sp/>of<sp/>F.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>For<sp/>example,<sp/>if<sp/>F<sp/>is<sp/>int(bool,<sp/>const<sp/>string&amp;),<sp/>then<sp/>Result<sp/>would</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>be<sp/>int,<sp/>and<sp/>ArgumentTuple<sp/>would<sp/>be<sp/>std::tuple&lt;bool,<sp/>const<sp/>string&amp;&gt;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>Result<sp/>Perform(const<sp/>ArgumentTuple&amp;<sp/>args)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::Action;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::ActionInterface;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakeAction;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">typedef<sp/>int<sp/>IncrementMethod(int*);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>IncrementArgumentAction<sp/>:<sp/>public<sp/>ActionInterface&lt;IncrementMethod&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>Perform(const<sp/>std::tuple&lt;int*&gt;&amp;<sp/>args)<sp/>override<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int*<sp/>p<sp/>=<sp/>std::get&lt;0&gt;(args);<sp/><sp/>//<sp/>Grabs<sp/>the<sp/>first<sp/>argument.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*p++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Action&lt;IncrementMethod&gt;<sp/>IncrementArgument()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakeAction(new<sp/>IncrementArgumentAction);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>Baz(_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.WillOnce(IncrementArgument());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>n<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.Baz(&amp;n);<sp/><sp/>//<sp/>Should<sp/>return<sp/>5<sp/>and<sp/>change<sp/>n<sp/>to<sp/>6.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Writing<sp/>New<sp/>Polymorphic<sp/>Actions<sp/>{#NewPolyActions}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>previous<sp/>recipe<sp/>showed<sp/>you<sp/>how<sp/>to<sp/>define<sp/>your<sp/>own<sp/>action.<sp/>This<sp/>is<sp/>all<sp/>good,</highlight></codeline>
<codeline><highlight class="normal">except<sp/>that<sp/>you<sp/>need<sp/>to<sp/>know<sp/>the<sp/>type<sp/>of<sp/>the<sp/>function<sp/>in<sp/>which<sp/>the<sp/>action<sp/>will</highlight></codeline>
<codeline><highlight class="normal">be<sp/>used.<sp/>Sometimes<sp/>that<sp/>can<sp/>be<sp/>a<sp/>problem.<sp/>For<sp/>example,<sp/>if<sp/>you<sp/>want<sp/>to<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal">action<sp/>in<sp/>functions<sp/>with<sp/>*different*<sp/>types<sp/>(e.g.<sp/>like<sp/>`Return()`<sp/>and</highlight></codeline>
<codeline><highlight class="normal">`SetArgPointee()`).</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>an<sp/>action<sp/>can<sp/>be<sp/>used<sp/>in<sp/>several<sp/>types<sp/>of<sp/>mock<sp/>functions,<sp/>we<sp/>say<sp/>it&apos;s</highlight></codeline>
<codeline><highlight class="normal">*polymorphic*.<sp/>The<sp/>`MakePolymorphicAction()`<sp/>function<sp/>template<sp/>makes<sp/>it<sp/>easy<sp/>to</highlight></codeline>
<codeline><highlight class="normal">define<sp/>such<sp/>an<sp/>action:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">namespace<sp/>testing<sp/>{</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>Impl&gt;</highlight></codeline>
<codeline><highlight class="normal">PolymorphicAction&lt;Impl&gt;<sp/>MakePolymorphicAction(const<sp/>Impl&amp;<sp/>impl);</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/>//<sp/>namespace<sp/>testing</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>an<sp/>example,<sp/>let&apos;s<sp/>define<sp/>an<sp/>action<sp/>that<sp/>returns<sp/>the<sp/>second<sp/>argument<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal">mock<sp/>function&apos;s<sp/>argument<sp/>list.<sp/>The<sp/>first<sp/>step<sp/>is<sp/>to<sp/>define<sp/>an<sp/>implementation</highlight></codeline>
<codeline><highlight class="normal">class:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ReturnSecondArgumentAction<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>Result,<sp/>typename<sp/>ArgumentTuple&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Result<sp/>Perform(const<sp/>ArgumentTuple&amp;<sp/>args)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>To<sp/>get<sp/>the<sp/>i-th<sp/>(0-based)<sp/>argument,<sp/>use<sp/>std::get(args).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>std::get&lt;1&gt;(args);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>implementation<sp/>class<sp/>does<sp/>*not*<sp/>need<sp/>to<sp/>inherit<sp/>from<sp/>any<sp/>particular<sp/>class.</highlight></codeline>
<codeline><highlight class="normal">What<sp/>matters<sp/>is<sp/>that<sp/>it<sp/>must<sp/>have<sp/>a<sp/>`Perform()`<sp/>method<sp/>template.<sp/>This<sp/>method</highlight></codeline>
<codeline><highlight class="normal">template<sp/>takes<sp/>the<sp/>mock<sp/>function&apos;s<sp/>arguments<sp/>as<sp/>a<sp/>tuple<sp/>in<sp/>a<sp/>**single**</highlight></codeline>
<codeline><highlight class="normal">argument,<sp/>and<sp/>returns<sp/>the<sp/>result<sp/>of<sp/>the<sp/>action.<sp/>It<sp/>can<sp/>be<sp/>either<sp/>`const`<sp/>or<sp/>not,</highlight></codeline>
<codeline><highlight class="normal">but<sp/>must<sp/>be<sp/>invocable<sp/>with<sp/>exactly<sp/>one<sp/>template<sp/>argument,<sp/>which<sp/>is<sp/>the<sp/>result</highlight></codeline>
<codeline><highlight class="normal">type.<sp/>In<sp/>other<sp/>words,<sp/>you<sp/>must<sp/>be<sp/>able<sp/>to<sp/>call<sp/>`Perform&lt;R&gt;(args)`<sp/>where<sp/>`R`<sp/>is</highlight></codeline>
<codeline><highlight class="normal">the<sp/>mock<sp/>function&apos;s<sp/>return<sp/>type<sp/>and<sp/>`args`<sp/>is<sp/>its<sp/>arguments<sp/>in<sp/>a<sp/>tuple.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Next,<sp/>we<sp/>use<sp/>`MakePolymorphicAction()`<sp/>to<sp/>turn<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>implementation</highlight></codeline>
<codeline><highlight class="normal">class<sp/>into<sp/>the<sp/>polymorphic<sp/>action<sp/>we<sp/>need.<sp/>It<sp/>will<sp/>be<sp/>convenient<sp/>to<sp/>have<sp/>a</highlight></codeline>
<codeline><highlight class="normal">wrapper<sp/>for<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::MakePolymorphicAction;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::PolymorphicAction;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">PolymorphicAction&lt;ReturnSecondArgumentAction&gt;<sp/>ReturnSecondArgument()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>MakePolymorphicAction(ReturnSecondArgumentAction());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now,<sp/>you<sp/>can<sp/>use<sp/>this<sp/>polymorphic<sp/>action<sp/>the<sp/>same<sp/>way<sp/>you<sp/>use<sp/>the<sp/>built-in<sp/>ones:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>::testing::_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>MockFoo<sp/>:<sp/>public<sp/>Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(int,<sp/>DoThis,<sp/>(bool<sp/>flag,<sp/>int<sp/>n),<sp/>(override));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MOCK_METHOD(string,<sp/>DoThat,<sp/>(int<sp/>x,<sp/>const<sp/>char*<sp/>str1,<sp/>const<sp/>char*<sp/>str2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(override));</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFoo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThis).WillOnce(ReturnSecondArgument());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(foo,<sp/>DoThat).WillOnce(ReturnSecondArgument());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThis(true,<sp/>5);<sp/><sp/>//<sp/>Will<sp/>return<sp/>5.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo.DoThat(1,<sp/>&quot;Hi&quot;,<sp/>&quot;Bye&quot;);<sp/><sp/>//<sp/>Will<sp/>return<sp/>&quot;Hi&quot;.</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Teaching<sp/>gMock<sp/>How<sp/>to<sp/>Print<sp/>Your<sp/>Values</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>an<sp/>uninteresting<sp/>or<sp/>unexpected<sp/>call<sp/>occurs,<sp/>gMock<sp/>prints<sp/>the<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">values<sp/>and<sp/>the<sp/>stack<sp/>trace<sp/>to<sp/>help<sp/>you<sp/>debug.<sp/>Assertion<sp/>macros<sp/>like</highlight></codeline>
<codeline><highlight class="normal">`EXPECT_THAT`<sp/>and<sp/>`EXPECT_EQ`<sp/>also<sp/>print<sp/>the<sp/>values<sp/>in<sp/>question<sp/>when<sp/>the</highlight></codeline>
<codeline><highlight class="normal">assertion<sp/>fails.<sp/>gMock<sp/>and<sp/>googletest<sp/>do<sp/>this<sp/>using<sp/>googletest&apos;s<sp/>user-extensible</highlight></codeline>
<codeline><highlight class="normal">value<sp/>printer.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>printer<sp/>knows<sp/>how<sp/>to<sp/>print<sp/>built-in<sp/>C++<sp/>types,<sp/>native<sp/>arrays,<sp/>STL</highlight></codeline>
<codeline><highlight class="normal">containers,<sp/>and<sp/>any<sp/>type<sp/>that<sp/>supports<sp/>the<sp/>`&lt;&lt;`<sp/>operator.<sp/>For<sp/>other<sp/>types,<sp/>it</highlight></codeline>
<codeline><highlight class="normal">prints<sp/>the<sp/>raw<sp/>bytes<sp/>in<sp/>the<sp/>value<sp/>and<sp/>hopes<sp/>that<sp/>you<sp/>the<sp/>user<sp/>can<sp/>figure<sp/>it<sp/>out.</highlight></codeline>
<codeline><highlight class="normal">[The<sp/>GoogleTest<sp/>advanced<sp/>guide](advanced.md#teaching-googletest-how-to-print-your-values)</highlight></codeline>
<codeline><highlight class="normal">explains<sp/>how<sp/>to<sp/>extend<sp/>the<sp/>printer<sp/>to<sp/>do<sp/>a<sp/>better<sp/>job<sp/>at<sp/>printing<sp/>your</highlight></codeline>
<codeline><highlight class="normal">particular<sp/>type<sp/>than<sp/>to<sp/>dump<sp/>the<sp/>bytes.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Useful<sp/>Mocks<sp/>Created<sp/>Using<sp/>gMock</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">&lt;!--#include<sp/>file=&quot;includes/g3_testing_LOGs.md&quot;--&gt;</highlight></codeline>
<codeline><highlight class="normal">&lt;!--#include<sp/>file=&quot;includes/g3_mock_callbacks.md&quot;--&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Mock<sp/>std::function<sp/>{#MockFunction}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`std::function`<sp/>is<sp/>a<sp/>general<sp/>function<sp/>type<sp/>introduced<sp/>in<sp/>C++11.<sp/>It<sp/>is<sp/>a</highlight></codeline>
<codeline><highlight class="normal">preferred<sp/>way<sp/>of<sp/>passing<sp/>callbacks<sp/>to<sp/>new<sp/>interfaces.<sp/>Functions<sp/>are<sp/>copyable,</highlight></codeline>
<codeline><highlight class="normal">and<sp/>are<sp/>not<sp/>usually<sp/>passed<sp/>around<sp/>by<sp/>pointer,<sp/>which<sp/>makes<sp/>them<sp/>tricky<sp/>to<sp/>mock.</highlight></codeline>
<codeline><highlight class="normal">But<sp/>fear<sp/>not<sp/>-<sp/>`MockFunction`<sp/>can<sp/>help<sp/>you<sp/>with<sp/>that.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`MockFunction&lt;R(T1,<sp/>...,<sp/>Tn)&gt;`<sp/>has<sp/>a<sp/>mock<sp/>method<sp/>`Call()`<sp/>with<sp/>the<sp/>signature:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>R<sp/>Call(T1,<sp/>...,<sp/>Tn);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It<sp/>also<sp/>has<sp/>a<sp/>`AsStdFunction()`<sp/>method,<sp/>which<sp/>creates<sp/>a<sp/>`std::function`<sp/>proxy</highlight></codeline>
<codeline><highlight class="normal">forwarding<sp/>to<sp/>Call:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::function&lt;R(T1,<sp/>...,<sp/>Tn)&gt;<sp/>AsStdFunction();</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">To<sp/>use<sp/>`MockFunction`,<sp/>first<sp/>create<sp/>`MockFunction`<sp/>object<sp/>and<sp/>set<sp/>up</highlight></codeline>
<codeline><highlight class="normal">expectations<sp/>on<sp/>its<sp/>`Call`<sp/>method.<sp/>Then<sp/>pass<sp/>proxy<sp/>obtained<sp/>from</highlight></codeline>
<codeline><highlight class="normal">`AsStdFunction()`<sp/>to<sp/>the<sp/>code<sp/>you<sp/>are<sp/>testing.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```cpp</highlight></codeline>
<codeline><highlight class="normal">TEST(FooTest,<sp/>RunsCallbackWithBarArgument)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>1.<sp/>Create<sp/>a<sp/>mock<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MockFunction&lt;int(string)&gt;<sp/>mock_function;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>2.<sp/>Set<sp/>expectations<sp/>on<sp/>Call()<sp/>method.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EXPECT_CALL(mock_function,<sp/>Call(&quot;bar&quot;)).WillOnce(Return(1));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>3.<sp/>Exercise<sp/>code<sp/>that<sp/>uses<sp/>std::function.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Foo(mock_function.AsStdFunction());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Foo&apos;s<sp/>signature<sp/>can<sp/>be<sp/>either<sp/>of:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>void<sp/>Foo(const<sp/>std::function&lt;int(string)&gt;&amp;<sp/>fun);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>void<sp/>Foo(std::function&lt;int(string)&gt;<sp/>fun);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>4.<sp/>All<sp/>expectations<sp/>will<sp/>be<sp/>verified<sp/>when<sp/>mock_function</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/>goes<sp/>out<sp/>of<sp/>scope<sp/>and<sp/>is<sp/>destroyed.</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remember<sp/>that<sp/>function<sp/>objects<sp/>created<sp/>with<sp/>`AsStdFunction()`<sp/>are<sp/>just</highlight></codeline>
<codeline><highlight class="normal">forwarders.<sp/>If<sp/>you<sp/>create<sp/>multiple<sp/>of<sp/>them,<sp/>they<sp/>will<sp/>share<sp/>the<sp/>same<sp/>set<sp/>of</highlight></codeline>
<codeline><highlight class="normal">expectations.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Although<sp/>`std::function`<sp/>supports<sp/>unlimited<sp/>number<sp/>of<sp/>arguments,<sp/>`MockFunction`</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>is<sp/>limited<sp/>to<sp/>ten.<sp/>If<sp/>you<sp/>ever<sp/>hit<sp/>that<sp/>limit...<sp/>well,<sp/>your</highlight></codeline>
<codeline><highlight class="normal">callback<sp/>has<sp/>bigger<sp/>problems<sp/>than<sp/>being<sp/>mockable.<sp/>:-)</highlight></codeline>
    </programlisting>
    <location file="build/_deps/googletest-src/docs/gmock_cook_book.md"/>
  </compounddef>
</doxygen>
